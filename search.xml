<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Gulp入门]]></title>
      <url>/2017/10/24/Gulp%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="Gulp是啥子东西？"><a href="#Gulp是啥子东西？" class="headerlink" title="Gulp是啥子东西？"></a>Gulp是啥子东西？</h2><p><img src="http://www.d1net.com/uploadfile/2017/0112/20170112092834684.png" alt=""></p>
<p>一句话简单的概括,就是一个前端项目自动化的构建工具。不理解没关系,容我慢慢道来。</p>
<p>首先要说说<code>Gulp</code>诞生的原因.</p>
<p>随着 <code>Web</code> 前端发展，前端项目变得越来越复杂，随之而来的是各种方便的工具：打包工具、转码工具、 <code>JS</code> 与 <code>CSS</code> 的合并压缩工具等等。这些工具极大的提高了我们前端的代码质量，但问题也随之而来：</p>
<p>这么多工具到底该怎么使用，难道一个个在各个工具中来回切换复制粘贴？或是在 CLI 里一条条地敲命里吗？敲完代码还要敲一堆的构建命令，说不准顺序搞错了还要功亏一篑重来一遍？</p>
<p>于是我们的构建工具 <code>Gulp</code> 就应运而生啦。</p>
<h3 id="Gulp有啥好处？"><a href="#Gulp有啥好处？" class="headerlink" title="Gulp有啥好处？"></a>Gulp有啥好处？</h3><p>首先当然是省心省力啦,<strong>一次配置,自动构建</strong>.我把我需要的功能配置出来后,以后直接用<code>Gulp</code>调用就好了,Gulp会帮我整合好我需要的功能。</p>
<p>第二个就是重复利用啦,因为配置文件的高度统一，这个配置文件几乎可以多个项目之间随便复制粘贴修修改改就可以重复使用！</p>
<h2 id="Gulp能做什么"><a href="#Gulp能做什么" class="headerlink" title="Gulp能做什么"></a>Gulp能做什么</h2><p>当你按下 <code>ctrl+s</code> 时,你发现你的电脑自动帮你编译、压缩、打包、自动刷新。你会不会觉得很爽呢？</p>
<p>下面我来说说Gulp的常用功能。</p>
<ul>
<li>静态文件的合并与压缩:JS 、css、html的压缩</li>
<li>图片(包括PNG、JPEG、GIF和SVG图片)的压缩,在不降低画质的情况下,降低图片的大小。</li>
<li>页面自动刷新,你的代码有任何变动都会刷新。</li>
<li>还有一些CSS预编译器(sass、less),ES6语法,都可以自动编译成浏览器能够识别的。</li>
<li>图片路径转base64<br>等等….<br>而这些功能的实现在配置完后你只需要做什么, <code>ctrl+s</code> !!!</li>
</ul>
<h2 id="Gulp的运行和安装"><a href="#Gulp的运行和安装" class="headerlink" title="Gulp的运行和安装"></a>Gulp的运行和安装</h2><p>关于Gulp的环境配置和安装,可以直接点击<a href="http://www.ydcss.com/archives/18" target="_blank" rel="external">这里查看教程</a>。</p>
<p>看完之后,有两个配置文件是我们一定要重视的,一个是<strong>gulpfile.js</strong>,另一个是<strong>package.json</strong>.如果其他人想要复制你的 <code>gulp</code> 功能属性,这两个文件是必须必备的。</p>
<p><strong>package.json</strong>是基于<code>nodejs</code>项目必不可少的配置文件，它是存放在项目根目录的普通json文件,里面存放是项目的一些基本配置,以及你安装的所有gulp插件.</p>
<p>当我们已经把所有的配置都安装好了之后，我们需要在gulpfile.js文件里面写我们的任务(task),我们需要在什么时候用什么插件,都要写在这里。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Flex布局]]></title>
      <url>/2017/10/24/Flex%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p>开篇我们先来看看传统的CSS布局格式,布局的传统解决方案：</p>
<p>基于盒状模型，依赖 <code>display</code> 属性 + <code>position</code>属性 + <code>float</code>属性。它对于那些特殊布局非常不方便，比如，垂直居中和绝对居中就很不容易实现。况且 <code>float</code> 用多了还得清除浮动.</p>
<h2 id="Flex是什么鬼"><a href="#Flex是什么鬼" class="headerlink" title="Flex是什么鬼?"></a>Flex是什么鬼?</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt=""></p>
<p><code>Flex</code> 是 <code>Flexible Box</code> 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 <code>Flex</code> 布局,只要加个 <code>display</code> 属性。<br>在这里先不考虑各浏览器的适配问题.在文末会提供解决方案。</p>
<p>注意，设为 <code>Flex</code> 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用 <code>Flex</code> 布局的元素，称为 <code>Flex</code> 容器（flex container），简称”<strong>容器</strong>“。它的所有子元素自动成为容器成员，称为 <code>Flex</code> 项目（flex item），简称”<strong>项目</strong>“。</p>
<p>通俗的说,就是<strong>容器</strong>是父元素,<strong>项目</strong>是子元素。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt=""></p>
<p>容器默认存在两根轴：水平的<strong>主轴</strong>（main axis）和垂直的<strong>交叉轴</strong>（cross axis）。其实就是<strong>横轴</strong>和<strong>纵轴</strong>。</p>
<h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><ul>
<li><code>flex-direction</code>(属性决定主轴的方向（即项目的排列方向))</li>
<li><code>flex-wrap</code>(<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。)</li>
<li><code>flex-flow</code>(<code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式)</li>
<li><code>justify-content</code>(定义了项目在主轴上的对齐方式)</li>
<li><code>align-items</code>(定义项目在交叉轴上如何对齐)</li>
<li><code>align-content</code>(<code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。)</li>
</ul>
<h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul>
<li><code>order</code>(性定义项目的排列顺序。数值越小，排列越靠前，默认为0。)</li>
<li><code>flex-grow</code>(属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。)</li>
<li><code>flex-shrink</code>(属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。)</li>
<li><code>flex-basis</code>(属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。)</li>
<li><code>flex</code>(是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为0 1 auto)</li>
<li><code>align-self</code>(属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性)</li>
</ul>
<p>关于 Flex 布局的语法基础就讲到这里，相信能看到这里你一定会有收获。</p>
<p>如果你看完还是一头雾水的话，没关系，可以看<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="兼容性与各浏览器差异性解决方案"><a href="#兼容性与各浏览器差异性解决方案" class="headerlink" title="兼容性与各浏览器差异性解决方案"></a>兼容性与各浏览器差异性解决方案</h2><p>通过<code>PostCSS</code>的<code>autoprefixer</code>插件,即能自动添加浏览器私有前缀,防止出现各大浏览器中展示效果不同的情况。</p>
<p>访问这篇文章<a href="http://www.xposean.xin/2017/10/24/PostCSS%E5%85%A5%E9%97%A8/" target="_blank" rel="external">《PostCSS入门》</a>。</p>
<p>如果不想麻烦使用<code>PostCSS</code>,也可以通过<code>gulp</code>安装<a href="http://www.ydcss.com/archives/94" target="_blank" rel="external">gulp-autoprefixer</a>插件,一样可以达到效果。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[PostCSS入门]]></title>
      <url>/2017/10/24/PostCSS%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我想你应该已经听说过<a href="http://postcss.com/" target="_blank" rel="external">PostCSS</a>,它比<a href="https://github.com/postcss/benchmark#preprocessors" target="_blank" rel="external">libsass</a>快了几乎两倍(并且比Ruby Sass快了28倍)； 或者听说过它支持<a href="http://cssnext.io/" target="_blank" rel="external">cssnext</a>和自动添加私有前缀而且可扩展功能,难道你一点都不好奇吗？</p>
<p>PostCSS最强大之处在于它是模块化并且基于插件的架构，不过这也是个缺点。如果你之前在项目中使用Sass(比如大多数的设计师和前端开发者)，你从不需要配置任何东西——Sass内置了全部实用功能，开箱即用。 然而，PostCSS需要你做一些配置。你不得不从一眼看不到底的<a href="https://github.com/postcss/postcss/blob/master/docs/plugins.md" target="_blank" rel="external">插件列表</a>选择插件并且自己把全部插件一起配置。但这同时意味着它的自定义程度高,足够实现你想要的。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>PostCSS在以惊人的速度发展，而且越来越受人欢迎。越来越多的人开始在了解它，使用它。因为他们意识到，在项目中使用PostCSS让他们意识到了眼前一亮。</p>
<p><img src="http://www.w3cplus.com/sites/default/files/blogs/2015/1510/postcssdownloads.png" alt=""></p>
<p>2014年总共不到140万的下载量，但从2015年1月份到6月份已经超过380万个下载。</p>
<p><strong><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="external">Autoprefixer</a></strong>是PostCSS中最流行的插件，其中Google、Shopify、Twitter、Bootstrap和Codepen都在使用这个插件。Wordpress也使用Autoprefixer插件，而且还使用RTLCSS插件。Alibaba使用了几个PostCSS插件，以及也参加PostCSS的开发。</p>
<h2 id="运行PostCSS"><a href="#运行PostCSS" class="headerlink" title="运行PostCSS"></a>运行PostCSS</h2><p>运行PostCSS的方法有很多种。你可以很容易地将它添加到Gulp、webpack的构建过程中；<br>或者是通过最简单的方式,即postcss-cli来构建都是OK的,但因为我是习惯使用gulp,所以接下来介绍的是通过gulp配置,如果想使用其他方式构建，请自行度娘或google。</p>
<p>在已经安装了gulp的配置环境下,我们直接开始进行postCSS的配置.</p>
<h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><p>首先在你的项目中创建两个文件夹，一个命名为src，另一个命名为dest。src文件夹用来放置未处理的CSS文件，而dest用来放置PostCSS插件处理后的文件。</p>
<p>接下来需要做的就是在你的项目中安装gulp-postcss插件，安装好之后就可以使用PostCSS处理器。</p>
<p>打开你的命令终端(CMD)，并且进入到你的项目根目录下，然后在命令终端输入下面的命令：</p>
<pre><code>npm install --save-dev gulp-postcss
</code></pre><p>安装完成后你的项目结构看起来就应该像这样：<br><img src="http://www.w3cplus.com/sites/default/files/blogs/2015/1510/gulpproject.png" alt=""></p>
<p>现在通过编辑器打开gulpfile.js文件，并且创建gulp和gulp-postcss变量，如下面代码所示：</p>
<pre><code>var gulp = require(&apos;gulp&apos;); 
var postcss = require(&apos;gulp-postcss&apos;);
</code></pre><p>那我们现在可以设置一个任务，让PostCSS读取CSS原文件并且处理它。</p>
<p>添加的代码如下：</p>
<pre><code>gulp.task(&apos;css&apos;, function () {
  var processors = [ ];
  return gulp.src(&apos;./src/*.css&apos;).pipe(postcss(processors)).pipe(gulp.dest(&apos;./dest&apos;)); 
});
</code></pre><p>我们一起来看一下上面的代码。在第一行，设置了一个任务名叫css。这个任务将会执行一个函数，同时在这个函数中创建了一个名为processors的数组。现在这个数组为空，这里将插入我们想使用的PostCSS插件。<br>在processors数组后面，我们指定了需要处理的目标文件，即src目录中的任何CSS文件。</p>
<p>这里面使用了两个.pipe()函数，设置postcss()执行PostCSS，并且给postcss()传递processors参数，后面会告诉PostCSS要使用哪个插件。</p>
<p>接下来的第二个.pipe()函数，指定结过PostCSS处理后的CSS放置在dest文件夹中。</p>
<h3 id="添加PostCSS插件"><a href="#添加PostCSS插件" class="headerlink" title="添加PostCSS插件"></a>添加PostCSS插件</h3><p>假设,现在我们添加需要的PostCSS插件：<strong>Autoprefixer</strong>(处理浏览器私有前缀)著作权归作者所有。<br>运行下面的命令，将插件安装到你的项目:</p>
<pre><code>npm install autoprefixer --save-dev
</code></pre><p>接下来，在我们的项目中定义变量，将这些插件加载到我们的项目中。和前面的方式一样，在<strong>gulpfile.js</strong>文件中添加下面的代码：</p>
<pre><code>var autoprefixer = require(&apos;autoprefixer&apos;);
</code></pre><p>然后将这个插件添加到processors数组中，更新后的数组如下：</p>
<pre><code>var processors = [ autoprefixer];
</code></pre><p>插件已经添加到了<code>processors</code>数组中了，这个时候<code>PostCSS</code>会知道将这些插件功能应用到我们的CSS源文件中。</p>
<h3 id="测试编译"><a href="#测试编译" class="headerlink" title="测试编译"></a>测试编译</h3><p>在src目录中创建一个测试文件style.css，并在这个文件中添加一些CSS的测试代码：</p>
<pre><code> /* Testing autoprefixer */ 
.autoprefixer { display: flex; }
</code></pre><p>在命令终端执行<code>gulp css</code>命令。在dest目录生成的文件会有下面的代码：</p>
<pre><code>/* Testing autoprefixer */ 
.autoprefixer { 
    display: -webkit-box;
    display: -webkit-flex;
    display: -ms-flexbox;
    display: flex; 
}
</code></pre><p>如上面编译出来的代码你应该看到了Autoprefixer给需要的属性添加了浏览器的私有前缀，编译符合需求的代码。</p>
<h4 id="设置插件选项"><a href="#设置插件选项" class="headerlink" title="设置插件选项"></a>设置插件选项</h4><p>注：每一个插件都有对应的配置参数选项，如果你想为一个插件配置选项参数，你可以在gulpfile.js文件中,在插件后面添加一对括号，并在里面传递选项的参数。例如，Autoprefixer需要指定对应的浏览器列表参数，你可以像这样设置：</p>
<pre><code>var processors = [ 
    autoprefixer({browsers: [&apos;last 1 version&apos;]})
];
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>通过<code>npm</code>(或<code>cnpm</code>)创建项目，并且将<code>gulp</code>安装到<code>gulpfile</code>文件</li>
<li>安装<code>gulp-postcss</code>插件</li>
<li>设置你的<code>gulpfile.js</code>文件，将<code>gulp</code>和<code>gulp-postcss</code>加载到项目中</li>
<li>创建一个任务，来编译你的<code>CSS</code></li>
<li>在任务中，设置一个<code>processors</code>数组</li>
<li>在<code>.pipe()</code>设置<code>一个postcss()</code>函数，并且将<code>processors</code>传递给它</li>
</ol>
<p>你可以根据上面的教程介绍，遵循相同的步骤，你可以将<code>PostCSS</code>任何插件安装到项目中。</p>
<p>通过<code>npm install &lt;plugin_name&gt; –save-dev</code> 命令将插件安装到你的项目中<br>类似<code>var autoprefixer = require(&quot;autoprefixer&quot;)</code>代码在你的<code>gulpfile.js</code>文件中定义要加载的插件变量名<br>将变量名添加到你的<code>preprocessors</code>数组中</p>
]]></content>
      
        
    </entry>
    
  
  
    
  
</search>
