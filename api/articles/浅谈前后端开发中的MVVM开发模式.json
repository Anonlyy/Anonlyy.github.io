{"title":"浅谈前后端开发中的MVVM开发模式","uid":"08c4771ec9e4c3675f85bffbb0600e94","slug":"浅谈前后端开发中的MVVM开发模式","date":"2018-01-17T02:00:21.000Z","updated":"2022-03-30T02:35:15.675Z","comments":true,"path":"api/articles/浅谈前后端开发中的MVVM开发模式.json","keywords":null,"cover":"https://image.xposean.top/blogImage/0012.png","content":"<p>之前在我的博客也写过关于MVVM模式的简单介绍,但不够详细,也因为对 MVVM 模式一直只是模模糊糊的认识，现在就给大家讲一下详细讲下MVVM模式为何物.</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><code>MVVM</code> 源自于经典的 Model–View–Controller（MVC）模式（期间还演化出了 Model-View-Presenter（MVP）模式，可忽略不计）。<br>MVC模式的业务逻辑主要集中在Controller，而前端的View其实已经具备了独立处理用户事件的能力，当每个事件都流经Controller时，这层会变得十分臃肿。</p>\n<p><code>MVVM</code> 的出现促进了 GUI 前端开发与后端业务逻辑的分离，极大地提高了前端开发效率。MVVM 的核心是 <strong>ViewModel层</strong>，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p>\n<p><img src=\"https://i.imgur.com/naMyZKg.png\"></p>\n<p>MVVM 已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。KnockoutJS 是最早实现 MVVM 模式的前端框架之一，当下流行的 MVVM 框架有 <code>Vue</code>，<code>Angular</code> 等。</p>\n<h2 id=\"MVVM架构组成\"><a href=\"#MVVM架构组成\" class=\"headerlink\" title=\"MVVM架构组成\"></a>MVVM架构组成</h2><p><img src=\"https://i.imgur.com/seNdEI9.png\"></p>\n<h3 id=\"View-层\"><a href=\"#View-层\" class=\"headerlink\" title=\"View 层\"></a>View 层</h3><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Marko、Pug、Jinja2等等，各大 MVVM 框架如 KnockoutJS，Vue，Angular 等也都有自己用来构建用户界面的内置模板语言。</p>\n<hr>\n<h3 id=\"Model-层\"><a href=\"#Model-层\" class=\"headerlink\" title=\"Model 层\"></a>Model 层</h3><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。后端的处理通常会非常复杂：</p>\n<p>后端业务处理再复杂跟我们前端也没有半毛钱关系，只要后端保证对外接口足够简单就行了，我请求api，你把数据返出来，咱俩就这点关系，其他都扯淡。</p>\n<hr>\n<h3 id=\"ViewModel-层\"><a href=\"#ViewModel-层\" class=\"headerlink\" title=\"ViewModel 层\"></a>ViewModel 层</h3><p><code>ViewModel</code> 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 <code>Model</code> 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 <code>ViewModel</code> 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示），而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 <code>ViewModel</code> 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。由于实现了双向绑定，<code>ViewModel</code> 的内容会实时展现在 <code>View</code> 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 <code>DOM</code> 去更新视图，<code>MVVM</code> 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 <code>ViewModel</code>，更新数据视图就会自动得到相应更新，真正实现数据驱动开发。看到了吧，<code>View</code> 层展现的不是 <code>Model</code> 层的数据，而是 <code>ViewModel</code> 的数据，由 <code>ViewModel</code> 负责与 <code>Model</code> 层交互，这就完全解耦了<code> View</code> 层和 <code>Model</code> 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p>\n<hr>\n<h2 id=\"举一个栗子\"><a href=\"#举一个栗子\" class=\"headerlink\" title=\"举一个栗子\"></a>举一个栗子</h2><p>扯了这么多，并没有什么卵用。千言万语不如一个栗子来的干脆，下面用一个 Vue 实例来说明 MVVM 的具体表现。</p>\n<p>Vue 的 View 模板：</p>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;\n    &lt;button @click=&quot;showMessage()&quot;&gt;Click me&lt;/button&gt;\n&lt;/div&gt;\n</code></pre>\n<p>Vue 的 ViewModel 层（下面是伪代码）：</p>\n<pre><code>var app = new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;     // 用于描述视图状态（有基于 Model 层数据定义的，也有纯前端定义）\n        message: &#39;Hello Vue!&#39;,  // 纯前端定义\n        server: &#123;&#125;, // 存放基于 Model 层数据的二次封装数据\n    &#125;,\n    methods: &#123;  // 用于描述视图行为（完全前端定义）\n        showMessage()&#123;\n            let vm = this;\n            alert(vm.message);\n        &#125;\n    &#125;,\n    created()&#123;\n            let vm = this;\n    \n            // Ajax 获取 Model 层的数据\n            this.$axios.get(&#39;/your/server/data/api&#39;).then(\n                result=&gt;&#123;console.log(result);&#125;\n            );\n        &#125;\n&#125;)\n \n</code></pre>\n<p>在MVVM中，我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为（格式化数据由View的负责），这里可以把它理解为一个类似json的数据对象。</p>\n<pre><code>&#123;\n    &quot;url&quot;: &quot;/your/server/data/api&quot;,\n    &quot;res&quot;: &#123;\n        &quot;success&quot;: true,\n        &quot;name&quot;: &quot;IoveC&quot;,\n        &quot;domain&quot;: &quot;www.cnblogs.com&quot;\n    &#125;\n&#125;\n</code></pre>\n<p>这就是完整的 MVVM 编程模式。</p>\n<h2 id=\"MVVM的优点\"><a href=\"#MVVM的优点\" class=\"headerlink\" title=\"MVVM的优点\"></a>MVVM的优点</h2><p>1.<strong>低耦合</strong><br>视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>\n<p>2.<strong>可重用性</strong><br>你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>\n<p>3.<strong>前后端协同开发</strong><br>开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p>\n<p>4.<strong>容易测试</strong><br>界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>\n","text":"之前在我的博客也写过关于MVVM模式的简单介绍,但不够详细,也因为对 MVVM 模式一直只是模模糊糊的认识，现在就给大家讲一下详细讲下MVVM模式为何物. 概述MVVM 源自于经典的 Model–View–Controller（MVC）模式（期间还演化出了 Model-View-...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"前端","slug":"前端","count":13,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":13,"path":"api/tags/前端.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MVVM%E6%9E%B6%E6%9E%84%E7%BB%84%E6%88%90\"><span class=\"toc-text\">MVVM架构组成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#View-%E5%B1%82\"><span class=\"toc-text\">View 层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Model-%E5%B1%82\"><span class=\"toc-text\">Model 层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ViewModel-%E5%B1%82\"><span class=\"toc-text\">ViewModel 层</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%B8%80%E4%B8%AA%E6%A0%97%E5%AD%90\"><span class=\"toc-text\">举一个栗子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MVVM%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">MVVM的优点</span></a></li></ol>","author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}},"mapped":true,"prev_post":{"title":"移动设备引发的一像素边框问题","uid":"87f74f29e587dfbe6578c326f4dc0a70","slug":"移动设备引发的一像素边框问题","date":"2018-02-27T01:41:55.000Z","updated":"2022-03-30T02:35:15.678Z","comments":true,"path":"api/articles/移动设备引发的一像素边框问题.json","keywords":null,"cover":"https://image.xposean.top/blogImage/0017.png","text":"熟悉移动web开发的同学一定对1像素边框问题不陌生,随着移动端web项目越来越多,要求也越来越高，好多设计师都发现了，你们前端实现的边线为什么这么粗的，根本不是1像素，好吗？一句很普通的border: 1px solid white;在PC端浏览器上会正常显示1px的边框,然而放...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"前端","slug":"前端","count":13,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":13,"path":"api/tags/前端.json"}],"author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}}},"next_post":{"title":"深入研究微信小程序的wepy框架","uid":"406a9d044b09e92171b60ddb7efe0ee1","slug":"深入研究微信小程序的wepy框架","date":"2017-12-30T05:24:28.000Z","updated":"2022-03-30T02:35:15.676Z","comments":true,"path":"api/articles/深入研究微信小程序的wepy框架.json","keywords":null,"cover":[],"text":"小程序现状微信小程序自发布到如今已经有半年多的时间了,凭借微信平台的强大影响力，越来越多企业加入小程序开发。 小程序于传统web页和APP比相比，有以下优势： 小程序拥有更多的能力，包括定位、录音、文件、媒体、各种硬件能力等，想象空间更大 运行在微信内部，体验更接近APP 在过度...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"小程序","slug":"小程序","count":1,"path":"api/categories/小程序.json"}],"tags":[{"name":"小程序","slug":"小程序","count":1,"path":"api/tags/小程序.json"}],"author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}}}}