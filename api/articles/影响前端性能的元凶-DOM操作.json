{"title":"影响前端性能的元凶:DOM操作","uid":"decb2ba92766b9621e5fcb0aeee2cd50","slug":"影响前端性能的元凶-DOM操作","date":"2019-09-01T13:42:09.000Z","updated":"2022-03-30T02:35:15.672Z","comments":true,"path":"api/articles/影响前端性能的元凶-DOM操作.json","keywords":null,"cover":"https://image.xposean.top/blogImage/0018.png","content":"<p>今天我们来谈谈影响前端性能的主要元凶:<strong>DOM操作.</strong></p>\n<h2 id=\"重视DOM操作的原因\"><a href=\"#重视DOM操作的原因\" class=\"headerlink\" title=\"重视DOM操作的原因?\"></a>重视DOM操作的原因?</h2><p>在<strong>PC浏览器</strong>的时代,一般的小批量重绘或回流是感觉不出浏览器卡顿的,这主要是因为PC端的浏览器性能强而且网速够快,但到了如今我们的<strong>移动浏览器</strong>时代,轻微的DOM操作,在我们性能稍弱,网速不够快的移动浏览器上,影响性能的表现就会很明显了。</p>\n<h2 id=\"DOM操作为什么会影响性能\"><a href=\"#DOM操作为什么会影响性能\" class=\"headerlink\" title=\"DOM操作为什么会影响性能\"></a>DOM操作为什么会影响性能</h2><p>在浏览器中，<code>DOM</code>的实现和<code>ECMAScript</code>的实现是分离的。所以通过<code>JavaScript</code>代码调用DOM接 口，相当于两个独立模块的交互。相比较在同一模块中的调用，这种跨模块的调用其性能损耗是很高的。但<code>DOM</code>操作对性能影响最大其实还是因为它导致了浏览器 的<strong>重绘</strong>和<strong>回流</strong>。</p>\n<p><strong>重绘</strong>（repaint）:当前元素的颜色样式(背景颜色、字体颜色等)发生改变的时候，我们只需要把改变的元素重新的渲染一下即可，重绘主要改变外观风格（改个颜色，换个皮肤），不改变布局，不影响其他的dom。</p>\n<p><strong>回流</strong>（reflow）:指浏览器为了重新渲染部分或者全部的文档而重新计算文档中元素的位置和几何构造的过程。如<code>DOM</code>元素的增删、位置移动、尺寸大小的改变以及浏览器窗口尺寸改变。每个页面至少会有一次回流,就是在页面初次渲染的时候。</p>\n<p>这其中,重绘对浏览器的性能影响较小,一般不做优化，但是能避免最好.主要是回流需要尽可能避免和优化。</p>\n<h2 id=\"浏览器的渲染原理\"><a href=\"#浏览器的渲染原理\" class=\"headerlink\" title=\"浏览器的渲染原理\"></a>浏览器的渲染原理</h2><p>在渲染页面的过程中，浏览器会通过解析HTML文档来构建DOM树，解析<code>CSS</code>产生<code>CSS</code>规则树。<code>JavaScript</code>代码在解析过程中， 可能会修改生成的<code>DOM树</code>和<code>CSS</code>规则树。之后根据<code>DOM</code>树和<code>CSS</code>规则树构建渲染树，在这个过程中<code>CSS</code>会根据选择器匹配HTML元素。渲染树包括了每 个元素的大小、边距等样式属性，渲染树中不包含隐藏元素及<code>head</code>元素等不可见元素。最后浏览器根据元素的坐标和大小来计算每个元素的位置，并绘制这些元 素到页面上。重绘指的是页面的某些部分要重新绘制，比如颜色或背景色的修改，元素的位置和尺寸并没用改变；回流则是元素的位置或尺寸发生了改变，浏览器需 要重新计算渲染树，导致渲染树的一部分或全部发生变化。渲染树重新建立后，浏览器会重新绘制页面上受影响的元素。</p>\n<p><img src=\"https://image.xposean.top/20210421101856.png\"></p>\n<p>这就是DOM树<br><img src=\"https://image.xposean.top/20210421094331.png\" alt=\"DOM树\"></p>\n<p><strong>回流</strong>的代价比<strong>重绘</strong>的代价高很多，重绘会影响部分的元素，而回流则有可能影响全部的元素。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：回流必将引起重绘，而重绘不一定会引起回流。</p></blockquote>\n<h2 id=\"那我们怎样优化和避免重绘和回流\"><a href=\"#那我们怎样优化和避免重绘和回流\" class=\"headerlink\" title=\"那我们怎样优化和避免重绘和回流?\"></a>那我们怎样优化和避免重绘和回流?</h2><h3 id=\"1-合并多次的DOM操作为单次的DOM操作\"><a href=\"#1-合并多次的DOM操作为单次的DOM操作\" class=\"headerlink\" title=\"1. 合并多次的DOM操作为单次的DOM操作\"></a>1. 合并多次的DOM操作为单次的DOM操作</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'content'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//多次的DOM操作</span>\nelement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>borderColor <span class=\"token operator\">=</span> <span class=\"token string\">'white'</span><span class=\"token punctuation\">;</span>\nelement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>borderStyle <span class=\"token operator\">=</span> <span class=\"token string\">'solid'</span><span class=\"token punctuation\">;</span>\nelement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>borderWidth <span class=\"token operator\">=</span> <span class=\"token string\">'1px'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//优化方案:1.可合并为一次</span>\nelement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>cssText <span class=\"token operator\">+=</span> <span class=\"token string\">'border: 1px solid white;background-color:green;'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//2.添加className</span>\nelement<span class=\"token punctuation\">.</span>className <span class=\"token operator\">+=</span> <span class=\"token string\">'empty'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"2-把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上\"><a href=\"#2-把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上\" class=\"headerlink\" title=\"2.把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上\"></a>2.把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上</h3><p>把DOM元素从页面流中脱离或隐藏，这样处理后，只会在DOM元素脱离和添加时，或者是隐藏和显示时才会造成页面的重绘或回流，对脱离了页面布局流的DOM元素操作就不会导致页面的性能问题。这种方式适合那些需要大批量修改DOM元素的情况。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> myElement <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'content'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyElement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>display <span class=\"token operator\">=</span> <span class=\"token string\">'none'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 一些基于myElement的大量DOM操作</span>\n<span class=\"token operator\">...</span>\nmyElement<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>display <span class=\"token operator\">=</span> <span class=\"token string\">'block'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-克隆DOM元素到内存中\"><a href=\"#3-克隆DOM元素到内存中\" class=\"headerlink\" title=\"3.克隆DOM元素到内存中\"></a>3.克隆DOM元素到内存中</h3><p>这种方式是把页面上的DOM元素克隆一份到内存中，然后再在内存中操作克隆的元素，操作完成后使用此克隆元素替换页面中原来的DOM元素。这样一来，<strong>影响性能的操作就只是最后替换元素的这一步操作了，在内存中操作克隆元素不会引起页面上的性能损耗</strong>。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> old <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'content'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> newElement<span class=\"token operator\">=</span> old<span class=\"token punctuation\">.</span><span class=\"token function\">cloneNode</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//复制DOM元素到内存中</span>\n<span class=\"token comment\">// 一些基于clone的大量DOM 操作</span>\n<span class=\"token operator\">...</span>\n<span class=\"token comment\">//替换原来DOM元素</span>\nold<span class=\"token punctuation\">.</span>parentNode<span class=\"token punctuation\">.</span><span class=\"token function\">replaceChild</span><span class=\"token punctuation\">(</span>newElement<span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"4-使用JS模板引擎\"><a href=\"#4-使用JS模板引擎\" class=\"headerlink\" title=\"4.使用JS模板引擎\"></a>4.使用JS模板引擎</h3><p>在大批量的<code>DOM</code>元素操作,其实最方便或最有效的操作,应该是使用JS模板引擎,例如有<code>artTemplate</code>、<code>Mustache</code>等</p>\n<h3 id=\"5-使用Virtual-DOM\"><a href=\"#5-使用Virtual-DOM\" class=\"headerlink\" title=\"5.使用Virtual DOM.\"></a>5.使用Virtual DOM.</h3><p>这也是目前主流的前端框架(<code>Reac</code>t、<code>Vue</code>、<code>Angular</code>)所使用的方式,将会在<a href=\"/2019/09/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%B8%8EVirtual-DOM%E7%9B%B8%E5%85%B3\">下一节</a>详细讲述。</p>\n","feature":true,"text":"今天我们来谈谈影响前端性能的主要元凶:DOM操作. 重视DOM操作的原因?在PC浏览器的时代,一般的小批量重绘或回流是感觉不出浏览器卡顿的,这主要是因为PC端的浏览器性能强而且网速够快,但到了如今我们的移动浏览器时代,轻微的DOM操作,在我们性能稍弱,网速不够快的移动浏览器上,影...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":13,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":13,"path":"api/tags/前端.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A7%86DOM%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">重视DOM操作的原因?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DOM%E6%93%8D%E4%BD%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">DOM操作为什么会影响性能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">浏览器的渲染原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%82%A3%E6%88%91%E4%BB%AC%E6%80%8E%E6%A0%B7%E4%BC%98%E5%8C%96%E5%92%8C%E9%81%BF%E5%85%8D%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81\"><span class=\"toc-text\">那我们怎样优化和避免重绘和回流?</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%90%88%E5%B9%B6%E5%A4%9A%E6%AC%A1%E7%9A%84DOM%E6%93%8D%E4%BD%9C%E4%B8%BA%E5%8D%95%E6%AC%A1%E7%9A%84DOM%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1. 合并多次的DOM操作为单次的DOM操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%8A%8ADOM%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F%E5%90%8E%E4%BF%AE%E6%94%B9%E3%80%81%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E5%BA%94%E7%94%A8%E5%88%B0position%E5%B1%9E%E6%80%A7%E4%B8%BAabsolute%E6%88%96fixed%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8A\"><span class=\"toc-text\">2.把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%85%8B%E9%9A%86DOM%E5%85%83%E7%B4%A0%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD\"><span class=\"toc-text\">3.克隆DOM元素到内存中</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8JS%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">4.使用JS模板引擎</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BD%BF%E7%94%A8Virtual-DOM\"><span class=\"toc-text\">5.使用Virtual DOM.</span></a></li></ol></li></ol>","author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}},"mapped":true,"prev_post":{"title":"一文带你知晓HTTP/2","uid":"6886a329624b279c7fd485ea2219eb1f","slug":"一文带你了解HTTP-2的优势","date":"2020-12-22T02:41:40.000Z","updated":"2022-03-30T02:35:15.668Z","comments":true,"path":"api/articles/一文带你了解HTTP-2的优势.json","keywords":null,"cover":"https://image.xposean.top/blogImage/0016.png","text":"前言作为一个经常跟web 打交道的程序员，了解HTTP协议是必须的, 通过本文, 希望能够让你了解到一些关于HTTP协议和HTTP&#x2F;2的基本概念和优劣势,如有不对的地方请指出。 HTTP协议HTTP的全称是超文本传输协议 (HyperText Transfer Prot...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"网络","slug":"网络","count":3,"path":"api/categories/网络.json"}],"tags":[{"name":"网络","slug":"网络","count":3,"path":"api/tags/网络.json"}],"author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}},"feature":true},"next_post":{"title":"你听过JS的Event Loop吗","uid":"b3ec5d64b85b68cc27c66fb82f00e4d5","slug":"你听过JS的Event-Loop吗","date":"2021-04-01T08:38:21.000Z","updated":"2022-03-30T02:35:15.669Z","comments":true,"path":"api/articles/你听过JS的Event-Loop吗.json","keywords":null,"cover":"https://image.xposean.top/blogImage/001.png","text":"前言不得不说, Event Loop在面试中的频率真的很高, 之前总觉得自己了解得差不多，可是当第一次被问到的时候，却不知道该从哪里开始说起，涉及到的知识点很多。于是花时间梳理了一下,并不仅仅是因为面试遇到了，而是理解JavaScript事件循环机制也能让我们平常遇到的疑惑也得到...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/tags/JavaScript.json"}],"author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}}}}