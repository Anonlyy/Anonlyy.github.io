{"title":"你好, 请你解释一下浏览器缓存策略","uid":"f72948e64ab8542e417504906d3a8265","slug":"你好-请你解释一下浏览器缓存策略","date":"2021-01-15T08:08:44.000Z","updated":"2022-03-30T02:35:15.669Z","comments":true,"path":"api/articles/你好-请你解释一下浏览器缓存策略.json","keywords":null,"cover":"https://image.xposean.top/blogImage/008.png","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前段时间, 被面试官问了一个之前完全没有留意的问题, 你知道什么是浏览器的缓存策略吗？知道的话,能不能解释一下缓存策略的内容, 这下可把我问懵了, 毕竟那会对于浏览器缓存只是一知半解, 更别说浏览器缓存策略了, 于是下定决定查阅了相关资料, 于是才有了这篇文章。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>浏览器缓存策略的目的是为了可以降低资源的重复加载, 并提高网页的整体加载速度。</p>\n<p>通常缓存策略可分为两种: <strong>强缓存</strong>和<strong>协商缓存</strong></p>\n<h3 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h3><ol>\n<li><p>浏览器加载资源时, 首先通过 响应头中的<code>Expires</code>(时间值)、 <code>Cache-Control</code> (相对值)验证强缓存是否可用, 如可用, 则直接从缓存读取资源，不会发请求到服务器。</p>\n</li>\n<li><p>否则进入协商缓存，即发送 <code>HTTP</code> 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>这些条件请求字段检查资源是否更新</p>\n</li>\n<li><p>若命中缓存,则返回<code>304</code>状态码，告诉浏览器直接从缓存获取资源</p>\n</li>\n<li><p>若没有命中, 则直接从服务器加载资源</p>\n</li>\n</ol>\n<h3 id=\"异同点\"><a href=\"#异同点\" class=\"headerlink\" title=\"异同点\"></a>异同点</h3><p>相同的地方: 如果命中, 都是从客户端中读取缓存, 而不是从服务端加载数据。</p>\n<p>不同的地方: 强缓存不发送请求到服务端, 而协商缓存会请求到服务端。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>那我们怎么区分一个请求是使用了协商缓存或强缓存呢？</p></blockquote>\n<p>十分简单, 通过<code>HTTP</code>状态码即可得知</p>\n<p>命中强缓存的请求, <code>Status Code</code>为<code>200 (from memory cache)</code>或 <code>200(from disk  cache)</code></p>\n<p><img src=\"https://image.xposean.top/20210115163448.png\"></p>\n<p>命中协商缓存的, <code>Status Code</code>为304</p>\n<hr>\n<h2 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h2><p>强缓存就是通过<code>Expires</code>和<code>Cache-Control</code>两种<strong>响应头</strong>实现</p>\n<h3 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a><strong>Expires</strong></h3><p><code>Expires</code>即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token literal-property property\">Expires</span><span class=\"token operator\">:</span> Wed<span class=\"token punctuation\">,</span> <span class=\"token number\">22</span> Nov <span class=\"token number\">2019</span> <span class=\"token number\">08</span><span class=\"token operator\">:</span><span class=\"token number\">41</span><span class=\"token operator\">:</span><span class=\"token number\">00</span> <span class=\"token constant\">GMT</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>表示资源在<em>2019年11月22号8点41分</em>过期，过期了就得向服务端发请求。</p>\n<p>这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器本地的时间可能并不一致，那么服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的<code>HTTP1.1</code>版本中被抛弃了。</p>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a><strong>Cache-Control</strong></h3><p>在<code>HTTP1.1</code>中，采用了一个非常关键的字段：<code>Cache-Control</code>。这个字段也是存在于响应头中的.</p>\n<p>它和<code>Expires</code>本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是<code>max-age</code>。比如这个例子:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Cache<span class=\"token operator\">-</span>Control<span class=\"token operator\">:</span>max<span class=\"token operator\">-</span>age<span class=\"token operator\">=</span><span class=\"token number\">3600</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>代表这个响应返回后在 <strong>3600 秒</strong>，也就是一个小时之内可以直接使用缓存。</p>\n<p><code>cache-control</code>其实可以组合非常多的指令，完成更多场景的缓存判断, 如下图所示：</p>\n<p><img src=\"https://image.xposean.top/20210115165642.png\"></p>\n<p>更多的详情可以查看: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\">cache-control文档</a></p>\n<p>值得注意的是, <code>cache-control</code>中<strong>禁用缓存</strong>的指令不是 <code>no-cache</code>, <code>no-cache</code>表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。真正禁用缓存的指令是<code> no-store</code></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p><code>Expires</code> 是<code>http1.0</code>的产物，<code>Cache-Control</code> 是<code>http1.1</code>的产物。</p>\n<p><code>Cache-Control</code> 相对于 <code>Expires</code> 更加准确，它的优先级也更高, </p>\n<p><strong>当两者都存在时, <code>Cache-Control</code>会优先考虑;</strong> 在某些不支持<code>HTTP1.1</code>的环境下，<code>Expires</code>就会发挥用处。所以<code>Expires</code>其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p>\n<h2 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h2><p>当浏览器对某个资源的请求没有命中强缓存时，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的<code>http</code>状态为304并且会显示一个<code>Not Modified</code>的字符串</p>\n<p>而协商缓存是利用的是<code>Last-Modified/If-Modified-Since</code>和<code>ETag/If-None-Match</code>这两对<code>Header</code>来管理的, 这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存中的两个 tag 不一样。</p>\n<h3 id=\"If-Modified-since-x2F-Last-Modified\"><a href=\"#If-Modified-since-x2F-Last-Modified\" class=\"headerlink\" title=\"If-Modified-since&#x2F;Last-Modified\"></a><strong>If-Modified-since&#x2F;Last-Modified</strong></h3><p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Last<span class=\"token operator\">-</span>Modified<span class=\"token operator\">:</span> Fri<span class=\"token punctuation\">,</span> <span class=\"token number\">22</span> Jul <span class=\"token number\">2016</span> <span class=\"token number\">01</span><span class=\"token operator\">:</span><span class=\"token number\">47</span><span class=\"token operator\">:</span><span class=\"token number\">00</span> <span class=\"token constant\">GMT</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">If<span class=\"token operator\">-</span>Modified<span class=\"token operator\">-</span>Since<span class=\"token operator\">:</span> Fri<span class=\"token punctuation\">,</span> <span class=\"token number\">27</span> Oct <span class=\"token number\">2017</span> <span class=\"token number\">06</span><span class=\"token operator\">:</span><span class=\"token number\">35</span><span class=\"token operator\">:</span><span class=\"token number\">57</span> <span class=\"token constant\">GMT</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，其实会和这个服务器中该资源的最后修改时间对比:</p>\n<ul>\n<li>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li>\n<li>否则返回304，告诉浏览器直接用缓存。响应头中不会再添加 <code>Last-Modified</code> 字段</li>\n</ul>\n<h3 id=\"If-None-Match-x2F-ETag\"><a href=\"#If-None-Match-x2F-ETag\" class=\"headerlink\" title=\"If-None-Match&#x2F;ETag\"></a><strong>If-None-Match&#x2F;ETag</strong></h3><p><code>ETag</code> 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。</p>\n<p>浏览器接收到<code>ETag</code>的值，会在下次请求时，将这个值作为<code>If-None-Match</code>这个字段的内容，并放到请求头中，然后发给服务器。</p>\n<p>服务器接收到<code>If-None-Match</code>后，会跟服务器上该资源的<code>ETag</code>进行比对:</p>\n<ul>\n<li>如果两者不一样，说明要更新了。返回新的资源，跟常规的<code>HTTP</code>请求响应的流程一样。</li>\n<li>否则返回304，告诉浏览器直接用缓存</li>\n</ul>\n<h3 id=\"两者对比\"><a href=\"#两者对比\" class=\"headerlink\" title=\"两者对比\"></a><strong>两者对比</strong></h3><ol>\n<li>在精准度上，<code>ETag</code>优于<code>Last-Modified</code>。优于<code>ETag</code> 是按照内容给资源上标识，因此能准确感知资源的变化。而 <code>Last-Modified</code> 就不一样了，它在一些特殊的情况下并不能准确感知资源变化，主要有两种情况:</li>\n</ol>\n<ul>\n<li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li>\n<li><code>Last-Modified</code> 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li>\n</ul>\n<ol>\n<li>在性能上，<code>Last-Modified</code>优于<code>ETag</code>，也很简单理解，<code>Last-Modified</code>仅仅只是记录一个时间点，而<code> Etag</code>需要根据文件的具体内容生成哈希值。</li>\n</ol>\n<p>另外，如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p>\n<h2 id=\"缓存位置\"><a href=\"#缓存位置\" class=\"headerlink\" title=\"缓存位置\"></a>缓存位置</h2><p>​    前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？</p>\n<p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p>\n<ul>\n<li>Service Worker</li>\n<li>Memory Cache（内存缓存）</li>\n<li>Disk Cache（硬盘缓存）</li>\n<li>Push Cache（推送缓存）</li>\n</ul>\n<h3 id=\"Service-Worker\"><a href=\"#Service-Worker\" class=\"headerlink\" title=\"Service Worker\"></a>Service Worker</h3><p>​    和Web Worker类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Worker使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的</p>\n<h3 id=\"Memory-Cache-和-Disk-Cache\"><a href=\"#Memory-Cache-和-Disk-Cache\" class=\"headerlink\" title=\"Memory Cache 和 Disk Cache\"></a>Memory Cache 和 Disk Cache</h3><p><code>Memory Cache</code>指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p>\n<p><code>Disk Cache</code>就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。</p>\n<p>好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p>\n<ul>\n<li>比较大的<code>JS</code>、<code>CSS</code>文件会直接被丢进磁盘，反之丢进内存</li>\n<li>内存使用率比较高的时候，文件优先进入磁盘</li>\n</ul>\n<h3 id=\"Push-Cache\"><a href=\"#Push-Cache\" class=\"headerlink\" title=\"Push Cache\"></a>Push Cache</h3><p>即推送缓存，这是浏览器缓存的最后一道防线。是<code>HTTP/2</code>的内容，目前应用较少</p>\n<p><code>Push Cache</code> 是指 <code>HTTP2</code> 在 <code>server push</code> 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段, 具体内容可以的可以查看<a href=\"https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81\">HTTP&#x2F;2 简介</a></p>\n<ul>\n<li><code>Push Cache</code> 是缓存的最后一道防线。浏览器只有在 <code>Memory Cache</code>、<code>HTTP Cache</code> 和 <code>Service Worker Cache</code> 均未命中的情况下才会去询问 <code>Push Cache</code>。</li>\n<li><code>Push Cache </code>是一种存在于会话阶段的缓存，当 <code>session</code> 终止时，缓存也随之释放。</li>\n<li>不同的页面只要共享了同一个 <code>HTTP2</code> 连接，那么它们就可以共享同一个 <code>Push Cache</code>。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>​    以上就是 关于浏览器缓存策略的全部内容了, 既然知道了缓存策略的规则, 那么我们在日常的开发项目中，对资源文件的缓存策略就有一个比较清晰的认识。</p>\n<p>​    对于一些<strong>改动比较频繁</strong>的, 例如<code>index.html</code>可以使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小, 且不会因为缓存导致请求了旧资源。</p>\n<p>​    而对于 <strong>不常变化的资源文件</strong>,，给它们的 <code>Cache-Control</code> 配置一个很大的 <code>max-age=31536000</code> (一年)，这样浏览器之后请求相同的 <code>URL </code>会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (我们的<code>webpack</code>就能够实现这种功能)。</p>\n<p>在线提供的类库 (如 <code>jquery-3.3.1.min.js</code>, <code>lodash.min.js</code> 等) 均采用这个模式。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>参考文章</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[<a href=\"https://github.com/amandakelake/blog/issues/41*\">缓存（二）——浏览器缓存机制：强缓存、协商缓存</a>]</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[<a href=\"https://www.hfwang.win/pages/855b44/\">缓存机制</a>]</p></blockquote>\n","text":"前言前段时间, 被面试官问了一个之前完全没有留意的问题, 你知道什么是浏览器的缓存策略吗？知道的话,能不能解释一下缓存策略的内容, 这下可把我问懵了, 毕竟那会对于浏览器缓存只是一知半解, 更别说浏览器缓存策略了, 于是下定决定查阅了相关资料, 于是才有了这篇文章。 概述浏览器缓...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"网络","slug":"网络","count":3,"path":"api/categories/网络.json"}],"tags":[{"name":"网络","slug":"网络","count":3,"path":"api/tags/网络.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">基本流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%90%8C%E7%82%B9\"><span class=\"toc-text\">异同点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">强缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Expires\"><span class=\"toc-text\">Expires</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Cache-Control\"><span class=\"toc-text\">Cache-Control</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">协商缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#If-Modified-since-x2F-Last-Modified\"><span class=\"toc-text\">If-Modified-since&#x2F;Last-Modified</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#If-None-Match-x2F-ETag\"><span class=\"toc-text\">If-None-Match&#x2F;ETag</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">两者对比</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">缓存位置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Service-Worker\"><span class=\"toc-text\">Service Worker</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Memory-Cache-%E5%92%8C-Disk-Cache\"><span class=\"toc-text\">Memory Cache 和 Disk Cache</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Push-Cache\"><span class=\"toc-text\">Push Cache</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}},"mapped":true,"prev_post":{"title":"老生常谈的原型链","uid":"212a81230ed6f68dcc9f987f4bdbd2fa","slug":"老生常谈的原型链","date":"2021-03-12T06:43:27.000Z","updated":"2022-03-30T02:35:15.679Z","comments":true,"path":"api/articles/老生常谈的原型链.json","keywords":null,"cover":"https://image.xposean.top/blogImage/006.png","text":"前言今天咱们来谈谈在JavaScript中常常被提及的原型链, 原型链的概念比较抽象, 所以初学时会难以理解, 但因为原型链又是JavaScript中十分重要的概念, 所以学习好原型链是十分有必要的。 理解原型链其实原型链咱们可以拆分成两个关键词: 原型(prototype) 链...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/tags/JavaScript.json"}],"author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}}},"next_post":{"title":"教你通过利用ssh编写前端一键部署脚本","uid":"7ba40a83c9b0e7e96e8e9f3699affe32","slug":"教你通过利用ssh编写一键部署脚本","date":"2020-05-19T11:21:17.000Z","updated":"2022-03-30T02:35:15.673Z","comments":true,"path":"api/articles/教你通过利用ssh编写一键部署脚本.json","keywords":null,"cover":"https://image.xposean.top/blogImage/003.png","text":"今天来介绍一下, 如何利用node编写部署脚本, 来实现一键部署的功能 背景因为我司的开发流程比较特殊, 开发环境的服务器ip会经常变化, 并不固定, 所以在前端部署代码的时候十分麻烦, 部署流程如下: 可以看出, 这种方式存在一些缺点： 每次部署都需要打开xshell或winS...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"开发技巧","slug":"开发技巧","count":2,"path":"api/categories/开发技巧.json"}],"tags":[{"name":"开发技巧","slug":"开发技巧","count":2,"path":"api/tags/开发技巧.json"}],"author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}}}}