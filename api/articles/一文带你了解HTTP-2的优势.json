{"title":"一文带你知晓HTTP/2","uid":"6886a329624b279c7fd485ea2219eb1f","slug":"一文带你了解HTTP-2的优势","date":"2020-12-22T02:41:40.000Z","updated":"2022-03-30T02:35:15.668Z","comments":true,"path":"api/articles/一文带你了解HTTP-2的优势.json","keywords":null,"cover":"https://image.xposean.top/blogImage/0016.png","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为一个经常跟<code>web</code> 打交道的程序员，了解HTTP协议是必须的, 通过本文, 希望能够让你了解到一些关于HTTP协议和HTTP&#x2F;2的基本概念和优劣势,如有不对的地方请指出。</p>\n<h2 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h2><p><code>HTTP</code>的全称是超文本传输协议 (<code>HyperText Transfer Protocol</code>) ,伴随着计算机网络和浏览器的诞生，<code>HTTP1.0</code> 也随之而来，处于计算机网络中的应用层，<code>HTTP</code> 是建立在 <code>TCP</code> 协议之上，所以 <code>HTTP </code>协议的瓶颈及其优化技巧都是基于<code> TCP</code> 协议本身的特性，<strong>例如 <code>TCP</code>建立连接的 3 次握手和断开连接的 4 次挥手以及每次建立连接带来的 RTT 延迟时间。</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>RTT(Round-Trip Time)，往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p></blockquote>\n<p>早在 HTTP 建立之初，主要就是为了将超文本标记语言 (HTML) 文档从 Web 服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的 HTML 页面将要放在我们的 web 服务器上，用户端通过浏览器访问 url 地址来获取网页的显示内容，但是到了 <code>WEB2.0</code> 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 <code>CSS</code>，<code>Javascript</code>，来丰富我们的页面展示，当 <code>ajax</code> 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化。 </p>\n<h2 id=\"HTTP-x2F-1-x-介绍\"><a href=\"#HTTP-x2F-1-x-介绍\" class=\"headerlink\" title=\"HTTP&#x2F;1.x 介绍\"></a>HTTP&#x2F;1.x 介绍</h2><p><code>HTTP1.0</code>最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而<code>HTTP1.1</code>则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时<code>HTTP1.1</code>也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>\n<ul>\n<li><p>缓存处理，在<code>HTTP1.0</code>中主要使用header里的<code>If-Modified-Since</code>,<code>Expires</code>来做为缓存判断的标准，<code>HTTP1.1</code>则引入了更多的缓存控制策略例如<code>E-Tag</code>，<code>If-Unmodified-Since</code>, <code>If-Match</code>, <code>If-None-Match</code>等更多可供选择的缓存头来控制缓存策略。</p>\n</li>\n<li><p>带宽优化及网络连接的使用，<code>HTTP1.0</code>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，<code>HTTP1.1</code>则在请求头引入了<code>range</code>头域，它允许只请求资源的某个部分，即返回码是<code>206（Partial Content）</code>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>\n</li>\n<li><p>错误通知的管理，在<code>HTTP1.1</code>中新增了24个错误状态响应码，如<code>409（Conflict）</code>表示请求的资源与资源的当前状态发生冲突；<code>410（Gone）</code>表示服务器上的某个资源被永久性的删除。<br>Host头处理，在<code>HTTP1.0</code>中认为每台服务器都绑定一个唯一的<code>IP</code>地址，因此，请求消息中的<code>URL</code>并没有传递主机名（<code>hostname</code>）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（<code>Multi-homed Web Servers</code>），并且它们共享一个<code>IP</code>地址。<code>HTTP1.1</code>的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（<code>400 Bad Request</code>）。</p>\n</li>\n<li><p><strong>长连接</strong>，<code>HTTP 1.1</code>支持长连接（<code>PersistentConnection</code>）和请求的流水线（<code>Pipelining</code>）处理，在一个TCP连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟，在<code>HTTP1.1</code>中默认开启<code>Connection： keep-alive</code>，一定程度上弥补了<code>HTTP1.0</code>每次请求都要创建连接的缺点。</p>\n</li>\n</ul>\n<h3 id=\"HTTP-x2F-1-x-的缺陷\"><a href=\"#HTTP-x2F-1-x-的缺陷\" class=\"headerlink\" title=\"HTTP&#x2F;1.x 的缺陷\"></a>HTTP&#x2F;1.x 的缺陷</h3><p>虽然 <code>HTTP/1.1</code>对比<code>HTTP/1.0</code>强大了许多, 但仍存在诸多缺陷：</p>\n<ul>\n<li><strong>连接无法复用</strong>：连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。<ul>\n<li>HTTP&#x2F;1.0 传输数据时，每次都需要重新建立连接，增加延迟。</li>\n<li>HTTP&#x2F;1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。</li>\n</ul>\n</li>\n<li><strong>Head-Of-Line Blocking（HOLB）</strong>：即队头阻塞, 导致带宽无法被充分利用，以及后续健康请求被阻塞。<a href=\"http://stackoverflow.com/questions/25221954/spdy-head-of-line-blocking\">HOLB</a>是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。<ul>\n<li>HTTP 1.0：下个请求必须在前一个请求返回后才能发出，<code>request-response</code>对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。</li>\n<li>HTTP 1.1：尝试使用 <code>pipeling</code> 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 <code>pipeling</code> 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，<code>pipeling</code> 只部分解决了 <code>HOLB</code>的情况。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://image.xposean.top/20210113114727.png\"></p>\n<p>如上图所示，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间。</p>\n<ul>\n<li><strong>协议开销大</strong>： <code>HTTP1.1</code> 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。</li>\n<li><strong>安全因素</strong>：<code>HTTP1.1</code> 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性</li>\n</ul>\n<p>因为 <code>HTTP/1.1</code> 的问题，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到 2009 年，谷歌公开了自行研发的 <code>SPDY</code>协议，主要解决 <code>HTTP/1.1</code> 效率不高的问题。谷歌推出 <code>SPDY</code>，才算是正式改造 <code>HTTP</code> 协议本身。降低延迟，压缩 <code>header</code> 等等，<code>SPDY</code> 的实践证明了这些优化的效果，也最终带来 <code>HTTP/2</code> 的诞生。</p>\n<p><code>SPDY</code> 协议在 <code>Chrome</code> 浏览器上证明可行以后，就被当作 <code>HTTP/2</code> 的基础，主要特性都在 <code>HTTP/2</code> 之中得到继承。</p>\n<h2 id=\"HTTP-x2F-2\"><a href=\"#HTTP-x2F-2\" class=\"headerlink\" title=\"HTTP&#x2F;2\"></a>HTTP&#x2F;2</h2><p>2015 年初，<code>IESG</code> 审阅了新的<code> HTTP/2</code> 标准并批准发布。</p>\n<h3 id=\"为什么不是-HTTP-x2F-1-2？\"><a href=\"#为什么不是-HTTP-x2F-1-2？\" class=\"headerlink\" title=\"为什么不是 HTTP&#x2F;1.2？\"></a>为什么不是 HTTP&#x2F;1.2？</h3><p>为了实现 HTTP 工作组设定的性能目标，HTTP&#x2F;2 引入了一个新的二进制分帧层，该层无法与之前的<code>HTTP/1.x</code>服务器和客户端向后兼容，因此协议的主版本提升到 <code>HTTP/2</code>。</p>\n<p>即便如此，除非您在实现网络服务器（或自定义客户端），需要使用原始的 TCP 套接字，否则您很可能注意不到任何区别：所有新的低级分帧由客户端和服务器为您执行。 可观察到的唯一区别将是性能的提升和请求优先级、流控制与服务器推送等新功能的出现。</p>\n<p>需要注意的是，HTTP&#x2F;2 仍是对之前 <code>HTTP</code> 标准的扩展，而非替代。 <code>HTTP </code>的应用语义不变，提供的功能不变，<code>HTTP</code> 方法、状态代码、<code>URI</code> 和标头字段等这些核心概念也不变。 这些方面的变化都不在<code> HTTP/2</code> 考虑之列。 </p>\n<hr>\n<p>那下面咱们来说说HTTP&#x2F;2的新特性</p>\n<h3 id=\"1-二进制传输\"><a href=\"#1-二进制传输\" class=\"headerlink\" title=\"1. 二进制传输\"></a><strong>1. 二进制传输</strong></h3><p><code>HTTP/2</code> 所有性能增强的核心在于新的<strong>二进制分帧层</strong>，它定义了如何封装 <code>HTTP</code> 消息并在客户端与服务器之间传输.新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。 为了说明这个过程，我们需要了解 <code>HTTP/2</code> 的三个概念：</p>\n<ul>\n<li><em>数据流</em>：已建立的连接内的双向字节流，可以承载一条或多条消息。</li>\n<li><em>消息</em>：与逻辑请求或响应消息对应的完整的一系列帧。</li>\n<li><em>帧</em>：<code>HTTP/2</code> 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li>\n</ul>\n<p>这些概念的关系总结如下：</p>\n<ul>\n<li>所有通信都在一个 <code>TCP</code> 连接上完成，此连接可以承载任意数量的双向数据流。</li>\n<li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li>\n<li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。</li>\n<li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li>\n</ul>\n<p><img src=\"D:\\Download\\2019-03-06-2.png\"></p>\n<p><code>HTTP/2</code>中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p>\n<p>了解了二进制传输的概念, 咱们才能明白<code>HTTP/2</code>的下一个重要特性<strong>多路复用</strong>的原理, 因为多路复用的实现正是基于二进制传输。</p>\n<h3 id=\"2-多路复用\"><a href=\"#2-多路复用\" class=\"headerlink\" title=\"2. 多路复用\"></a>2. 多路复用</h3><p>在 <code>HTTP/2</code> 中引入了多路复用的技术。<strong>多路复用</strong>很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟因为在<code>TCP</code>的”慢启动”机制下, 每新开一个 TCP 连接都需要慢慢提升传输速度。</p>\n<p>通过访问 <a href=\"https://http2.akamai.com/demo\">HTTP&#x2F;1与HTTP&#x2F;2性能对比</a> 可以明显的看出性能上的区别</p>\n<p><img src=\"https://image.xposean.top/20210113143024.png\"></p>\n<p>在 <code>HTTP/2 </code>中，有了二进制分帧之后，<code>HTTP /2 </code>不再依赖 TCP 链接去实现多流并行了，在 <code>HTTP/2</code> 中：</p>\n<ul>\n<li>同域名下所有通信都在单个连接上完成。</li>\n<li>单个连接可以承载任意数量的双向数据流。</li>\n<li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li>\n</ul>\n<p>通俗一点来说，<code>TCP</code>连接相当于两根管道（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，传输是有序的，每个字节都是一个一个来传输。</p>\n<p>例如客户端要向服务器发送<code>Hello</code>、<code>World</code>两个单词，只能是先发送<code>Hello</code>再发送<code>World</code>，没办法同时发送这两个单词。不然服务器收到的可能就是<code>HWeolrllod</code>（注意是穿插着发过去了，但是顺序还是不会乱）。这样服务器处理就会出现问题了。</p>\n<p>接上面的问题，能否同时发送<code>Hello</code>和<code>World</code>两个单词呢？在<code>HTTP/2</code>中就能，可以将消息数据拆成帧，给每个帧打上标签(帧首部的流标识)。发的时候是这样的①H ②W ①e ②o ①l ②r ①l ②l ①o ②d。这样到了服务器，服务器根据标签()把两个单词区分开来。实际的发送效果如下图：</p>\n<p><img src=\"https://image.xposean.top/20210113144541.png\"></p>\n<p>这一特性，使得传输性能有了极大提升：</p>\n<ul>\n<li>同个域名只需要占用一个 <code>TCP</code>连接，使用一个连接并行发送多个请求和响应,消除了因多个 <code>TCP</code> 连接而带来的延时和内存消耗。</li>\n<li>并行交错地发送多个请求，请求之间互不影响。</li>\n<li>并行交错地发送多个响应，响应之间互不干扰。</li>\n<li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。</li>\n<li>不必再为绕过<code> HTTP/1.x</code> 请求限制而做很多工作（例如级联文件、image sprites 和域名分片等）</li>\n</ul>\n<p>总结下来, 多路复用技术：利用单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；由于减少TCP 慢启动时间，提高传输的速度</p>\n<h3 id=\"3-Header-压缩\"><a href=\"#3-Header-压缩\" class=\"headerlink\" title=\"3.Header 压缩\"></a>3.<strong>Header 压缩</strong></h3><p>为什么要压缩？在 <code>HTTP/1.x</code> 中，<code>HTTP</code> 请求和响应都是由「状态行、请求 &#x2F; 响应头部、消息主体」三部分组成。一般而言，消息主体都会经过<code> Gzip</code> 压缩，或者本身传输的就是压缩过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接以纯文本传输。</p>\n<p>随着 <code>Web</code> 功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输 <code>UserAgent</code>、<code>Cookie</code> 这类不会频繁变动的内容，可能每次都需要重复传输几百到几千的字节, 造成浪费。</p>\n<p>为了减少这块的资源消耗并提升性能， <code>HTTP/2</code> 对这些首部采取了压缩策略：</p>\n<ul>\n<li><code>HTTP/2 </code>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li>\n<li>首部表在 HTTP&#x2F;2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li>\n<li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值</li>\n</ul>\n<p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销.</p>\n<p><img src=\"https://image.xposean.top/20210113145839.png\"></p>\n<h3 id=\"4-服务器推送\"><a href=\"#4-服务器推送\" class=\"headerlink\" title=\"4 .服务器推送\"></a>4 .服务器推送</h3><p><code>HTTP/2</code> 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源（如下图所示），而无需客户端明确地请求。</p>\n<p><img src=\"https://image.xposean.top/20210113150150.png\"></p>\n<p>为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</p>\n<p>事实上，如果您在网页中内联过 CSS、JavaScript，或者通过数据 URI 内联过其他资产，那么您就已经亲身体验过服务器推送了。 对于将资源手动内联到文档中的过程，我们实际上是在将资源推送给客户端，而不是等待客户端请求。 使用 HTTP&#x2F;2，我们不仅可以实现相同结果，还会获得其他性能优势。 推送资源可以进行以下处理：</p>\n<ul>\n<li>由客户端缓存</li>\n<li>在不同页面之间重用</li>\n<li>与其他资源一起复用</li>\n<li>由服务器设定优先级</li>\n<li>被客户端拒绝</li>\n</ul>\n<p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 <code>RST_STREAM</code> 帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行, 更多详情可参阅<a href=\"https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81\">服务器推送</a></p>\n<p>那么以上就是<code>HTTP/2</code>的所有新特性了, 其实以上的特性同时也是<code>HTTP/1.x</code>中存在的缺陷, 同时需要注意的是, 在<code>HTTP/2</code>中, 我们的日常用的 优化手段, 例如图片<code>Base64</code>、雪碧图、多域名等手段也不再适用了。</p>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>虽然 <code>HTTP/2</code> 提高了网页的性能，但是并不代表它已经是完美的了，<code>HTTP/3</code> 就是为了解决 <code>HTTP/2</code> 所存在的一些问题而被推出来的.</p>\n<p><code>HTTP/2</code>还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。</p>\n<p>上文提到 HTTP&#x2F;2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 <code>HTTP/2</code> 的表现情况反倒不如 <code>HTTP/1</code> 了。</p>\n<p>因为在出现丢包的情况下，整个 <code>TCP</code> 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 <code>HTTP/1.1</code> 来说，可以开启多个<code> TCP</code> 连接，出现这种情况反倒只会影响其中一个连接，剩余的<code>TCP</code>连接还可以正常传输数据。</p>\n<p>那么可能就会有人考虑到去修改 <code>TCP</code> 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实, 这就是所谓的<a href=\"https://http3-explained.haxx.se/zh/why-quic/why-ossification\">协议僵化</a></p>\n<p>基于这个原因，<strong>Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP&#x2F;3 上</strong>，HTTP&#x2F;3 之前名为 <code>HTTP-over-QUIC</code>，从这个名字中我们也可以发现，<code>HTTP/3</code> 最大的改造就是使用了 <code>QUIC</code>。</p>\n<p><code>QUIC</code> 虽然基于 <code>UDP</code>，但是在原本的基础上新增了很多功能, 使得<code>QUIC</code> 能够用<code>UDP </code>来实现高速度，同时又不会牺牲 <code>TLS </code>的安全性。</p>\n<p>2018 年，<code>QUIC</code> 演变成为 <code>HTTP3</code>。互联网工程任务组（Internet Engineerring Task Force）的那帮制定互联网协议的哥们同意了这个提案。这是个好消息，因为对于我们这些急躁的人们来说，互联网的速度永远都不够快。</p>\n<p>更多关于HTTP&#x2F;3的内容, 可以阅读<a href=\"https://http3-explained.haxx.se/zh\">http3-explained</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 参考文章</p>\n<p>[<a href=\"https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/\">一文读懂 HTTP&#x2F;2 及 HTTP&#x2F;3 特性</a>]</p>\n<p>[<a href=\"https://http3-explained.haxx.se/zh\">HTTP&#x2F;3 explained</a>]</p>\n<p>[<a href=\"https://segmentfault.com/a/1190000016496448\">谈谈HTTP1.0,HTTP1.1和HTTP2.0区别</a>]</p></blockquote>\n","feature":true,"text":"前言作为一个经常跟web 打交道的程序员，了解HTTP协议是必须的, 通过本文, 希望能够让你了解到一些关于HTTP协议和HTTP&#x2F;2的基本概念和优劣势,如有不对的地方请指出。 HTTP协议HTTP的全称是超文本传输协议 (HyperText Transfer Prot...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"网络","slug":"网络","count":3,"path":"api/categories/网络.json"}],"tags":[{"name":"网络","slug":"网络","count":3,"path":"api/tags/网络.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">HTTP协议</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-x2F-1-x-%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">HTTP&#x2F;1.x 介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTTP-x2F-1-x-%E7%9A%84%E7%BC%BA%E9%99%B7\"><span class=\"toc-text\">HTTP&#x2F;1.x 的缺陷</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTTP-x2F-2\"><span class=\"toc-text\">HTTP&#x2F;2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF-HTTP-x2F-1-2%EF%BC%9F\"><span class=\"toc-text\">为什么不是 HTTP&#x2F;1.2？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">1. 二进制传输</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">2. 多路复用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Header-%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">3.Header 压缩</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81\"><span class=\"toc-text\">4 .服务器推送</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">拓展</span></a></li></ol>","author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}},"mapped":true,"prev_post":{"title":"HTTPS,没有你想的那么复杂","uid":"504da11f3eb2cec03d50a92ae3a009b3","slug":"HTTPS-没有你想的那么复杂","date":"2021-01-22T03:28:47.000Z","updated":"2022-03-30T02:35:15.665Z","comments":true,"path":"api/articles/HTTPS-没有你想的那么复杂.json","keywords":null,"cover":"https://image.xposean.top/blogImage/0020.png","text":"前言作为一名合格的前端工程师, 不可避免的要接触到HTTPS协议, 也一直没有时间深入的研究过这个东西, 趁着今天这篇文章, 咱们就来好好的探讨一下, 看完之后, 也许就能拨开HTTPS的神秘面纱。在网络世界里, 怎样的数据传输才能理解为安全呢?我认为主要体现在以下几个方面: 我...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"网络","slug":"网络","count":3,"path":"api/categories/网络.json"}],"tags":[{"name":"网络","slug":"网络","count":3,"path":"api/tags/网络.json"}],"author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}},"feature":true},"next_post":{"title":"影响前端性能的元凶:DOM操作","uid":"decb2ba92766b9621e5fcb0aeee2cd50","slug":"影响前端性能的元凶-DOM操作","date":"2019-09-01T13:42:09.000Z","updated":"2022-03-30T02:35:15.672Z","comments":true,"path":"api/articles/影响前端性能的元凶-DOM操作.json","keywords":null,"cover":"https://image.xposean.top/blogImage/0018.png","text":"今天我们来谈谈影响前端性能的主要元凶:DOM操作. 重视DOM操作的原因?在PC浏览器的时代,一般的小批量重绘或回流是感觉不出浏览器卡顿的,这主要是因为PC端的浏览器性能强而且网速够快,但到了如今我们的移动浏览器时代,轻微的DOM操作,在我们性能稍弱,网速不够快的移动浏览器上,影...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":13,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":13,"path":"api/tags/前端.json"}],"author":{"name":"Xposean","slug":"blog-author","avatar":"https://cdn.xposean.top/smallStack/dist/img/avatar.6354a35.png","link":"/","description":"做一个刚刚好的前端仔","socials":{"github":"https://github.com/Anonlyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.im/user/1451011078620568","customs":{"site":{"icon":"/image/site_logo.png","link":"https://www.xposean.top"}}}},"feature":true}}