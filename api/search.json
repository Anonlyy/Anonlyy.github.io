[{"id":"504da11f3eb2cec03d50a92ae3a009b3","title":"HTTPS,没有你想的那么复杂","content":"前言作为一名合格的前端工程师, 不可避免的要接触到HTTPS协议, 也一直没有时间深入的研究过这个东西, 趁着今天这篇文章, 咱们就来好好的探讨一下, 看完之后, 也许就能拨开HTTPS的神秘面纱。在网络世界里, 怎样的数据传输才能理解为安全呢?我认为主要体现在以下几个方面:\n\n我发送的数据, 不该看的人看不懂\n我发的数据或者别人发我的数据, 不该看的人不能伪造或者修改\n互相发送的数据, 在过期之后不能看的人无法偷偷拿过来继续用\n\n而HTTPS怎么保证数据传输的安全呢？\n接下来咱们通过一个故事,来解释HTTPS安全传输的原理\n故事内容1. 故事背景咱们今天的主人公, 一个是位于中国深圳的小王, 另一个则是位于日本东京的伊藤一郎, 两人远隔重洋,天各一方,通过网络联系,,小王痴迷于日本的二次元文化, 伊藤一郎则钟爱中国的传统文化, 两人一聊如故, 聊得热火朝天。\n两个人越聊越投机高谈阔论,，天南地北，还夹杂着不少隐私的话题。\n2.  聊天内容被窥探的感觉有一天， 伊藤一郎 突然意识到： 坏了， 我们的通信是明文的， 这简直就是网络上裸奔啊， 任何一个不怀好意的家伙都可以监听我们通信，打开我们发送的数据包，窥探我们的隐私啊。\n小王说： “你不早点说，我刚才是不是把我的微信号给你发过去了？ 我是不是告诉你我上周去哪儿旅游了?  估计已经被人截取了吧！”\n伊藤一郎  提议： “要不我们做个数据的加密？ 每次传输之前， 你把消息用一个加密算法加密， 然后发到我这里以后我再解密， 这样别人就无法偷窥了，像这样： ”\n\n小王十分聪明，一看就明白了， 这加密和解密算法是公开的，那个密钥是保密的， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。 他说： “伊藤一郎 老兄，你生成一个密钥， 然后把密钥发给我， 咱们这就开启加密消息， 让那些偷窥狂人们哭去吧！”\n（注：这就叫对称加密算法， 因为加密和解密用的是同一个密钥）\n一炷香功夫过去了， 伊藤一郎 还是没有回音， 小王忍不住地催促： “快发啊？！！！”\n伊藤一郎 终于回复了： “ 我感觉有一双眼睛正在虎视眈眈地盯着我们的通话， 如果我把密钥发给你， 也被他截取了， 那加密岂不白费工夫？”\n小王沉默了， 是啊， 网络是不安全的， 这密钥怎么安全地发过来啊 ？　\n“噢，对了，我下周要去日本旅游，到时候我们见一面，把密码确定下来，写到纸上，谁也偷不走， 这不就结了？”　\n“哈哈， 这倒是终极解决之道 ”  伊藤一郎 笑了， “可是，我不仅仅和你聊天， 我还要和易卜拉欣，阿卜杜拉， 弗拉基米尔，克里斯托夫，玛格丽特， 桥本龙太郎， 李贤俊， 许木木，郭芙蓉，吕秀才等人通信， 我总不能打着飞的，满世界的和人交换密码吧？ ”\n小王心里暗自佩服伊藤一郎同学的好友竟然遍布全球，看来他对加密通信的要求更加强烈啊！\n可是这个加密解密算法需要的密钥双方必须得知道啊， 但是密钥又无法通过网络发送， 这该死的偷窥者！\n这可怎么办？\n3. 利用非对称加密伊藤一郎和 小王的通信无法加密，两人聊天也谨慎了不少， 直到有一天， 他们听说了一个叫做RSA的非对称加密算法，一下子来了灵感。\n这个RSA算法非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对钥匙， 一个是保密的，称为私钥，另外一个是公开的，称为公钥。\n更有意思的是，用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。\n\n有了这两个非常棒的特性， 当小王给伊藤一郎发消息的时候， 就可以先用伊藤一郎的公钥去加密（反正伊藤一郎的公钥是公开的，地球人都知道）， 等到消息被伊藤一郎 收到后， 他就可以用自己的私钥去解密（只有伊藤一郎才能解开，私钥是保密的 ）\n\n反过来也是如此, 伊藤一郎给小王发消息是, 可以先用小王的公钥去加密, 等到消息被小王收到后, 小王就可以用自己的私钥解密。\n如此一来, 他们通信安全就固若金汤了, 其他人再也没办法窥探消息了。\n4.非对称加密+对称加密两人实验了几次，  小王说： “伊藤一郎  , 你有没有感觉咱们这个RSA的加密和解密有点慢啊？”\n伊藤一郎叹了口气 ：“是啊， 我也注意到了， 刚才搜了一下，这个RSA算法虽然更加安全, 可是比之前的对称密钥算法要慢上百倍。我们就是加个密而已，现在搞得都没办法好好聊天了”\n小王灵机一动, 回答道：“回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ,我想可以结合一下， 分两步走:\n　1. 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你。 　2. 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信,  如何？  ”\nPS: 这里与HTTPS的传输机制是类似的\n伊藤一郎 说： “你小子可以啊， 这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错不错。”　\n于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！\n5.中间人攻击小王把和伊藤一郎 聊天的情况给好基友小张汇报了一次。\n小张告诫他说： “你要小心啊， 你确定网络那边坐着的确实是伊藤一郎?”\n小王着急地辩解说：“肯定是他啊，我都有他的公钥，我们俩的通信都是加密的。”\n小张提醒道：＂假如一开始，伊藤一郎给你发公钥的时候， 有个中间人，截取了伊藤一郎的公钥， 然后把自己的公钥发给了你，冒充伊藤一郎 ，你发的消息就用中间人的公钥加了密，那中间人不就可以解密看到消息了？＂\n小王背后出汗了，是啊，而且这个中间人解密以后，还可以用伊藤一郎的公钥加密，发给伊藤一郎, 伊藤一郎和我根本都意识不到， 还以为我们在安全传输呢！\n\n看来问题出现在公钥的分发上！  虽然这个东西是公开的， 但是在别有用心的人看来，截取以后还可以干坏事 ！\n6.你到底是谁？可是怎样才能安全的分发公钥呢？这似乎又回到了最初的问题上, 怎么安全的保护密钥呢？或者说怎么声明公钥是真实的发送者呢？\n怎么声明呢？\n小王突然想到： 现实中有公证处，它提供的公证材料大家都信任，那在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。\n这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！\n这样以来我拿到证书就可以安全地取到公钥了 ！ 完美！\n可是伊藤一郎 马上泼了一盆冷水：证书怎么安全传输？ 要是证书传递的过程中被篡改了怎么办？\n小王心里不由地咒骂起来： 尼玛， 这简直就是鸡生蛋，蛋生鸡的问题啊。\n天无绝人之路， 小王很快就找到了突破口： 数字签名。\n简单来讲是这样的， 伊藤一郎可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，只要输入数据有一点点变化，那生成的消息摘要就会有巨变，这样就可以防止别人修改原始内容。\n\n可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？”\n小王说你别得意的太早 ， 我们会让有公信力的认证中心（简称CA）用它的私钥对消息摘要加密，形成签名：\n\n这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“数字证书”\n\n小王接着说：当伊藤一郎把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！\n\n如果没人篡改， 我就可以安全的拿到伊藤一郎的公钥喽，有了公钥， 后序的加密工作就可以开始了。\n虽然很费劲， 但是为了防范你们这些偷窥者，实在是没办法啊。\n中间人恶狠狠地说： “算你小子狠！ 等着吧，我还有别的招。 对了，我且问你， 你这个CA的公钥怎么拿到？难道不怕我在你传输CA公钥的时候发起中间人攻击吗？如果我成功的伪装成了CA，你这一套体系彻底玩完。”\n小王语塞了，折腾了半天，又回到了公钥安全传输的问题！\n不过转念一想，想解决鸡生蛋，蛋生鸡的问题必须得打破这个怪圈才行，我必须得信任CA，并且通过安全的的方式获取他们的公钥，这样才能把游戏玩下去。\nPS: 这些CA本身也有证书来证明自己的身份，并且CA的信用是像树一样分级的，高层的CA给底层的CA做信用背书，而操作系统／浏览器中会内置一些顶层的CA的证书，相当于你自动信任了他们。这些顶层的CA证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。\n总结与回顾好了, 故事咱们已经讲完了, 那么咱们来回顾一下 故事里出现的几个关键词,搞清楚几个关键词后, 理解起    HTTPS, 就十分通俗易懂了。\n对称加密对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。\n常见的对称加密算法有: DES、3DES、AES等\n对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。\n对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好密钥，然后使双方都能保存好密钥。其次如果一方的密钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的独一密钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。\n非对称加密非对称式密码学（英语：Asymmetric cryptography）是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。公钥可以公开，可任意向外发布；私钥不可以公开，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。\n数字签名\n数字签名的主要作用就是 验证信息的可信度的, 故事里其实也已经描述过了, 通过对发送方的公钥、公钥信息等内容进行Hash算法加密, 生成消息摘要, 再用CA的私钥对消息摘要进行加密, 生成签名, 即数字签名。\n数字证书\n而数字证书其实就是在数字签名的基础上, 增加 公钥和证书的一些基础信息(如申请者与颁布者信息、有效期等).\n现在的数字证书申请其实已经很方便了, 可以直接去阿里云或腾讯云等网站, 提交资料购买。\nHTTPS的传输过程前面铺垫了如此之多, 如果你都理解了, 那下面这张描述HTTPS传输过程的图片你会觉得十分简单。\n\n\n\n\n\n\n\n\n\n\n参考文章\n\n\n\n\n\n\n\n\n\n 【百度百科：对称加密】\n\n\n\n\n\n\n\n\n\n【维基百科：非对称加密】\n\n\n\n\n\n\n\n\n\n【百度百科：RSA算法】\n","slug":"HTTPS-没有你想的那么复杂","date":"2021-01-22T03:28:47.000Z","categories_index":"网络","tags_index":"网络","author_index":"Xposean"},{"id":"6886a329624b279c7fd485ea2219eb1f","title":"一文带你知晓HTTP/2","content":"前言作为一个经常跟web 打交道的程序员，了解HTTP协议是必须的, 通过本文, 希望能够让你了解到一些关于HTTP协议和HTTP&#x2F;2的基本概念和优劣势,如有不对的地方请指出。\nHTTP协议HTTP的全称是超文本传输协议 (HyperText Transfer Protocol) ,伴随着计算机网络和浏览器的诞生，HTTP1.0 也随之而来，处于计算机网络中的应用层，HTTP 是建立在 TCP 协议之上，所以 HTTP 协议的瓶颈及其优化技巧都是基于 TCP 协议本身的特性，例如 TCP建立连接的 3 次握手和断开连接的 4 次挥手以及每次建立连接带来的 RTT 延迟时间。\n\n\n\n\n\n\n\n\n\nRTT(Round-Trip Time)，往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。\n早在 HTTP 建立之初，主要就是为了将超文本标记语言 (HTML) 文档从 Web 服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的 HTML 页面将要放在我们的 web 服务器上，用户端通过浏览器访问 url 地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化。 \nHTTP&#x2F;1.x 介绍HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：\n\n缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如E-Tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n\n带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。\n\n长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\n\n\nHTTP&#x2F;1.x 的缺陷虽然 HTTP/1.1对比HTTP/1.0强大了许多, 但仍存在诸多缺陷：\n\n连接无法复用：连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。\nHTTP&#x2F;1.0 传输数据时，每次都需要重新建立连接，增加延迟。\nHTTP&#x2F;1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。\n\n\nHead-Of-Line Blocking（HOLB）：即队头阻塞, 导致带宽无法被充分利用，以及后续健康请求被阻塞。HOLB是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。\nHTTP 1.0：下个请求必须在前一个请求返回后才能发出，request-response对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。\nHTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB的情况。\n\n\n\n\n如上图所示，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间。\n\n协议开销大： HTTP1.1 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。\n安全因素：HTTP1.1 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性\n\n因为 HTTP/1.1 的问题，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到 2009 年，谷歌公开了自行研发的 SPDY协议，主要解决 HTTP/1.1 效率不高的问题。谷歌推出 SPDY，才算是正式改造 HTTP 协议本身。降低延迟，压缩 header 等等，SPDY 的实践证明了这些优化的效果，也最终带来 HTTP/2 的诞生。\nSPDY 协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。\nHTTP&#x2F;22015 年初，IESG 审阅了新的 HTTP/2 标准并批准发布。\n为什么不是 HTTP&#x2F;1.2？为了实现 HTTP 工作组设定的性能目标，HTTP&#x2F;2 引入了一个新的二进制分帧层，该层无法与之前的HTTP/1.x服务器和客户端向后兼容，因此协议的主版本提升到 HTTP/2。\n即便如此，除非您在实现网络服务器（或自定义客户端），需要使用原始的 TCP 套接字，否则您很可能注意不到任何区别：所有新的低级分帧由客户端和服务器为您执行。 可观察到的唯一区别将是性能的提升和请求优先级、流控制与服务器推送等新功能的出现。\n需要注意的是，HTTP&#x2F;2 仍是对之前 HTTP 标准的扩展，而非替代。 HTTP 的应用语义不变，提供的功能不变，HTTP 方法、状态代码、URI 和标头字段等这些核心概念也不变。 这些方面的变化都不在 HTTP/2 考虑之列。 \n\n那下面咱们来说说HTTP&#x2F;2的新特性\n1. 二进制传输HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输.新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。 为了说明这个过程，我们需要了解 HTTP/2 的三个概念：\n\n数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。\n消息：与逻辑请求或响应消息对应的完整的一系列帧。\n帧：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。\n\n这些概念的关系总结如下：\n\n所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。\n每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。\n每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。\n帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。\n\n\nHTTP/2中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。\n了解了二进制传输的概念, 咱们才能明白HTTP/2的下一个重要特性多路复用的原理, 因为多路复用的实现正是基于二进制传输。\n2. 多路复用在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟因为在TCP的”慢启动”机制下, 每新开一个 TCP 连接都需要慢慢提升传输速度。\n通过访问 HTTP&#x2F;1与HTTP&#x2F;2性能对比 可以明显的看出性能上的区别\n\n在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2 中：\n\n同域名下所有通信都在单个连接上完成。\n单个连接可以承载任意数量的双向数据流。\n数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。\n\n通俗一点来说，TCP连接相当于两根管道（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，传输是有序的，每个字节都是一个一个来传输。\n例如客户端要向服务器发送Hello、World两个单词，只能是先发送Hello再发送World，没办法同时发送这两个单词。不然服务器收到的可能就是HWeolrllod（注意是穿插着发过去了，但是顺序还是不会乱）。这样服务器处理就会出现问题了。\n接上面的问题，能否同时发送Hello和World两个单词呢？在HTTP/2中就能，可以将消息数据拆成帧，给每个帧打上标签(帧首部的流标识)。发的时候是这样的①H ②W ①e ②o ①l ②r ①l ②l ①o ②d。这样到了服务器，服务器根据标签()把两个单词区分开来。实际的发送效果如下图：\n\n这一特性，使得传输性能有了极大提升：\n\n同个域名只需要占用一个 TCP连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。\n并行交错地发送多个请求，请求之间互不影响。\n并行交错地发送多个响应，响应之间互不干扰。\n消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。\n不必再为绕过 HTTP/1.x 请求限制而做很多工作（例如级联文件、image sprites 和域名分片等）\n\n总结下来, 多路复用技术：利用单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；由于减少TCP 慢启动时间，提高传输的速度\n3.Header 压缩为什么要压缩？在 HTTP/1.x 中，HTTP 请求和响应都是由「状态行、请求 &#x2F; 响应头部、消息主体」三部分组成。一般而言，消息主体都会经过 Gzip 压缩，或者本身传输的就是压缩过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接以纯文本传输。\n随着 Web 功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，可能每次都需要重复传输几百到几千的字节, 造成浪费。\n为了减少这块的资源消耗并提升性能， HTTP/2 对这些首部采取了压缩策略：\n\nHTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；\n首部表在 HTTP&#x2F;2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;\n每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值\n\n例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销.\n\n4 .服务器推送HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源（如下图所示），而无需客户端明确地请求。\n\n为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。\n事实上，如果您在网页中内联过 CSS、JavaScript，或者通过数据 URI 内联过其他资产，那么您就已经亲身体验过服务器推送了。 对于将资源手动内联到文档中的过程，我们实际上是在将资源推送给客户端，而不是等待客户端请求。 使用 HTTP&#x2F;2，我们不仅可以实现相同结果，还会获得其他性能优势。 推送资源可以进行以下处理：\n\n由客户端缓存\n在不同页面之间重用\n与其他资源一起复用\n由服务器设定优先级\n被客户端拒绝\n\n服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行, 更多详情可参阅服务器推送\n那么以上就是HTTP/2的所有新特性了, 其实以上的特性同时也是HTTP/1.x中存在的缺陷, 同时需要注意的是, 在HTTP/2中, 我们的日常用的 优化手段, 例如图片Base64、雪碧图、多域名等手段也不再适用了。\n拓展虽然 HTTP/2 提高了网页的性能，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的.\nHTTP/2还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。\n上文提到 HTTP&#x2F;2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。\n因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反倒只会影响其中一个连接，剩余的TCP连接还可以正常传输数据。\n那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实, 这就是所谓的协议僵化\n基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP&#x2F;3 上，HTTP&#x2F;3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。\nQUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能, 使得QUIC 能够用UDP 来实现高速度，同时又不会牺牲 TLS 的安全性。\n2018 年，QUIC 演变成为 HTTP3。互联网工程任务组（Internet Engineerring Task Force）的那帮制定互联网协议的哥们同意了这个提案。这是个好消息，因为对于我们这些急躁的人们来说，互联网的速度永远都不够快。\n更多关于HTTP&#x2F;3的内容, 可以阅读http3-explained\n\n\n\n\n\n\n\n\n\n 参考文章\n[一文读懂 HTTP&#x2F;2 及 HTTP&#x2F;3 特性]\n[HTTP&#x2F;3 explained]\n[谈谈HTTP1.0,HTTP1.1和HTTP2.0区别]\n","slug":"一文带你了解HTTP-2的优势","date":"2020-12-22T02:41:40.000Z","categories_index":"网络","tags_index":"网络","author_index":"Xposean"},{"id":"decb2ba92766b9621e5fcb0aeee2cd50","title":"影响前端性能的元凶:DOM操作","content":"今天我们来谈谈影响前端性能的主要元凶:DOM操作.\n重视DOM操作的原因?在PC浏览器的时代,一般的小批量重绘或回流是感觉不出浏览器卡顿的,这主要是因为PC端的浏览器性能强而且网速够快,但到了如今我们的移动浏览器时代,轻微的DOM操作,在我们性能稍弱,网速不够快的移动浏览器上,影响性能的表现就会很明显了。\nDOM操作为什么会影响性能在浏览器中，DOM的实现和ECMAScript的实现是分离的。所以通过JavaScript代码调用DOM接 口，相当于两个独立模块的交互。相比较在同一模块中的调用，这种跨模块的调用其性能损耗是很高的。但DOM操作对性能影响最大其实还是因为它导致了浏览器 的重绘和回流。\n重绘（repaint）:当前元素的颜色样式(背景颜色、字体颜色等)发生改变的时候，我们只需要把改变的元素重新的渲染一下即可，重绘主要改变外观风格（改个颜色，换个皮肤），不改变布局，不影响其他的dom。\n回流（reflow）:指浏览器为了重新渲染部分或者全部的文档而重新计算文档中元素的位置和几何构造的过程。如DOM元素的增删、位置移动、尺寸大小的改变以及浏览器窗口尺寸改变。每个页面至少会有一次回流,就是在页面初次渲染的时候。\n这其中,重绘对浏览器的性能影响较小,一般不做优化，但是能避免最好.主要是回流需要尽可能避免和优化。\n浏览器的渲染原理在渲染页面的过程中，浏览器会通过解析HTML文档来构建DOM树，解析CSS产生CSS规则树。JavaScript代码在解析过程中， 可能会修改生成的DOM树和CSS规则树。之后根据DOM树和CSS规则树构建渲染树，在这个过程中CSS会根据选择器匹配HTML元素。渲染树包括了每 个元素的大小、边距等样式属性，渲染树中不包含隐藏元素及head元素等不可见元素。最后浏览器根据元素的坐标和大小来计算每个元素的位置，并绘制这些元 素到页面上。重绘指的是页面的某些部分要重新绘制，比如颜色或背景色的修改，元素的位置和尺寸并没用改变；回流则是元素的位置或尺寸发生了改变，浏览器需 要重新计算渲染树，导致渲染树的一部分或全部发生变化。渲染树重新建立后，浏览器会重新绘制页面上受影响的元素。\n\n这就是DOM树\n回流的代价比重绘的代价高很多，重绘会影响部分的元素，而回流则有可能影响全部的元素。\n\n\n\n\n\n\n\n\n\n注意：回流必将引起重绘，而重绘不一定会引起回流。\n那我们怎样优化和避免重绘和回流?1. 合并多次的DOM操作为单次的DOM操作var element = document.getElementById('content');\n//多次的DOM操作\nelement.style.borderColor = 'white';\nelement.style.borderStyle = 'solid';\nelement.style.borderWidth = '1px';\n//优化方案:1.可合并为一次\nelement.style.cssText += 'border: 1px solid white;background-color:green;';\n//2.添加className\nelement.className += 'empty';\n2.把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上把DOM元素从页面流中脱离或隐藏，这样处理后，只会在DOM元素脱离和添加时，或者是隐藏和显示时才会造成页面的重绘或回流，对脱离了页面布局流的DOM元素操作就不会导致页面的性能问题。这种方式适合那些需要大批量修改DOM元素的情况。\nvar myElement = document.getElementById('content');\nmyElement.style.display = 'none';\n// 一些基于myElement的大量DOM操作\n...\nmyElement.style.display = 'block';\n\n3.克隆DOM元素到内存中这种方式是把页面上的DOM元素克隆一份到内存中，然后再在内存中操作克隆的元素，操作完成后使用此克隆元素替换页面中原来的DOM元素。这样一来，影响性能的操作就只是最后替换元素的这一步操作了，在内存中操作克隆元素不会引起页面上的性能损耗。\nvar old = document.getElementById('content');\nvar newElement= old.cloneNode(true); //复制DOM元素到内存中\n// 一些基于clone的大量DOM 操作\n...\n//替换原来DOM元素\nold.parentNode.replaceChild(newElement, old);\n\n4.使用JS模板引擎在大批量的DOM元素操作,其实最方便或最有效的操作,应该是使用JS模板引擎,例如有artTemplate、Mustache等\n5.使用Virtual DOM.这也是目前主流的前端框架(React、Vue、Angular)所使用的方式,将会在下一节详细讲述。\n","slug":"影响前端性能的元凶-DOM操作","date":"2019-09-01T13:42:09.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"b3ec5d64b85b68cc27c66fb82f00e4d5","title":"你听过JS的Event Loop吗","content":"前言不得不说, Event Loop在面试中的频率真的很高, 之前总觉得自己了解得差不多，可是当第一次被问到的时候，却不知道该从哪里开始说起，涉及到的知识点很多。于是花时间梳理了一下,并不仅仅是因为面试遇到了，而是理解JavaScript事件循环机制也能让我们平常遇到的疑惑也得到解答。\n大家都知道JavaScript是单线程语言, 可是你知道为什么它是单线程吗？\n答案就是, 为了保证用户界面的强一致性,Javascript可以直接与界面交互。假想一下，如果Javascript采用多线程策略，各个线程都能操作DOM，那最终的界面呈现到底以谁为准呢？这显然是存在矛盾的。因此，Javascript选择使用单线程模型。\n确定JavaScript是单线程语言后, 我们就势必会遇到一个问题, 当遇到多任务需要处理时, JavaScript怎么处理呢？如果不处理这种情况, 那么当某个任务很耗时，就会导致后面的一系列的任务堵塞, 不执行了, 直接导致页面不响应, 进入”假死”状态了, 这显示是不符合实际情况的, 于是乎, 就诞生了我们今天所讲的Event Loop机制了。\n核心内容用一段代码举例一下\nconsole.log('start');\nsetTimeout(() => &#123;\n    console.log('children2');\n    Promise.resolve().then(() => &#123;\n        console.log('children3');\n    &#125;)\n&#125;, 0);\n\nnew Promise(function(resolve, reject) &#123;\n    console.log('children4');\n    setTimeout(function() &#123;\n        console.log('children5');\n    &#125;, 0)\n    resolve('children6')\n&#125;).then((res) => &#123;\n    console.log('children7');\n    setTimeout(() => &#123;\n        console.log(res);\n    &#125;, 0)\n&#125;)\n\n代码的执行结果如下：\nstart\nchildren4\nchildren7\nchildren2\nchildren3\nchildren5\nchildren6\n\n如果你对Event Loop的机制暂不熟悉, 那么对以上代码的执行结果就会十分迷惑不解, 而这也是面试题常常出现的Event Loop考题，所以我们有必要深究其执行顺序的规则和原理。\n本质上来说，Javascript的任务在执行阶段都是按顺序执行，但是JS引擎在解析Javascript代码时，会把代码分为同步任务和异步任务。同步任务直接进入执行栈执行；异步任务进入任务队列，并且在接下来的Event Loop中被处理。\n异步任务又分为**Macrotask和Microtask**，即宏任务与微任务, 他们各自有单独的数据结构和内存来维护。\n宏任务与微任务\n\n\n\n\n\n\n\n\n常见的宏任务：\n\nsetTimeout\nsetInterval\nI/O(文件、网络)相关API\nDOM事件监听(浏览器环境)\nsetImmediate(Node环境)\n\n\n\n\n\n\n\n\n\n\n常见的微任务：\n\nMutationObserver(浏览器环境, 描述)\nPromise.prototype.then, Promise.prototype.catch, Promise.prototype.finally\nprocess.nextTick(Node环境)\nqueueMicrotask\n\nEvent Loop 流程\n具体流程描述如下:\n当某个宏任务执行完后,会查看是否有微任务队列任务。如果有，先依次执行微任务队列完中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。执行栈空后，再次读取微任务队列里的任务，依次类推。\n咱们也可以通过一个动图来熟悉一下\n\n\n全局代码压入执行栈执行，输出 start\nsetTimeout压入 macrotask队列，promise.then 回调放入 microtask队列，最后执行 console.log(&#39;end&#39;)，输出 end\n调用栈中的代码执行完成（全局代码属于宏任务），接下来开始执行微任务队列中的代码，执行promise回调，输出 promise1, promise回调函数默认返回 undefined, promise状态变成 fulfilled ，触发接下来的 then回调，继续压入 microtask队列，此时产生了新的微任务，会接着把当前的微任务队列执行完，此时执行第二个 promise.then回调，输出 promise2\n此时，microtask 队列 已清空，接下来会会执行 UI 渲染工作（如果有的话），然后开始下一轮event loop, 执行 setTimeout的回调，输出 setTimeout\n\n\n经典面试题如果你已经熟悉Event Loop的机制, 可以尝试不看答案做题，看看自己是否掌握了.\n例题一// 以下的代码输出顺序是什么？\nasync function async1() &#123;\n    console.log('async1 start');\n    await async2();\n    console.log('async1 end');\n&#125;\nasync function async2() &#123;\n    console.log('async2');\n&#125;\nconsole.log('script start');\nsetTimeout(function() &#123;\n    console.log('setTimeout');\n&#125;, 0)\nasync1();\nnew Promise(function(resolve) &#123;\n    console.log('promise1');\n    resolve();\n&#125;).then(function() &#123;\n    console.log('promise2');\n&#125;);\nconsole.log('script end');\n\n先执行宏任务（当前代码块也算是宏任务），然后执行当前宏任务产生的微任务，然后接着执行宏任务\n\n从上往下执行代码，先执行同步代码，输出 script start\n遇到setTimeout，现把 setTimeout 的代码放到宏任务队列中\n执行 async1()，输出 async1 start, 然后执行 async2(), 输出 async2，把 async2() 后面的代码 console.log(&#39;async1 end&#39;)放到微任务队列中\n接着往下执行，输出 promise1，把 .then() 放到微任务队列中；注意Promise 本身是同步的立即执行函数，.then是异步执行函数\n接着往下执行， 输出 script end。同步代码（同时也是宏任务）执行完成，接下来开始执行刚才放到微任务中的代码\n依次执行微任务中的代码，依次输出 async1 end、 promise2, 微任务中的代码执行完成后，开始执行宏任务中的代码，输出 setTimeout\n\n最后的执行结果如下\n\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n\n例题二// 以下的代码输出顺序是什么？\nconsole.log('start');\nsetTimeout(() => &#123;\n    console.log('children2');\n    Promise.resolve().then(() => &#123;\n        console.log('children3');\n    &#125;)\n&#125;, 0);\n\nnew Promise(function(resolve, reject) &#123;\n    console.log('children4');\n    setTimeout(function() &#123;\n        console.log('children5');\n        resolve('children6')\n    &#125;, 0)\n&#125;).then((res) => &#123;\n    console.log('children7');\n    setTimeout(() => &#123;\n        console.log(res);\n    &#125;, 0)\n&#125;)\n\n这道题跟上面题目不同之处在于，执行代码会产生很多个宏任务，每个宏任务中又会产生微任务\n\n从上往下执行代码，先执行同步代码，输出 start\n遇到setTimeout，先把 setTimeout 的代码放到宏任务队列①中\n接着往下执行，输出 children4, 遇到setTimeout，先把 setTimeout 的代码放到宏任务队列②中，此时.then并不会被放到微任务队列中，因为 resolve是放到 setTimeout中执行的\n代码执行完成之后，会查找微任务队列中的事件，发现并没有，于是开始执行宏任务①，即第一个 setTimeout， 输出 children2，此时，会把 Promise.resolve().then放到微任务队列中。\n宏任务①中的代码执行完成后，会查找微任务队列，于是输出 children3；然后开始执行宏任务②，即第二个 setTimeout，输出 children5，此时将.then放到微任务队列中。\n宏任务②中的代码执行完成后，会查找微任务队列，于是输出 children7，遇到 setTimeout，放到宏任务队列中。此时微任务执行完成，开始执行宏任务，输出 children6;\n\n最后的执行结果如下\n\nstart\nchildren4\nchildren2\nchildren3\nchildren5\nchildren7\nchildren6\n\n例题三// 以下的代码输出顺序是什么？\nconst p = function() &#123;\n    return new Promise((resolve, reject) => &#123;\n        const p1 = new Promise((resolve, reject) => &#123;\n            setTimeout(() => &#123;\n                resolve(1)\n            &#125;, 0)\n            resolve(2)\n        &#125;)\n        p1.then((res) => &#123;\n            console.log(res);\n        &#125;)\n        console.log(3);\n        resolve(4);\n    &#125;)\n&#125;\n\n\np().then((res) => &#123;\n    console.log(res);\n&#125;)\nconsole.log('end');\n\n\n执行代码，Promise本身是同步的立即执行函数，.then是异步执行函数。遇到setTimeout，先把其放入宏任务队列中，遇到p1.then会先放到微任务队列中，接着往下执行，输出 3\n遇到 p().then 会先放到微任务队列中，接着往下执行，输出 end\n同步代码块执行完成后，开始执行微任务队列中的任务，首先执行 p1.then，输出 2, 接着执行p().then, 输出 4\n微任务执行完成后，开始执行宏任务，setTimeout, resolve(1)，但是此时 p1.then已经执行完成，此时 1不会输出。\n\n最后的执行结果如下\n\n3\nend\n2\n4\n\n你可以将上述代码中的 resolve(2)注释掉, 此时 1才会输出\nconst p = function() &#123;\n    return new Promise((resolve, reject) => &#123;\n        const p1 = new Promise((resolve, reject) => &#123;\n            setTimeout(() => &#123;\n                resolve(1)\n            &#125;, 0)\n        &#125;)\n        p1.then((res) => &#123;\n            console.log(res);\n        &#125;)\n        console.log(3);\n        resolve(4);\n    &#125;)\n&#125;\n\n\np().then((res) => &#123;\n    console.log(res);\n&#125;)\nconsole.log('end');\n\n注释后, 输出结果就会变成3 end 4 1.\n面试回答如果是在面试中被问到Event Loop机制, 我也总结了一下回答的内容, 你可以参考着回答。\n\n\n\n\n\n\n\n\n\n因为JS是单线程的, 所以JS在执行阶段都是按顺序执行, 但是JS引擎在解析Javascript代码时，会把代码分为同步任务和异步任务。同步任务直接进入执行栈执行,异步任务会进入任务队列，并且在接下来的Event Loop中被处理。\n\n\n\n\n\n\n\n\n\n异步任务又分为Macrotask和Microtask，即宏任务与微任务, 他们各自有单独的队列来维护，\n\n\n\n\n\n\n\n\n\n常见的的宏任务有: I&#x2F;O代码相关API、DOM事件监听、定时器\n\n\n\n\n\n\n\n\n\n常见的微任务: MutationObserver、new Promise.then()/catch()/finally()\n\n\n\n\n\n\n\n\n\n具体的Event Loop是这样的, 在查看宏任务队列是否有任务, 有的话, 执行第一个宏任务, 执行完成之后查看微任务队列, 如果发现有微任务, 依次执行完微任务队列里的所有任务, 执行完后再判断是否需要浏览器渲染, 再重复整个过程,。\n看到结尾，相信大家也累了，感谢各位读者的阅读！希望本文对宏任务和微任务的解读能给各位读者带来一点启发。\n参考文献&gt; JavaScript中的Event Loop（事件循环）机制\n&gt; Event Loop Processing Model\n","slug":"你听过JS的Event-Loop吗","date":"2021-04-01T08:38:21.000Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"Xposean"},{"id":"212a81230ed6f68dcc9f987f4bdbd2fa","title":"老生常谈的原型链","content":"前言今天咱们来谈谈在JavaScript中常常被提及的原型链, 原型链的概念比较抽象, 所以初学时会难以理解, 但因为原型链又是JavaScript中十分重要的概念, 所以学习好原型链是十分有必要的。\n理解原型链其实原型链咱们可以拆分成两个关键词:\n\n原型(prototype)\n链(__proto__)\n\n原型(prototype)原型（prototype）是一个普通的对象，它为构造函数的实例共享了属性和方法。在所有的实例中，引用到的原型都是同一个对象。\n\n\n\n\n\n\n\n\n\n函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。\n以代码为例：\n// 构造函数 Student\nfunction Student(name) &#123; \n    this.name = name \n    this.study = function () &#123;\n        console.log('study js')\n    &#125;\n&#125;\n\n// 创建2个实例\nconst xiaoming = new Student('xiaoming')\nconst xiaohong = new Student('xiaohong')\nxiaoming.study()\nxiaohong.study()\n\n在上面的代码中, 我们创建了2个Student实例:xiaowang和xiaohong, 每个实例都有一个study方法, 用来打印study js.\n如果没有prototype会怎样呢？\n2个实例中的study方法都是独立的, 虽然功能相同, 但在系统中占用的是2分内存, 如果创建的是100个实例，就得占用100份内存,这样的话, 就会造成大量的内存浪费。\n// 使用prototype\nfunction Student(name) &#123; \n    this.name = name \n&#125;\nStudent.prototype.study = function() &#123;\n\tconsole.log('study js')\n&#125;\n// 创建2个实例\nconst xiaoming = new Student('xiaoming')\nconst xiaohong = new Student('xiaohong')\nxiaoming.study() // study js\nxiaohong.study() // study js\n\n\n使用 prototype 之后， study 方法存放在 Student 的原型中，内存中只会存放一份，所有 Student 实例都会共享它，内存问题就迎刃而解了。\nprototype设计之初其实就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了prototype我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）,那些不需要共享的才创建在构造函数中。\n可是还有一个问题 !\n\n\n\n\n\n\n\n\n\n为什么xiaohong和xiaoming两个实例能够访问到Student原型上的属性和方法呢？\n那就得介绍__proto__了。\n链(__proto__)链（__proto__）可以理解为一个指针，它是实例对象中的一个属性，指向了构造函数的原型（prototype）。即从一个对象指向该对象的原型对象（也可以理解为父对象）,显然它的含义就是告诉我们一个对象的原型对象是谁。\n以代码为例：\nfunction Student(name) &#123;\n  this.name = name\n&#125;\nStudent.prototype.study = function () &#123;\n  console.log('study js')\n&#125;\nconst xiaoming = new Student('xiaoming')\nxiaoming.study() // study js\nconsole.log(xiaoming.__proto__ === Studuent.prototype) // true\n\n从打印结果可以得出：函数实例的 __proto__ 指向了构造函数的 prototype，上文中遗留的问题也就解决了。\n但很多同学可能有这个疑问。\n\n\n\n\n\n\n\n\n\n为什么调用 xiaoming.study 时，访问到的却是 Student.prototype.study 呢？\n答案在原型链中，我们接着往下看。\n原型链原型链指的是：一个实例对象，在调用属性或方法时，会依次从实例本身、构造函数原型、构造函数原型的原型… 上去寻找，查看是否有对应的属性或方法。这样的寻找方式就好像一个链条一样，从实例对象，一直找到 Object.prototype ，专业上称之为原型链。\n同样的拿代码举例：\nfunction Student(name) &#123;\n  this.name = name;\n&#125;\nStudent.prototype.study = function () &#123;\n  console.log(\"study js\");\n&#125;;\n\nconst student = new Student(\"xiaoming\");\nstudent.study(); // study js。\n// 1.在实例中没找到，2.在构造函数的原型上找到了。\n// 实际调用的是：student.__proto__.study 也就是 Student.prototype.study。\n\nstudent.toString(); // \"[object Object]\"\n// 1.在实例中没找到。\n// 2.在构造函数的原型上也没找到。\n// 3.在构造函数的原型的原型上找到了。\n// 实际调用的是 student.__proto__.__proto__.toString 也就是 Object.prototype.toString。\n\n所以看到， __proto__ 就像一个链一样，串联起了实例对象和原型。\n你可能还会疑问。\n\n\n\n\n\n\n\n\n\n为什么 Student.protype.__proto__是 Object.protype呢？\n这里有个推导步骤可供参考：\n\n先找 __proto__ 前面的对象，也就是 Student.prototype 的构造函数。\n\n\n判断 Student.prototype 类型， typeof Student.prototype 是 object。\nobject 的构造函数是 Object。\n得出Student.prototype 的构造函数是 Object。\n\n\n所以 Student.prototype.__proto__ === Object.prototype。\n\n\n这个推导方法很实用，除了自定义构造函数对象之外，其他对象都可以推导出正确答案。\n原型链常见问题\n\n\n\n\n\n\n\n\nFunction.__proto__ 是什么？\n\n找Function的构造函数\na. 判断Function类型, 即typeof Function 是 function.\nb. function类型的构造函数就是Function.\nc. 得出Function的构造函数是Function.\n\n故 Function.__proto__ === Function.prototype.\n\n\n\n\n\n\n\n\n\n\n\nNumber.__proto__ 是什么？\n\n找Number的构造函数\na. 判断Number类型, 即 typeof Number是function.\nb. function类型的构造函数就是Function.\nc. 得出Number的构造函数是Function\n\n故 Number.__proto__ === Function.prototype.\n\n\n\n\n\n\n\n\n\n\n\nObject.prototype.__proto__ 是什么？\n这里是个特例, 如果按照前面推导步骤, Object.prototype.__proto__ 是 Object.prototype，但这是不对的，因为这样下去原型链就在 Object 处无限循环了。\n为了解决这个问题，JavaScript就直接在规定了 Object.prototype.__proto__ 为 null，打破了原型链的无线循环。\n然而 null 究竟代表了什么呢？\n引用阮一峰老师的 《undefined与null的区别》 就是：\n\n\n\n\n\n\n\n\n\nnull 表示“没有对象”，即该处不应该有值。\n所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n所以查找属性的时候查到 Object.prototype 就可以停止查找了。\n那么如果以下这张图片你能看懂, 那也就是你已经理解原型链了。\n\n","slug":"老生常谈的原型链","date":"2021-03-12T06:43:27.000Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"Xposean"},{"id":"f72948e64ab8542e417504906d3a8265","title":"你好, 请你解释一下浏览器缓存策略","content":"前言前段时间, 被面试官问了一个之前完全没有留意的问题, 你知道什么是浏览器的缓存策略吗？知道的话,能不能解释一下缓存策略的内容, 这下可把我问懵了, 毕竟那会对于浏览器缓存只是一知半解, 更别说浏览器缓存策略了, 于是下定决定查阅了相关资料, 于是才有了这篇文章。\n概述浏览器缓存策略的目的是为了可以降低资源的重复加载, 并提高网页的整体加载速度。\n通常缓存策略可分为两种: 强缓存和协商缓存\n基本流程\n浏览器加载资源时, 首先通过 响应头中的Expires(时间值)、 Cache-Control (相对值)验证强缓存是否可用, 如可用, 则直接从缓存读取资源，不会发请求到服务器。\n\n否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新\n\n若命中缓存,则返回304状态码，告诉浏览器直接从缓存获取资源\n\n若没有命中, 则直接从服务器加载资源\n\n\n异同点相同的地方: 如果命中, 都是从客户端中读取缓存, 而不是从服务端加载数据。\n不同的地方: 强缓存不发送请求到服务端, 而协商缓存会请求到服务端。\n\n\n\n\n\n\n\n\n\n那我们怎么区分一个请求是使用了协商缓存或强缓存呢？\n十分简单, 通过HTTP状态码即可得知\n命中强缓存的请求, Status Code为200 (from memory cache)或 200(from disk  cache)\n\n命中协商缓存的, Status Code为304\n\n强缓存强缓存就是通过Expires和Cache-Control两种响应头实现\nExpiresExpires即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:\nExpires: Wed, 22 Nov 2019 08:41:00 GMT\n\n表示资源在2019年11月22号8点41分过期，过期了就得向服务端发请求。\n这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器本地的时间可能并不一致，那么服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。\nCache-Control在HTTP1.1中，采用了一个非常关键的字段：Cache-Control。这个字段也是存在于响应头中的.\n它和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age。比如这个例子:\nCache-Control:max-age=3600\n\n代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。\ncache-control其实可以组合非常多的指令，完成更多场景的缓存判断, 如下图所示：\n\n更多的详情可以查看: cache-control文档\n值得注意的是, cache-control中禁用缓存的指令不是 no-cache, no-cache表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。真正禁用缓存的指令是 no-store\n小结Expires 是http1.0的产物，Cache-Control 是http1.1的产物。\nCache-Control 相对于 Expires 更加准确，它的优先级也更高, \n当两者都存在时, Cache-Control会优先考虑; 在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。\n协商缓存当浏览器对某个资源的请求没有命中强缓存时，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串\n而协商缓存是利用的是Last-Modified/If-Modified-Since和ETag/If-None-Match这两对Header来管理的, 这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存中的两个 tag 不一样。\nIf-Modified-since&#x2F;Last-Modified即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。\nLast-Modified: Fri, 22 Jul 2016 01:47:00 GMT\n\n浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。\nIf-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT\n\n服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:\n\n如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。\n否则返回304，告诉浏览器直接用缓存。响应头中不会再添加 Last-Modified 字段\n\nIf-None-Match&#x2F;ETagETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。\n浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。\n服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:\n\n如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。\n否则返回304，告诉浏览器直接用缓存\n\n两者对比\n在精准度上，ETag优于Last-Modified。优于ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况下并不能准确感知资源变化，主要有两种情况:\n\n\n编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。\nLast-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。\n\n\n在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值。\n\n另外，如果两种方式都支持的话，服务器会优先考虑ETag。\n缓存位置​    前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？\n浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：\n\nService Worker\nMemory Cache（内存缓存）\nDisk Cache（硬盘缓存）\nPush Cache（推送缓存）\n\nService Worker​    和Web Worker类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Worker使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的\nMemory Cache 和 Disk CacheMemory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。\nDisk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。\n好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：\n\n比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存\n内存使用率比较高的时候，文件优先进入磁盘\n\nPush Cache即推送缓存，这是浏览器缓存的最后一道防线。是HTTP/2的内容，目前应用较少\nPush Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段, 具体内容可以的可以查看HTTP&#x2F;2 简介\n\nPush Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。\nPush Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。\n不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。\n\n总结​    以上就是 关于浏览器缓存策略的全部内容了, 既然知道了缓存策略的规则, 那么我们在日常的开发项目中，对资源文件的缓存策略就有一个比较清晰的认识。\n​    对于一些改动比较频繁的, 例如index.html可以使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小, 且不会因为缓存导致请求了旧资源。\n​    而对于 不常变化的资源文件,，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (我们的webpack就能够实现这种功能)。\n在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。\n\n\n\n\n\n\n\n\n\n参考文章\n\n\n\n\n\n\n\n\n\n[缓存（二）——浏览器缓存机制：强缓存、协商缓存]\n\n\n\n\n\n\n\n\n\n[缓存机制]\n","slug":"你好-请你解释一下浏览器缓存策略","date":"2021-01-15T08:08:44.000Z","categories_index":"网络","tags_index":"网络","author_index":"Xposean"},{"id":"7ba40a83c9b0e7e96e8e9f3699affe32","title":"教你通过利用ssh编写前端一键部署脚本","content":"今天来介绍一下, 如何利用node编写部署脚本, 来实现一键部署的功能\n背景因为我司的开发流程比较特殊, 开发环境的服务器ip会经常变化, 并不固定, 所以在前端部署代码的时候十分麻烦,\n部署流程如下:\n \n可以看出, 这种方式存在一些缺点：\n\n每次部署都需要打开xshell或winSCP软件\n部署多个服务器ip,十分麻烦, 需要来回切换, 容易替换错误\n每次都需要手动复制代码或执行上传命令\n\n全自动化的部署其实首推jenkins实现，jenkins可以根据gitlab push或者merge事件自动打包代码到web目录，可以参考：\n实战笔记：Jenkins打造强大的前端自动化工作流\n但是因为我们的部署流程比较特殊, 并不是固定的几台服务器, 没有那么方便, 其次公司的gitlab最高权限是在总部, 操作起来比较麻烦, 需要申请权限, 于是为了能够快速的完成一键部署功能, 选用了采用轻量部署的方案来实现自动化部署了.\n方案预研我们想要达到的效果是: 运行 npm run deploy 的命令, 再输入部署的服务器ip, 就直接将执行打包部署等一系列操作。\n那么要达到这个效果, 首先就要使用到一些node 库了,\n1. node-ssh首先要知道的是, 我们想要通过本地连接到我们对应的服务器, 那么就要使用ssh协议连接服务器。\nnode-ssh是一个基于ssh2的轻量级npm包，主要用于ssh连接服务器、上传文件、执行命令, 通过它我们可以替代xshell的功能\n用到的api：\n\nssh.connect：连接服务器\n\nssh.connect(&#123;\n  host: 'localhost',\n  username: 'steel',\n  privateKey: '/home/steel/.ssh/id_rsa'\n&#125;)\n\n\nssh.putFile：上传文件\n\nssh.putFile('/home/steel/Lab/localPath', '/home/steel/Lab/remotePath').then(function() &#123;\n   console.log(\"The File thing is done\")\n &#125;, function(error) &#123;\n   console.log(\"Something's wrong\")\n   console.log(error)\n &#125;)\n\n\nssh.execCommand：执行远端服务器命令\n\nssh.execCommand('rm -r dist', &#123; cwd:'/var/www' &#125;).then(function(result) &#123;\n   console.log('STDOUT: ' + result.stdout)\n   console.log('STDERR: ' + result.stderr)\n &#125;)\n\n2. archiverarchiver是一个用于生成压缩包的npm包，可以把我们编译后的文件夹打包成zip、gz等格式的压缩包, 方便上传到服务端\n使用指南：\nconst archiver = require('archiver');\n\n// 设置压缩类型及级别\nconst archive = archiver('zip', &#123;\n  zlib: &#123; level: 9 &#125;,\n&#125;).on('error', err => &#123;\n  throw err;\n&#125;);\n\n// 创建文件输出流\nconst output = fs.createWriteStream(__dirname + '/dist.zip');\n\n// 通过管道方法将输出流存档到文件\narchive.pipe(output);\n\n// 从subdir子目录追加内容并重命名\narchive.directory('subdir/', 'new-subdir');\n\n// 完成打包归档\narchive.finalize();\n\n3. chalkchalk 就是用来在终端中优雅地输出带颜色的文本, 不需要记忆、查阅样式手册,直接调用chalk的函数可以很方便的显示不同颜色不同样式的终端文字, 效果大致如下：\n\nchalk 将各种颜色和样式修饰符实现为各个函数，并且支持链式调用。\nconst chalk = require('chalk');\n\n// 输出蓝色的MCC\nconsole.log(chalk.blue('MCC'));\n\n// 输出蓝色带下划线的MCC\nconsole.log(chalk.blue.underline('MCC'));\n\n// 使用RGB颜色输出\nconsole.log(chalk.rgb(4, 156, 219).underline('MCC'));\nconsole.log(chalk.hex('#049CDB').bold('MCC'));\nconsole.log(chalk.bgHex('#049CDB').bold('MCC'));\n\n\n\n4. inquirer因为我们的命令行使用过程中需要 用户输入或者选择一些参数, 那么就可以使用inquirer来处理用户的终端输入, 实现终端交互。很多cli脚手架都是使用inquirer来实现配置的哦。\nconst promptList = [&#123;\n    type: 'input',\n    name: 'IP',\n    message: 'please input hostIP(example: 10.30.1.1)?',\n    default: '10.30.10.62',\n    validate: async (input) => &#123;\n        if (input === '') &#123;\n            return 'IP is require!!(ctrl+c exit)'\n        &#125;\n        return true\n    &#125;\n&#125;];\n\n就可以实现以下的效果：\n\n5. ora如果想要在命令行中添加比较好看的loading, 这个时候ora就可以派上用场了, 在一些需要网络通信场合, 加上loading可以拥有更好的用户体验, 所有这里我们还是给它加上。\nconst ora = require('ora');\n \nconst spinner = ora('Loading unicorns').start();\n \nsetTimeout(() => &#123;\n    spinner.color = 'yellow';\n    spinner.text = 'Loading rainbows';\n&#125;, 1000);\n\n\n那么以上就是我们在开发部署功能中会使用到的库了.\n方案实践那么在实际开发阶段, 我们共大致有这几个流程:\n\n流程如下：\n\n提示用户输入 服务器IP、用户名(root)、密码(如果服务器IP是固定的, 可以统一写在配置文件里)\n通过node-ssh测试连接服务器是否正常(固定服务器可不测试)\n本地执行打包命令例：npm run build生成dist文件夹\n通过archiver将dist文件夹打包成dist.tar.gz(linux系统可以直接解压此格式, 无需另外安装其他库)\n连接服务器并上传压缩包，使用ssh.putFile上传dist.tar.gz\n服务端解压缩dist.tar.gz，并重启nginx服务\n删除本地dist.tar.gz文件\n\n具体代码通过npm下载对应的库\nnpm install node-ssh ora chalk inquirer shelljs archiver --save-dev\n\n\n\n//deploy.js 代码已注释\nconst Node_ssh = require('node-ssh')\nconst path = require('path')\nconst ora = require('ora')\nconst chalk = require('chalk')\nconst inquirer = require('inquirer')\nconst shell = require('shelljs')\nconst projectDir = process.cwd()\nconst ssh = new Node_ssh()\nconst fs = require('fs')\nconst archiver = require('archiver')\n\nconst resolve = dir => &#123;\n  return path.join(__dirname, dir)\n&#125;\n// loggs\nconst errorLog = error => console.log(chalk.red(`*********$&#123;error&#125;*********`))\nconst defaultLog = log => console.log(chalk.blue(`*********$&#123;log&#125;*********`))\nconst successLog = log => console.log(chalk.green(`*********$&#123;log&#125;*********`))\n// 编译模式(纯编译、打包为压缩包、打包并上传)\nlet deployMode = 'deploy'\n// 文件夹位置\nconst distDir = path.resolve(__dirname, '../dist')\nconst distZipPath = path.resolve(__dirname, '../dist.tar.gz')\nconst host = ''\nlet ipFileContent = ''\nconst sshConfig = &#123;\n  host,\n  username: 'root', // 默认用户名\n  port: 22 // SSH端口\n&#125;\n\n// ********* TODO 打包代码 *********\nconst compileDist = async () => &#123;\n  // 进入本地文件夹\n  defaultLog('开始编译打包代码')\n  shell.cd(path.resolve(__dirname, '../'))\n  shell.exec(`npm run build`)\n  successLog('编译完成')\n&#125;\nconst runTask = async (isRepeat) => &#123;\n  if (isRepeat) &#123;\n\n  &#125;\n  defaultLog('进入前端代码打包自动替换模式')\n  // 判断是否存在 dist 文件夹有则询问是否重新编译\n  const modePromptList = [\n    &#123;\n      type: 'list',\n      name: 'mode',\n      choices: [\n        &#123;\n          name: 'Packed into packages(.tar.gz)',\n          value: 'gzip',\n          short: 'gzip'\n        &#125;,\n        &#123;\n          name: 'Packed into dist folder',\n          value: 'build',\n          short: 'build'\n        &#125;,\n        &#123;\n          name: 'Auto deploy',\n          value: 'deploy',\n          short: 'deploy'\n        &#125;\n      ],\n      message: 'Please choice your mode?',\n      default: 'deploy'\n    &#125;\n  ]\n  const modePromptValue = await inquirer.prompt(modePromptList)\n  deployMode = modePromptValue.mode\n  let deployPromptList = []\n  if (deployMode === 'deploy') &#123;\n    deployPromptList = [\n      &#123;\n        type: 'input',\n        name: 'IP',\n        message: 'please input hostIP(example: 10.30.1.1)?',\n        default: '10.30.10.62',\n        validate: async (input) => &#123;\n          if (input === '') &#123;\n            return 'IP is require!!(ctrl+c exit)'\n          &#125;\n          return true\n        &#125;\n      &#125;,\n      &#123;\n        type: 'input',\n        name: 'username',\n        message: 'please input username(example: root)?',\n        default: 'root'\n      &#125;,\n      &#123;\n        type: 'Password',\n        name: 'password',\n        message: 'please input password(example: root)?',\n        default: 'root'\n      &#125;\n    ]\n  &#125;\n  if (deployMode !== 'build' &amp;&amp; fs.existsSync(distDir)) &#123;\n    deployPromptList.push(&#123;\n      type: 'confirm',\n      name: 'isRebuild',\n      message: 'Do you need to rebuild dist folder?',\n      default: false\n    &#125;)\n  &#125;\n  const promptValueList = await inquirer.prompt(deployPromptList)\n  if (deployMode === 'gzip') &#123;\n    const isRebuild = promptValueList.isRebuild\n    if (isRebuild || !fs.existsSync(distDir)) &#123; // 重新编译本地代码\n      await compileDist()\n      startZip(sshConfig)\n    &#125; else &#123; // 直接压缩上传代码\n      startZip(sshConfig)\n    &#125;\n    return\n  &#125; else if (deployMode === 'build') &#123;\n    await compileDist()\n    return\n  &#125;\n  let sshConnectState\n  sshConfig.host = promptValueList.IP\n  sshConfig.username = promptValueList.username\n  sshConfig.password = promptValueList.password\n  const spinner = ora(&#123; text: `正在连接 $&#123;sshConfig.host&#125; \\n`,\n    spinner: &#123;\n      interval: 80, // Optional\n      frames: ['⠋',\n        '⠙',\n        '⠹',\n        '⠸',\n        '⠼',\n        '⠴',\n        '⠦',\n        '⠧',\n        '⠇',\n        '⠏'\n      ]\n    &#125;\n  &#125;)\n  spinner.start()\n  try &#123;\n    sshConnectState = await checkSSHConnect(sshConfig)\n  &#125; catch (err) &#123;\n    spinner.stop()\n    if (err === 'client-authentication') &#123; // 验证错误, 则重新输入密码\n      sshConnectState = await handleAuthError(sshConfig, spinner)\n    &#125; else &#123;\n      errorLog('ssh 连接异常！请输入正确的IP地址、用户名或密码', err)\n      return\n    &#125;\n  &#125;\n  if (sshConnectState === 'success') &#123;\n    successLog('ssh 连接成功')\n    spinner.stop()\n    const isRebuild = promptValueList.isRebuild\n    ipFileContent = readApiFile()\n    // console.log('ipFileContent', ipFileContent)\n    if (isRebuild || !fs.existsSync(distDir)) &#123; // 重新编译本地代码\n      await compileDist()\n      startZip(sshConfig)\n    &#125; else &#123; // 直接压缩上传代码\n      startZip(sshConfig)\n    &#125;\n  &#125; else &#123;\n    spinner.stop()\n    errorLog('ssh 连接异常！请输入正确的IP地址、用户名或密码')\n  &#125;\n&#125;\nasync function handleAuthError (sshConfig, spinner) &#123;\n  /* eslint-disable-next-line */\n  errorLog('ssh 连接错误！请输入正确的密码')\n  const errorPromptList = [\n    &#123;\n      type: 'Password',\n      name: 'password',\n      message: 'please input password(example: root)?',\n      default: 'root'\n    &#125;\n  ]\n  const errorPromptValueList = await inquirer.prompt(errorPromptList)\n  let sshConnectRepeatState = ''\n  sshConfig.password = errorPromptValueList.password\n  try &#123;\n    spinner = ora(`正在连接 $&#123;sshConfig.host&#125; \\n`)\n    spinner.start()\n    sshConnectRepeatState = await checkSSHConnect(sshConfig)\n    spinner.stop()\n    return sshConnectRepeatState\n  &#125; catch (error) &#123;\n    spinner.stop()\n    if (error === 'client-authentication') &#123; // 验证错误, 则重新输入密码\n      /* eslint-disable-next-line */\n      return await handleAuthError(sshConfig, spinner)\n    &#125; else &#123;\n      return error\n    &#125;\n  &#125;\n&#125;\n// 开始打包\nasync function startZip (config) &#123;\n  try &#123;\n    if (fs.existsSync(distZipPath)) &#123;\n      defaultLog('dist.zip已经存在, 即将删除压缩包')\n      fs.unlinkSync(distZipPath)\n    &#125; else &#123;\n      defaultLog('即将开始压缩zip文件')\n    &#125;\n    await compress('dist', path.basename('dist.tar.gz'))\n    // await zipper.sync.zip(distDir).compress().save(distZipPath)\n    successLog('文件夹压缩成功')\n  &#125; catch (error) &#123;\n    errorLog(error)\n    errorLog('压缩dist文件夹失败')\n    process.exit(0)\n  &#125;\n  if (deployMode === 'deploy') &#123;\n    uploadFile(config)\n  &#125; else &#123;\n    successLog('执行完毕')\n  &#125;\n&#125;\n// 测试是否联通ssh\nconst checkSSHConnect = async () => &#123;\n  return new Promise((resolve, reject) => &#123;\n    ssh.connect(sshConfig).then(() => &#123;\n      resolve('success')\n    &#125;).catch((err) => &#123;\n      // console.log('err', err.level)\n      reject(err.level || 'unknown error')\n    &#125;)\n  &#125;)\n&#125;\n// 上传文件\nfunction uploadFile (config) &#123;\n  const spinner = ora(`正在连接 $&#123;host&#125;`)\n  spinner.start()\n  ssh.connect(sshConfig)\n    .then(() => &#123;\n      spinner.stop()\n      // successLog(`  SSH连接成功`)\n      defaultLog(`上传zip至目录$&#123;sshConfig.webDir&#125;`)\n      ssh.putFile(`$&#123;projectDir&#125;/dist.tar.gz`, `$&#123;sshConfig.webDir&#125;/dist.tar.gz`)\n        .then(() => &#123;\n          successLog(`  zip包上传成功`)\n          defaultLog('解压zip包')\n          statrRemoteShell(config)\n        &#125;)\n        .catch(err => &#123;\n          console.error('  文件传输异常', err)\n          process.exit(0)\n        &#125;)\n    &#125;)\n    .catch(err => &#123;\n      console.error(' 连接失败', err)\n      process.exit(0)\n    &#125;)\n&#125;\n// 执行Linux命令\nfunction runCommand (command, webDir) &#123;\n  return new Promise((resolve, reject) => &#123;\n    defaultLog(`执行命令$&#123;command&#125;`)\n    // console.log('webDir', webDir)\n    ssh.execCommand(command, &#123; cwd: webDir &#125;)\n      .then(result => &#123;\n        resolve()\n        if (result.stdout) &#123;\n          // console.log(result.stdout)\n        &#125;\n        if (result.stderr &amp;&amp; result.stderr.indexOf('debconf: unable to initialize frontend: Dialog') > -1) &#123;\n          errorLog('执行出错, 正在重试...')\n          runCommand(command, webDir)\n        &#125; else if (result.stderr) &#123;\n          console.error('执行命令出错', result.stderr)\n          process.exit(1)\n        &#125;\n      &#125;)\n      .catch(err => &#123;\n        reject(err)\n      &#125;)\n  &#125;)\n&#125;\n// 开始执行远程命令\nasync function statrRemoteShell (config) &#123;\n  const &#123; webDir &#125; = config\n  try &#123;\n    // await runCommand('apt-get install unzip --force-yes', webDir)\n    await runCommand(`cd $&#123;webDir&#125;`, webDir)\n    await runCommand('rm -r dist', webDir)\n    // await runCommand(`mkdir dist`, webDir)\n    // await runCommand(`cd dist`, webDir)\n    // await runCommand(`unzip -o $&#123;webDir&#125;dist.zip `, `$&#123;webDir&#125;dist`)\n    // await runCommand(`rm -r dist.zip`, `$&#123;webDir&#125;`)\n    await runCommand(`tar -zxmf dist.tar.gz -C $&#123;webDir&#125;`, `$&#123;webDir&#125;`)\n    await runCommand(`rm -r dist.tar.gz`, `$&#123;webDir&#125;`)\n    await runCommand(`service nginx restart`, `$&#123;webDir&#125;`)\n    await runCommand(`service manager restart`, `$&#123;webDir&#125;`)\n    successLog('  解压成功')\n    deleteLocalZip(config)\n  &#125; catch (e) &#123;\n    console.error('  文件解压失败', err)\n    process.exit(0)\n  &#125;\n&#125;\n\n// 删除本地dist.zip包\nfunction deleteLocalZip (config) &#123;\n  const &#123; projectName, name &#125; = config\n  fs.unlink(`$&#123;projectDir&#125;/dist.tar.gz`, err => &#123;\n    if (err) &#123;\n      console.error('本地dist.zip删除失败', err)\n    &#125;\n    successLog('本地dist.zip删除成功')\n    backupApiFile()\n  &#125;)\n&#125;\n// 恢复被删除的devApiUrl 文件\nfunction backupApiFile () &#123;\n  fs.writeFile(resolve('./devApiUrl.js'), ipFileContent, (err) => &#123;\n    if (err) &#123;\n      errorLog('IP文件恢复失败', err)\n    &#125; else &#123;\n      successLog('IP文件恢复完成')\n      successLog(` 恭喜您，项目部署成功了^_^`)\n      process.exit(0)\n    &#125;\n  &#125;)\n&#125;\nfunction readApiFile () &#123;\n  return fs.readFileSync(resolve('./devApiUrl.js'), 'utf-8', (err, data) => &#123;\n    if (err) &#123;\n      errorLog('读取devApiUrl.js文件出错', err)\n    &#125; else &#123;\n      return data\n    &#125;\n  &#125;)\n&#125;\n// 压缩\nfunction compress (sourceDir, targetPath) &#123;\n  const output = fs.createWriteStream(targetPath)\n  const archive = archiver('tar', &#123;\n    gzip: true,\n    gzipOptions: &#123;\n      level: 5\n    &#125;\n  &#125;)\n  archive.pipe(output)\n  archive.directory(sourceDir, path.basename(sourceDir))\n  return archive.finalize()\n&#125;\nrunTask()\n\n\n上面的代码即是整个自动部署的全部代码了, 那么可以在 package.json中新增命令,类似以下这样.\n\n那么就可以很方便的使用 npm run deploy去执行我们的自动部署功能啦。\n优化方向后续可以考虑加入脚手架中, 并上传至私有的npm库, 这样在操作多个项目的时候, 需要重复复制部署代码, 直接通过npm instal xxx 执行。\n如果有更好的方案或者在文章中有错误的地方, 可以直接通过github联系我哦, 不胜感激\n","slug":"教你通过利用ssh编写一键部署脚本","date":"2020-05-19T11:21:17.000Z","categories_index":"开发技巧","tags_index":"开发技巧","author_index":"Xposean"},{"id":"f7aad555d08cbab83a738e706571ee98","title":"教你快速拥有一个免费的图床且快捷上传","content":"\n经常写博客的人都知道, 找图床是个很令人头疼的问题, 特别是我们这种没钱的, 总得找一些免费的图床, 一开始选择还比较多,  有微博图床、七牛云图床等等可供选择, 可是到了 2020年, 可选择且稳定还免费的图床, 越来越少了,于是无奈之下, 只能选择把图片手动上传到 github仓库, 然后通过https://raw.githubusercontent.com/xxx/xxx.png再去引入, 这种虽然也可以使用, 但是存在几个问题：\n\n在国内访问github仓库的图片太慢了, 而且还经常容易挂, 体验很不好。\n每次上传的时候都很麻烦, 得先手动上传, 然后在markdown编辑器里引入查看, 如果不合适的话, 又得重复上传, 再查看, 实在是影响效率。\n\n于是懒惰的我, 开始找合适的解决方案。\n解决方案首先来解决第一个问题, 访问速度慢的问题, github的访问虽然慢, 但是我们却可以通过cdn去访问, 于是我找到了一个十分强大且免费的cdn网站: jsdelivr, 通过这个cdn，你可以快速获取到npm、github、wordPress上的资源, 且比官方访问快速的多。jsDelivr十分强大, 通过它也可以加速你的挂在github pages上的静态资源, 让你的博客能够更快访问。\n\n其次, 第二个上传麻烦的问题, 这里我们同样找到了合适的”轮子“, 那就是PicGo, 这是一个能够配置参数后, 快捷上传图片到图床的软件, 支持常见的图床配置, 甚至可以通过编写插件配置自定义的图床。\n\n更加方便的是, 它能够与markdown编辑器:**Typora**配合使用, 在编辑器里拖入图片通过调用PicGo的服务自动上传到默认图床里, 简直是舒服极了。\n配置1. 新建github仓库这里创建的github仓库是专门用来存放图片的, 需要注意的是, 新建的仓库必须是公开的, 不能是私有的, 否则即便你可以上传图片, 你的图片其他人是访问不了的！\n\n然后再创建一个github的token, 后面配置图床的时候需要用到。\n\n2. 下载 PicGo并配置访问PicGo下载地址, 下载安装包后安装。\n\n安装完成后, 找到github图床,进行配置\n\n这里关键的地方是 设定自定义域名这一项，刚刚我们说到用jsdelivr可以加速访问github的资源, 那么在这里要填入https://cdn.jsdelivr.net/gh/github用户名称/图床仓库名称即可。\n再上传图片试试, 应该就没有问题了, 如果失败的话, 可以去**PicGo设置-日志文件里看看报错原因,**或者检查一下github图床的配置是否有误。\n\n\n上传图片前自动压缩图片使用PicGo的插件, 我们还能够实现在上传前把图片进行压缩后再进行上传, 也能够节省仓库空间, 且加快资源访问。\n打开PicGo, 找到插件设置, 输入compress,点击安装(可能安装不成功, 多试几次就好了)。\n\n使用效果实际在Typora中使用就是这样的啦, 直接把图片拖拽进来或右键插入图像, 都会自动触发upload(图片自动压缩上传并填充图床图片地址)。\n\n更多设置\n如果你拥有自己的域名(可以花几块钱, 在腾讯云或阿里云购买),并且备案通过, 也可以使用七牛云的图床, 七牛云支持更多配置和更大的存储空间, 并且上传速度更快。\n\n\n\n\n\n\n\n\n\n\n\n😄希望这篇文章能够帮助到您~~~💕\n","slug":"教你快速拥有一个免费的图床","date":"2020-05-11T09:42:32.000Z","categories_index":"开发技巧","tags_index":"开发技巧","author_index":"Xposean"},{"id":"8c7f3eb97377e5b415daeb0404588f05","title":"团队项目优化之路","content":"背景公司的前端项目是基于Vue技术栈为核心的前端项目,不得不说, 我花了接近将近一个多星期, 才对它有一定的了解, 在不包含引入库和依赖的情况下, 接近 43.3M, src文件下的.vue文件 接近700个, 这么大的项目, 可是让我疑惑的点是, 在优化的方面, 却有很多不足之处。\n\n项目中存在的问题：\n\n使用 vuex, 但不使用 vuex 的组件化通信,只是将 vuex 作为一个存储全局变量的作用,事实上 vuex 还有很多功能可以用到,例如 action 等,此外 vuex 没有分模块管理,只使用一个 store.js ,在项目功能越发复杂的情况,会导致该文件越发的庞大且难以维护\n样式集中于一个 style 文件,文件庞大难以维护,且极其容易出现样式污染的情况\nelementUI 的主题修改, elementUI 官方提供修改主题色的方式,使用现有的样式替换方式会导致一些组件样式使用上很奇怪\nAPI方法使用问题,第一个问题是内部封装的方法是用 mixin 去引入的,这就导致了只有在 vue 文件中才能使用,在一些特定的场景下无法使用,如路由钩子和一些自定义方法,其次是在使用某个请求方法的时候,代码可读性很差。\n开发代码无规范, 预计使用 eslint(standard) 、js命名使用小驼峰\ngit commit提交无规范, 随意提交\n构建代码时间过长,且 webpack 配置有待优化\n组件封装和代码风格问题\n前端权限路由系统\n\n以上问题, 在目前最新的项目中已基本完成修复, 这过程其实算是比较漫长的, 因为还要兼顾需求的开发和bug修复, 以及个别改动较大, 需要考虑时机进行整改, 例如代码规范这一项, 改动的范围就很大.\n那么以下就根据一个个修复点进行详解:\n1) Vuex 的使用文档首页: https://vuex.vuejs.org/zh/\n\n\n\n\n\n\n\n\n\nVuex 是一个专为 Vue.js 应用程序开发的 状态管理模式 。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n对于中大型项目而言, Vuex的使用是十分有必要性的, 项目一庞大, 势必带来层级关系复杂, 变量繁多的情况, 这个使用vuex能够较大程度的解决一些变量传值和统一管理的问题。\n在 Vuex 有几个核心概念,分别是 state , action , mutation , Module , Getter ,而我们的项目中只用到了 state 和 mutation ,此外因为项目既然已经使用了 vuex , 很多地方还是会出现, 一个变量传三四层组件的情况。\n项目中的 vuex 应分功能模块管理,尽量不耦合关联,项目成员只改动自己功能所属的 Vuex 模块代码, 这样, 多层嵌套的组件、兄弟组件间的状态会更好管理维护, 而且对开发者来说，如果你的项目足够复杂，团队的规模也不仅是一个人，那么数据集中处理更利于程序的稳定和维护。\n理想中的 Vuex 文件夹结构\n└── store\n   ├── index.js          # 我们组装模块并导出 store 的地方\n   ├── actions.js        # 根级别的 action\n   ├── mutations.js      # 根级别的 mutation\n   ├── getters.js      # 根级别的 getters\n   └── modules\n       ├── network  # 网络模块\n            └── actions.js   # 网络模块的 action\n            └── getters.js   # 网络模块的 getters          \n            └── mutations.js   # 网络模块的 mutation      \n            └── index.js   # 导出网络模块文件    \n       ├── user  # 用户模块\n            └── actions.js   # 用户模块的 action\n            └── getters.js   # 用户模块的 getters          \n            └── mutations.js   # 用户模块的 mutation      \n            └── index.js   # 导出用户模块文件    \n       ....\n\n而每次需要修改增加 store 的功能,则可以去对应的功能模块文件夹下新增或修改即可\n2) API的调用方式项目中 API 原来的调用方式是使用 Mixin 混入全局来进行使用的,这种方案问题很大。\n先来说缺陷:\n\n使用局限性,我们都知道mixin是只有在vue文件中才有的功能,那么就会导致封装的API方法只能在我们的vue文件中使用,如果在我们的 vuex 或者 vue-router 中去使用的话,是没办法使用的。\n代码可读性差, 在目前项目中,调用一个请求方法可能是这样的\n\nimport xxxApi from 'xxx/models/xxxApi' // 1. 引入mixin文件\nexport default &#123;\n\tmixins: [xxxApi] // 2. 引用\n&#125;\n// 参数\nlet params = &#123;\n  name: xxx,\n  age: xxxx\n&#125;\nself.hostphysicalList(params).then(res => &#123; // 3.使用\n// 接口返回处理\n&#125;)\n\n 如果这个使用在 vue的 method 定义了另一个hostphysicalList 命名相近的方法,这个时候其他成员在阅读代码的时候会比较清楚哪个才是真正的请求方法。\n\n命名空间容易冲突, api请求方法名很容易和原本自带的方法名重复。\n\n这种情况下, 势必要对 Api的请求方式和架构做调整.\nAPI目录：\n└── api\n   ├── index.js       # api方法入口文件\n   ├── http.js       # api方法核心文件\n   ├── modules        # api方法文件夹\n        ├── user.js  # 用户模块API方法\n        ├── cluster.js # 集群模块API方法\n        ├── tenant.js # 租户模块API方法\n\n// `http.js` \n// 1. 文件配置好`API`的公共配置并导出, 然后在每个方法中引入使用。\nimport axios from 'axios'\nimport router from '@/router/routerConfig'\nimport store from '@/vuex/store'\nimport Message from '@/components/message/' // 自定义message提示\nimport VueMessageBox from '@/components/message-box/' // 自定义confirm提示框\nimport NProgress from 'nprogress'\nimport sha256 from 'crypto-js/sha256'\nimport Base64 from 'crypto-js/enc-base64'\n/**\n * 请求失败(非200)后的错误统一处理\n * @param &#123;Number&#125; status 请求失败的状态码\n */\nconst errorHandle = (status, other) => &#123;\n  // 状态码判断\n  console.log('status', status)\n  switch (status) &#123;\n    // 404请求不存在\n    case 404:\n      Message(&#123;\n        message: '请求不存在！',\n        type: 'error',\n        duration: 2000\n      &#125;)\n      break\n    case 500:\n      Message(&#123;\n        message: '服务端错误！',\n        type: 'error',\n        duration: 2000\n      &#125;)\n      break\n    default:\n      Message(&#123;\n        message: '接口错误',\n        type: 'error',\n        duration: 1500\n      &#125;)\n      break\n  &#125;\n&#125;\n// 创建axios实例\n// console.log('baseURL', baseURL)\nconst instance = axios.create(&#123;\n  baseURL: 'xxxx', // 填写API baseURL\n  timeout: 1000 * 300,\n  headers: &#123;\n    'Content-Type': 'application/json'\n  &#125;,\n  cancelToken: true\n&#125;)\n/**\n * 请求拦截器\n * 1. 请求前，如果存在token则在请求头中携带token\n   2. POST请求传参加密\n   3. 添加cancelToken,处理路由切换请求cancel\n */\ninstance.interceptors.request.use(config => &#123;\n  const systemConfigModuleState = _.cloneDeep(store.state.SystemConfig)\n  config.cancelToken = new CancelToken((cancel) => &#123;\n    if (!config.noCancel) &#123;\n      systemConfigModuleState.httpCancelTokenList.push(cancel)\n    &#125;\n    store.commit('SystemConfig/setAxiosCancelTokenList', systemConfigModuleState.httpCancelTokenList)\n  &#125;)\n  // 添加 token\n  let token = store.state.token\n  config.headers.Authorization = token\n  // 检测传入集群uuid，不传入则默认使用当前集群uuid\n  if (!config.data) &#123;\n    config.data = &#123;&#125;\n  &#125;\n  if (!config.params) &#123;\n    config.params = &#123;&#125;\n  &#125;\n  switch (config.method.toUpperCase()) &#123;\n    case 'POST':\n    case 'PUT':\n    case 'PATCH':\n      if (config.method.toUpperCase() === 'POST') &#123;\n        // 对POST请求增加参数防篡改机制：\n        // 1. 通过 SHA256 > BASE64 > AES 给 请求体进行加密得出秘钥,并放置在请求头中\n        // 2. 后端拿到秘钥后再做校验, 校验正确则通过, 失败则直接报错误\n      &#125;\n      break\n  &#125;\n  return config\n&#125;,\nerror => Promise.error(error)\n)\n\n// 响应拦截器\n// 关于token机制, 超时后直接弹出确认框跳转到登录页, 无刷新token操作\ninstance.interceptors.response.use(\n  async (response) => &#123;\n\treturn Promise.resolve(response.data)\n  &#125;,\n  // 请求失败(非200)\n  error => &#123;\n    NProgress.done()\n    const &#123; response &#125; = error\n    if (response) &#123;\n      // 请求已发出，但是不在2xx的范围,直接进入统一错误处理\n      errorHandle(response.status, response.data.message)\n      return Promise.reject(response)\n    &#125; else &#123;\n      console.log('error', error.message)\n      // 处理断网的情况\n      if (!window.navigator.onLine) &#123;\n        Message(&#123;\n          message: '网络异常,请检查网络连接',\n          type: 'error',\n          duration: 2000\n        &#125;)\n      &#125; else if (error.message === 'routerCancel') &#123; // 接口取消的情况下不提示错误\n        return Promise.reject(error)\n      &#125; else &#123;\n        errorHandle(-1)\n        return Promise.reject(error)\n      &#125;\n    &#125;\n  &#125;)\n\nexport default instance\n\n// 2. API文件引用axios实例\nimport axios from './http'\nexport default &#123;\n   /**\n\t * 登录\n\t * @method managerLogin\n\t * @param &#123;String&#125; user 用户名\n\t * @param &#123;String&#125; password 用户密码\n\t * @param &#123;String&#125; tenant 租户名\n\t*/\n  login (params) &#123;\n    return axios.post('/login', params)\n  &#125;,\n&#125;\n\n// index.js 充当入口文件\nimport user from './modules/user'\nexport default &#123;\n    user\n&#125;\n\n实际使用会将所有API方法,挂载到 vue实例上, 即：\n// main.js\nimport Vue form 'vue'\nVue.prototype.$Api = Api\n\n\n\n最终使用效果:\n\n每个模块的api方法要在api/index.js文件引入后才可调用\n\n\nvue文件中使用, 因为已经挂载到vue.prototype.$Api对象上,直接 this.$Api[&#39;模块名称&#39;].函数名()即可\n\n\n非vue文件中使用, 如 store、router中的js使用, 则直接import对应的模块\n\n例: import authApi from '@/api/modules/authorization'\n引用 => auth.函数名() 即可\n\n\n\n更换新的API方式后, 可以带来以下的优点：\n\n拓展性强, 所有参数与axios文档无异, 也可以使用axios的所有功能\n可读性强, 使用方便\n适用范围广, 在vue文件和普通js文件中都可以使用封装好的axios实例\n增加路由切换, 将上一页面pengding的请求cancel, 节省流量\n\n3) 代码封装问题目前的前端项目之所以频繁出现 改了一个 bug 又出现其他 bug 的原因,除了有程序员粗心以外,我觉得还有另外几个原因：\n\n项目中单个vue文件代码过于臃肿,冗余,修改功能和修复bug十分困难,往往就是几千行代码\n\n过多使用 mixin 来进行代码封装,导致代码可读性差\n\n各组件之间高度耦合\n\n变量经常被过多依赖….\n\n\n建议:\n\n以一个文件代码不超过1k行的标准(根据实际情况而定)来规定, 超过1k行的代码,即要拆分为组件,如发现该功能存在复用的情况,则可直接封装。\n\n多使用ES6的module功能封装代码(如某些功能函数), 少使用 mixin , ES6 的 module 使用更加方便且通用.我所认为需要使用 mixin 的场景,应当是一些功能逻辑不复杂的工具方法,如表单自定义验证方法,可以使用, mixin 使用过多会导致后期维护和组件封装十分困难, 变量来源不可知、变量污染、代码可读性差的问题\n\n修改某个方法和变量时,应注意该方法是否在其他地方使用,如有,则要做兼容处理,否则容易出现,另一个使用该方法的地方出现问题\n\n少定义公共变量。\n\n\n4) 代码规范在多人协作的项目中, 制定并共同遵循同一个代码规范是非常必要的,这无论对于新成员阅读代码或是其他成员修改阅读代码都是很有帮助的,我们的JS中已经有了相应的工具是帮助我们制定规范，即 ESlint ,其中我较为推荐的是 standrd 规则\nJavaScript Standard 规则细则: https://standardjs.com/rules-zhcn.html\n这个规则也是大部分前端团队中用的比较多的规范,在我们的前端项目使用它并安装 VS code 相关插件,即可实现自动代码格式化且符合 standard 代码规范。\n\n\n\n\n\n\n\n\n\n代码命名\nJS命名是统一使用小驼峰写法,\n至于CSS的命名规范,个人是比较推崇 BEM 的命名方式的, https://juejin.im/post/5cc28ed46fb9a032086dd3d3\n剩下的HTML命名的话,则不强制\n5) 构建配置优化初始版本的webpack配置优化程度不够, 且版本是2.2.1,所以干脆对项目webpack配置做了升级:\n\n使用 webpack4\n改造项目结构, 使用vue/cli@3创建项目, 并且升级webpack版本到webpack4\n使用parallel-uglify-plugin、HappyPack 多进程编译, 加速编译时间\n增加 小于5kb的图片转为base64\n压缩图片和代码, 且删除console、debugger代码\n增加了一键部署的功能\n\n6) git commit 提交规范规则是 提交类型(修改范围): 提交内容\n提交类型用于说明 commit 的类别，只允许使用下面8个标识:\n&#39;feat&#39;, &#x2F;&#x2F; 新功能（feature）\n&#39;bugfix&#39;, &#x2F;&#x2F; bug修复\n&#39;docs&#39;, &#x2F;&#x2F; 文档更新\n&#39;UI&#39;, &#x2F;&#x2F; 只修改页面样式(不影响代码运行的变动)\n&#39;refactor&#39;,&#x2F;&#x2F; 重构（即不是新增功能，也不是修改bug的代码变动）\n&#39;common&#39;, &#x2F;&#x2F; 全局级别的修改(如公共组件或公共配置)\n&#39;build&#39;, &#x2F;&#x2F; 主要目的是修改项目构建系统(例如 webpack，rollup 的配置等)的提交\n&#39;other&#39;, &#x2F;&#x2F; 不属于以上任何类型之一\t\n\n使用commitlint此外为了规范 git commit内容提交,增加了commitlint工具拦截commit提交,\n1.全局安装 commitlintnpm install -g @commitlint/cli @commitlint/config-conventional\n2.项目单独安装npm install yorkie --save-dev\n其他配置文件已修改完成, 安装后提交不合规范的commit即会被拦截。\nPS: 本文主要是记录在公司的团队项目中, 对前端项目做的一系列优化, 希望能给你带来一些启发。\n\n参考文献\n\n\n\n\n\n\n\n\n使用webpack4提升180%编译速度\n","slug":"团队项目优化之路","date":"2020-05-09T08:51:32.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"0ea28cef92d6f8f6e9cc5aa8158bb914","title":"教你如何做一个表白神器","content":"\n初衷前段时间发现微信群里有人天天准时准点的在发咨询或者消息, 身为程序员的我一眼就发现这是机器人所为, 于是萌生了利用机器人每天向女票定时发消息的想法, 那么开始我的折腾之旅吧。\n关于微信机器人的开源项目, github一搜也是有一大堆了, 身为前端, 自然是拥抱node啦, 于是我找到了wechaty, 于是正当我满心欢喜的clone 下来，扫码登录后,却报了这个错误:\n&lt;error>&lt;ret>1203&lt;/ret>&lt;message>当前登录环境异常。为了你的帐号安全，暂时不能登录web微信。你可以通过手机客户端或者windows微信登录。&lt;/message>&lt;/error>\n\n在issues里一搜发现, 这个问题已经有很多人提过了, 而且目前没有什么解决办法, 去wx.qq.com扫码登录一下, 如果你的账号可以正常在网页版微信登录的话, 那你也不用再折腾了, 直接去github 搜下微信机器人的开源项目, 可以用这个微信每日说项目, 而我的两个账号, 都无法登录网页版微信, 那就无法使用这些依赖网页版微信的机器人项目了, 于是我又找到了 基于ipad协议版本的wechaty项目, 作者在介绍里是这样介绍的, \n\n大体的意思是通过puppet这个中间件再基于各个平台的协议(如ipad、web、mac), 就可以用wechaty控制我们的微信号了。\n话不多说, 那就开始搬砖了。\n须知：本项目必须向wechaty团队申请token, 否则该项目是无法使用的. 申请流程参考: 申请token安装过程1、安装MongoDB与Node为了让数据持久化，使用了mongodb数据库，保存所有的定时任务，所以需要本地安装好mongodb数据库，本项目mongodb端口默认27017。Node请选择大于10的版本安装\n请自行安装好git客户端，没有客户端的可以直接下载zip包\ngit clone https://github.com/Anonlyy/wechat-assistant-padplus.git // 下载zip包的忽略本步骤\n\ncd wechat-assistant-padplus\nnpm install\n\n\n2.注册天行数据账号由于本项目部分接口来自天行数据，所以需要注册自己的天行数据账号，并在wechat.config.js中的TXAPIKEY位置填写自己的key，注册地址：天行数据注册\n注： 申请完天行数据账号后, 需对应申请一些API接口, 否则本项目的某些接口是没有权限访问的图中画框的即是必须申请的接口\n3、修改配置文件根目录下存在一个wechat.config.example.js文件，请copy一份到当前目录并修改文件名为wechat.config.js或直接修改文件名为wechat.config.js，配置文件中已对各字段说明清晰，项目出现问题时，请先对照配置内容自行排查问题原因\n// 本文件是配置案例文件，请拷贝一份此文件后重命名为wechat.config.js，否则项目无法运行\nmodule.exports = &#123;\n  AUTOREPLY: false, // 是否设置机器人自动回复，默认关闭 false  开启为 true\n  DEFAULTBOT: '0', // 默认机器人 0 天行机器人 1 天行对接的图灵机器人 2 图灵机器人\n  TULINGKEY: '', //图灵机器人KEY\n  WECHATYTOKEN: '', // 必填，wechaty token\n  TXAPIKEY: '',// 必填，天行数据key，目建议申请自己的天行数据key，可以对机器人个性化定制\n  /**\n   * 每日说定时任务（支持多人）\n   * name:要发送好友的昵称 （注：不是微信号！不是微信号！不是微信号！）\n   * alias:要发送好友的备注（默认查找备注优先，防止昵称带表情特殊字符）\n   * memorialDay:你与朋友的纪念日\n   * city:朋友所在城市，写的时候不要带‘市’\n   * endWord:每日说内容的最后的落款 案例中效果为‘——————————爱你的朋友Leo_chen’\n   * date:每天定时的发送时间，案例中代表每天早上8点钟，具体规则见‘wechaty/lib/index.js’ (多个好友不要设置相同时间！不要设置相同时间！不要设置相同时间！)\n   */ \n  DAYLIST: [\n    &#123;name:'昵称',alias:'备注',memorialDay:'2015/04/18',city:'上海',endWord:'爱你的朋友Leo_chen',date:'0 0 8 * * *'&#125;,\n  ],\n\n  /**\n   * 群定时任务列表（支持多群配置）\n   * roomName: 群名\n   * sortId: 新闻资讯类别id （详情参见README.md数据字典）\n   * endword: 结尾备注 ‘————————小助手雷欧’\n   * date:每天定时的发送时间，案例中代表每天早上7点30分，具体规则见‘wechaty/lib/index.js’(多个群不要设置相同时间！不要设置相同时间！不要设置相同时间！)\n   */\n  ROOMLIST: [\n    &#123;roomName:'群名',sortId:22,endWord:'小助手雷欧',date:'0 30 7 * * *'&#125;,\n  ],\n   /**\n    * 自动添加好友关键词，留空代表同意任何好友请求 \n    */\n  ACCEPTFRIEND: [],\n  /**\n   * 好友进群通知，可配置多个\n   */\n  ROOMJOINLIST: [&#123;name:'群名',welcome:'有什么问题都可以群里提出，大家都是很热情的'&#125;],\n  /**\n   * 关键词回复列表\n   * key: 多个关键词触发相同内容，非模糊匹配，为全匹配\n   * reply: 回复内容\n   */ \n  KEYWORDLIST:[&#123;key:['你好','您好'],reply:'你好啊，我是小助手雷欧'&#125;],\n  /**\n   * 新通过好友，默认发送消息\n   */\n  NEWFRIENDREPLY: '你好，请问有什么可以帮助的',\n  /**\n   * 关键词加群配置\n   * key: 多个关键词触发相加群操作，全匹配\n   * roomName: 发送邀请的群名\n   */\n  ADDROOMKEYLIST:[\n    &#123;key:['加群'],roomName:'群名'&#125;\n  ],\n  /**\n   * 关键词触发指定事件，适用于私聊与群聊\n   * key: 关键词\n   * position: 关键词所在位置 start 开头  middle 不限 end 结尾\n   * event: 触发事件名称，更多查看事件字典\n   */\n  EVENTKEYWORDLIST:[\n    &#123;key:'?',position:'start',event:'rubbish'&#125;,\n    &#123;key:'？',position:'start',event:'rubbish'&#125;,\n    &#123;key:'是什么垃圾',position:'end',event:'rubbish'&#125;,\n    &#123;key:'名人名言',position:'middle',event:'mingyan'&#125;,\n    &#123;key:'*',position:'start',event:'star'&#125;,\n    &#123;key:'姓',position:'start',event:'xing'&#125;,\n    &#123;key:'姓',position:'end',event:'xing'&#125;,\n  ],  \n&#125;\n\n4、本地启动项目npm run koa // 执行此命令后需新开命令窗口执行以下命令\nnpm run start\n执行完成后请等待，直到出现二维码界面，拿出手机扫描确认登录即可\n5、服务器启动项目服务器部署项目时，请全局安装进程守护工具pm2,命令npm i pm2 -g。执行安装完成后\nnpm run pm2 //此操作产生的log日志在/koa/log/文件夹中，如果有报错请自行查看log是否koa未启动成功\nnpm run start //执行此操作，出现二维码，扫描登录成功后，键盘ctrl+c退出，然后执行\nnpm run pm2-wechaty // 执行日志在/wechaty/log/目录中，如果发现掉线，请重新执行npm run start后再执行此命令\n**注意: **\n两个服务都运行成功后, 就可以测试一下自己的机器人微信号会不会自动回复你的消息啦.\n如果发现无法正常使用, 可以执行pm2 logs wechaty看是否是卡在扫码阶段了, 如果是再次扫码登录即可\n\n更多问题关于wechaty的相关接口，请参考wechaty官网文档，如果以上还没有解决你的问题，请先往wechaty的项目issues中查找是否存在相同的问题，由于本项目是依赖wechaty开发，所以启动时遇到的问题大部分是wechaty的。\n事实上, 如果需要一些其他自定义功能, 也可以很方便的在项目里修改哦！\n使用效果\n\n\n注意事项 本项目属于个人兴趣开发，开源出来纯粹是为了技术交流，请勿使用此项目做违反微信规定或者其他违法事情。\n 建议使用小号进行测试。\n","slug":"教你如何做一个表白神器","date":"2020-05-09T08:49:49.000Z","categories_index":"日常","tags_index":"日常","author_index":"Xposean"},{"id":"17337bd6a857e628bf33d12d35e24870","title":"浏览器渲染与Virtual DOM相关","content":"浏览器如何渲染页面作为一名web前端码农,每天都在接触着浏览器.长此以往我们都会有疑惑,浏览器是怎么解析我们的代码然后渲染的呢？弄明白浏览器的渲染原理,对于我们日常前端开发中的性能优化有重要意义。\n所以今天我们来给大家详细说说浏览器是怎么渲染DOM的。\n浏览器渲染大致流程首先,浏览器会通过请求的 URL 进行域名解析，向服务器发起请求,接收资源（HTML、CSS、JS、Images)等等,那么之后浏览器又会进行以下解析:\n\n解析HTML文档,生成DOM Tree\n\nCSS 样式文件加载后，开始解析和构建 CSS Rule Tree\n\nJavascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作改动 DOM Tree 和 CSS Rule Tree\n\n\n而解析完以上步骤后, 浏览器会通过DOM Tree 和CSS Rule Tree来构建 Render Tree(渲染树)。\n根据渲染树来布局，以计算每个节点的几何信息。\n最后将各个节点绘制到页面上。\n1. HTML解析&lt;!DOCTYPE html>\n&lt;html>\n  &lt;head>\n    &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    &lt;link href=\"style.css\" rel=\"stylesheet\">\n    &lt;title>Critical Path&lt;/title>\n  &lt;/head>\n  &lt;body>\n    &lt;p>Hello &lt;span>web performance&lt;/span> students!&lt;/p>\n    &lt;div>&lt;img src=\"awesome-photo.jpg\">&lt;/div>\n  &lt;/body>\n&lt;/html>\n\n那么解析的DOM树大概就是以下这样\n\n2.CSS解析body &#123; font-size: 16px &#125;\np &#123; font-weight: bold &#125;\nspan &#123; color: red &#125;\np span &#123; display: none &#125;\nimg &#123; float: right &#125;\n\n\nCSS Rule Tree会比照着DOM树来对应生成,在这里需要注意的就是CSS匹配DOM的规则。很多人都以为CSS匹配DOM树的速度会很快,其实不然。\n\n\n\n\n\n\n\n\n\n样式系统从最右边的选择符开始向左侧移动来匹配一条规则。样式系统会一直向左匹配选择符直到规则匹配完毕或者由于出错停止匹配.\n这里就衍生出一个问题,为什么解析CSS的时候选择从右往左呢？\n为了匹配效率。\n所有样式规则极有可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素，所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。\n如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 HTML的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。\n可以看以下的例子：\n&lt;div>\n   &lt;div class=\"jartto\">\n      &lt;p>&lt;span> 111 &lt;/span>&lt;/p>\n      &lt;p>&lt;span> 222 &lt;/span>&lt;/p>\n      &lt;p>&lt;span> 333 &lt;/span>&lt;/p>\n      &lt;p>&lt;span class='yellow'> 444 &lt;/span>&lt;/p>\n   &lt;/div>\n&lt;/div>\n&lt;div>\n   &lt;div class=\"jartto1\">\n      &lt;p>&lt;span> 111 &lt;/span>&lt;/p>\n      &lt;p>&lt;span> 222 &lt;/span>&lt;/p>\n      &lt;p>&lt;span> 333 &lt;/span>&lt;/p>\n      &lt;p>&lt;span class='red'> 555 &lt;/span>&lt;/p>\n   &lt;/div>\n&lt;/div>\n\ndiv > div.jartto p span.yellow&#123;\n   color:yellow;\n&#125;\n\n对于上述例子，如果按从左到右的方式进行查找：1.先找到所有 div 节点；2.在 div 节点内找到所有的子 div ,并且是 class = “jartto”3.然后再依次匹配 p span.yellow 等情况；4.遇到不匹配的情况，就必须回溯到一开始搜索的 div 或者 p 节点，然后去搜索下个节点，重复这样的过程。\n试想一下，如果采用从左至右的方式读取 CSS 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。\n所以浏览器 CSS 匹配核心算法的规则是以从右向左方式匹配节点的。这样做是为了减少无效匹配次数，从而匹配快、性能更优。\nCSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，你就会在N多地方看到很多人都告诉你，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去，……\n3. 合成布局树并渲染经运行过Javascript脚本后解析出了最终的DOM Tree 和 CSS Rule Tree, 根据这两者,就能合成我们的**Render  Tree**,网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。\n为构建渲染树，浏览器大体上完成了下列工作：\n\n从 DOM 树的根节点开始遍历每个可见节点。\n某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。\n某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点—不会出现在渲染树中，—因为有一个显式规则在该节点上设置了“display: none”属性。\n\n\n对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。\n渲染可见节点，连同其内容和计算的样式。\n\n\nVirtual DOM​    大部分前端开发者对Virtual DOM这个词都很熟悉了,简单来讲，Virtual DOM就是在数据和真实 DOM 之间建立了一层缓冲层。当数据变化触发渲染后，并不直接更新到DOM上，而是先生成 Virtual DOM，与上一次渲染得到的 Virtual DOM 进行比对，在渲染得到的 Virtual DOM 上发现变化，然后将变化的地方更新到真实 DOM 上。 \n为什么说Virtual DOM快?**1）DOM结构复杂,操作很慢 **\n我们在控制台输入\nvar div = document.createElement('div')\nvar str = '' \nfor (var key in div) &#123;\n    str = str + key + \"\\n\"\n&#125;\nconsole.log(str)\n\n可以很容易发现,我们的一个空div对象,他的属性就有几百个,所以说DOM的操作慢是可以理解的。不是浏览器不想好好实现DOM，而是DOM设计得太复杂。\n2）JS计算很快\nhttps://julialang.org/benchmarks/\nJulia有一个Benchmark，Julia Benchmarks， 可以看到Javascript跟C语言很接近了，也就几倍的差距，跟Java基本也是一个量级。 这就说明，单纯的Javascript运行起来其实速度是很快的。 \n而相对于DOM,我们原生的JavaScript对象处理起来则会更快更简单.\n我们通过JavaScript,可以很容易的用JavaScript对象表示出来.\nvar olE = &#123;\n  tagName: 'ul', // 标签名\n  props: &#123; // 属性用对象存储键值对\n    id: 'ul-list',\n    class: 'list'\n  &#125;,\n  children: [ // 子节点\n    &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 1\"]&#125;,\n    &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 2\"]&#125;,\n    &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 3\"]&#125;,\n  ]\n&#125;\n\n对应的HTML写法:\n&lt;ul id='ol-list'>\n  &lt;li class='item'>Item 1&lt;/li>\n  &lt;li class='item'>Item 2&lt;/li>\n  &lt;li class='item'>Item 3&lt;/li>\n&lt;/ul>\n\n那么,既然我们可以用javascript来表示DOM，那么代表我们可以用JavaScript来构造我们的真实DOM树,当我们的DOM树需要更新了,那我们先渲染更改这个JavaScript构造的Virtual DOM树,再更新到真实DOM树上。\n 所以Virtual DOM算法就是：\n一开始先用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文\n档当中。当状态变更时，重新构造一棵新的对象树。然后用新的树和旧的树进行比较两个树的差异。\n然后把差异更新到旧的树上，最后再把整个变更写入真实 DOM。 \n简单Virtual DOM 算法实现步骤一：用JS对象模拟DOM树,并构建\n用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： \n// 创建虚拟DOM函数\nfunction Element (tagName, props, children) &#123;\n  this.tagName = tagName // 标签名\n  this.props = props // 对应属性（如ID、Class）\n  this.children = children // 子元素\n&#125;\n\nmodule.exports = function (tagName, props, children) &#123;\n  return new Element(tagName, props, children)\n&#125;\n\n实际应用如下:\nvar el = require('./element')\n// 普通ul和li对象就可以表示为这样\nvar ul = el('ul', &#123;id: 'list'&#125;, [\n  el('li', &#123;class: 'item'&#125;, ['Item 1']),\n  el('li', &#123;class: 'item'&#125;, ['Item 2']),\n  el('li', &#123;class: 'item'&#125;, ['Item 3'])\n])\n\n现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的&lt;ul&gt;元素： \n// 构建真实DOM函数\nElement.prototype.render = function () &#123;\n  var el = document.createElement(this.tagName) // 根据tagName构建\n  var props = this.props\n\n  for (var propName in props) &#123; // 设置节点的DOM属性\n    var propValue = props[propName]\n    el.setAttribute(propName, propValue)\n  &#125;\n\n  var children = this.children || []\n\n  children.forEach(function (child) &#123;\n    var childEl = (child instanceof Element)\n      ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点\n      : document.createTextNode(child) // 如果字符串，只构建文本节点\n    el.appendChild(childEl)\n  &#125;)\n\n  return el\n&#125;\n\n\n\n我们的render方法会根据tagName去构建一个真实的DOM节点,设置节点属性,再递归到子元素构建:\nvar ulRoot = ul.render() // 将js构建的dom对象传给render构建\ndocument.body.appendChild(ulRoot) // 真实的DOM对象塞入body\n\n这样我们body中就有了ul和li的DOM元素了\n&lt;body>\n    &lt;ul id='list'>\n      &lt;li class='item'>Item 1&lt;/li>\n      &lt;li class='item'>Item 2&lt;/li>\n      &lt;li class='item'>Item 3&lt;/li>\n    &lt;/ul>\n&lt;/body>\n\n\n\n步骤二：比较两棵虚拟DOM树的差异\n在这里我们假设对我们修改了某个状态或者某个数据,这就会产生新的虚拟DOM\n// 新DOM\nvar ol = el('ol', &#123;id: 'ol-list'&#125;, [\n  el('li', &#123;class: 'ol-item'&#125;, ['Item 1']),\n  el('li', &#123;class: 'ol-item'&#125;, ['Item 2']),\n  el('li', &#123;class: 'ol-item'&#125;, ['Item 3']),\n  el('li', &#123;class: 'ol-item'&#125;, ['Item 4'])\n])\n\n// 旧DOM\nvar ul = el('ul', &#123;id: 'list'&#125;, [\n  el('li', &#123;class: 'item'&#125;, ['Item 1']),\n  el('li', &#123;class: 'item'&#125;, ['Item 3']),\n  el('li', &#123;class: 'item'&#125;, ['Item 2'])\n])\n\n那么我们会和先和,刚刚上一次生成的虚拟DOM树进行比对.\n我们应该都很清楚,Virtual DOM算法的核心部分,就在比较差异这一部分,也就是所谓的 diff算法。\n因为很少出现跨层级的移动。\ndiff算法一般来说,都是同一层级比对同一层级的\n\nvar patch = &#123;\n    'REPLACE' : 0, // 替换\n    'REORDER' : 1, // 新增、删除、移动\n    'PROPS' : 2, // 属性更改\n    'TEXT' : 3 // 文本内容更改\n&#125;\n\n例如，上面的div和新的div有差异，当前的标记是0，那么：\n// 用数组存储新旧节点的不同\npatches = [\n    // 每个数组表示一个元素的差异\n    [ \n        &#123;difference&#125;, \n    \t&#123;difference&#125;\n    ],\n    [\n        &#123;difference&#125;, \n    \t&#123;difference&#125;\n    ]  \n] \n\npatches[0] = [\n  &#123;\n  \ttype: REPALCE,\n  \tnode: newNode // el('section', props, children)\n  &#125;,\n  &#123;\n  \ttype: PROPS,\n    props: &#123;\n        id: \"container\"\n    &#125;\n  &#125;,   \n  &#123;\n  \ttype: REORDER,\n      moves: [\n          &#123;index: 2, item: item, type: 1&#125;, // 保留的节点\n          &#123;index: 0, type: 0&#125;, // 该节点被删除\n          &#123;index: 1, item: item, type: 1&#125; // 保留的节点\n      ]\n  &#125;\n];\n如果是文本节点内容更改，就记录下：\npatches[2] = [&#123;\n  type: TEXT,\n  content: \"我是新修改的文本内容\"\n&#125;]\n\n// 详细算法查看diff.js https://blog.xposean.top/file/virtualDom/diff.js\n\n每种差异都会有不同的对比方式,通过比对后会将差异记录下来,应用到真实DOM上,并把最近最新的虚拟DOM树保存下来,以便下次比对使用。\n步骤三：把差异应用到真正的DOM树上\n通过比对后,我们已经知道了,差异的节点是哪些,我们可以方便对真实DOM做最小化的修改。 \n// 详情看patch.js https://blog.xposean.top/file/virtualDom/patch.js\n\n\n\n\n\n发现问题到这里我们发现一个问题,不是说 Virtual DOM更快吗? 可是最终你还是要进行DOM操作呀?那意义何在？还不如一开始我们就直接进行DOM操作来的方便。\n所以到这里我们要对Virtual DOM 有一个正确的认识\n网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？\nhttp://chrisharrington.github.io/demos/performance/\nVirtual DOM的优点:\n\n最优更改, 保证性能下限\nVirtual DOM的算法能够向你保证的就是,每一次的DOM操作我都能达到算法上的理论最优,而如果是你自己去操作DOM,这并不能保证。\n\n开发模式的更改\n为了让开发者把精力集中在操作数据，而非接管 DOM 操作。Virtual DOM能让我们在实际开发过程中,不需要去理会复杂的DOM结构,而只需理会绑定DOM结构的状态和数据即可,这从开发上来说 就是一个很大的优势。\n\n跨平台\n因为 Virtual DOM 本质上是JS的对象, 就可以比较方便的实现跨平台操作, 例如SSR、uniapp等\n\n\n","slug":"浏览器渲染与Virtual-DOM相关","date":"2019-09-05T07:41:20.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"a7be6c78ff15adee9cbf442fa41bfbf4","title":"被严重低估的target='_blank'漏洞问题","content":"\n\n\n\n\n\n\n\n\n在网页中使用链接时，如果想要让浏览器自动在新的标签页打开指定的地址，通常的做法就是在 a 标签上添加 target等于”_blank” 属性。\n\n\n\n\n\n\n\n\n\n然而，就是这个属性，为钓鱼攻击者带来了可乘之机。\nparent 与 opener在说 opener 之前，可以先聊聊 &lt;iframe&gt; 中的 parent。我们知道，在 &lt;iframe&gt; 中提供了一个用于父子页面交互的对象，叫做 window.parent，我们可以通过 window.parent 对象来从框架中的页面访问父级页面的 window。opener 与 parent 一样，只不过是用于 &lt;a target=&quot;_blank&quot;&gt; 在新标签页打开的页面的。通过&lt;a target=&quot;_blank&quot;&gt; 打开的页面，可以直接使用 window.opener 来访问来源页面的 window 对象。\n重述攻击步骤比如在当前的页面上存在一个链接：进入一个“邪恶”的网站\n当用户点击了这个链接，在新的标签页打开了这个网站。这个邪恶的网站上只要包含着类似于这样的 JavaScript 代码：\n&lt;script type='text/javascript'>\n\tif  (window.opener)  &#123;\n\t  window.opener.location.replace('https://www.baidu.com');\n\t&#125;\n&lt;/script>\n\n那么此时，用户在继续浏览这个新的标签页，而原来的网站所在的标签页此时已经被导航到了 https://www.baidu.com\n上面的攻击步骤是在跨域的情况下的，在跨域情况下，opener 对象和 parent 一样，是受到限制的，仅提供非常有限的属性访问，并且在这仅有的几个属性中，大部分也都是不允许访问的（访问会直接抛出 DOMException）。但是与 parent 不同的是，在跨域的情况下，opener 仍然可以调用 location.replace 方法而 parent 则不可以。\n这样是十分可怕的,如果有不法分子利用在论坛或是某些博客上的链接跳转到对应的钓鱼网站,而你的源网站可能已经被钓鱼网站给更改为高仿的登录页,当你关掉钓鱼网站,就会在高仿的登录页输入你的账号密码,导致账号密码泄露。\n防御措施为了安全，现代浏览器都支持在&lt;a&gt;标签的 rel 属性中指定 rel=&quot;noopener&quot;，这样，在打开的新标签页中，将无法再使用 opener 对象了，它设置为了 null。\n&lt;a href=\"https://an.evil.site\" target=\"_blank\" rel=\"noopener\">进入一个“邪恶”的网站&lt;/a>\n\nnoopener 属性看似是解决了所有问题，但是…浏览器的兼容性问题…可以看到，现在绝大多数浏览器都已经兼容了 rel=&quot;noopener&quot; 属性了。但是，为了保护稍旧的“近代”浏览器或是很旧的“古代”浏览器甚至是“远古”浏览器，只有noopener 属性还是远远不够的。\n这时，就只能请出下面这段原生 JavaScript 来帮忙了。\nfunction openUrl(url) &#123;\n  var newTab = window.open();\n  newTab.opener = null;\n  newTab.location = url;\n&#125;\n\n\n\n性能问题如果网站使用了 &lt;a target=&quot;_blank&quot;&gt;，那么新打开的标签页的性能将会影响到当前页面。此时如果新打开的页面中执行了一个非常庞大的 JavaScript 脚本，那么原始标签页也会受到影响，会出现卡顿的现象（当然不至于卡死）。而如果在链接中加入了 noopener，则此时两个标签页将会互不干扰，使得原页面的性能不会受到新页面的影响。\n","slug":"被严重低估的target-blank-漏洞问题","date":"2019-03-08T15:05:56.000Z","categories_index":"安全","tags_index":"安全","author_index":"Xposean"},{"id":"6f52155d9c00c8a7ee0e0860b268d01b","title":"来聊聊优雅的Icon","content":"前言在做前端后台项目的时候经常会用到很多 icon 图标，刚开始还好，但随着项目的不断迭代，每次修改添加图标会变得很麻烦，而且总觉得不够优雅，就开始琢磨着有啥简单方便的工作流呢？\nIcon发展史雪碧图在我刚开始实习时，大部分图标都是用 img 来实现的。渐渐发现一个页面的请求资源中图片 img 占了大部分，所以为了优化有了image sprite 就是所谓的雪碧图，就是将多个图片合成一个图片，然后利用 css 的 background-position 定位显示不同的 icon 图标。\n制作雪碧图1.photoShop手动制作后生成  这种方式是最费时费力的方式,在多数情况并不使用。\n2.通过在线网站或客户端直接生成  如GO!PNG、sprite-generator、CssGaga3.Gulp实现雪碧图自动合成  安装Gulp插件sprity并配置icon路径,会生成对应的雪碧图和css,详情可查看教程\n4.Webpack实现  配置webpack环境后,安装雪碧图依赖模块：webpack-spritesmith,并配置即可,此种方式和gulp类似\n雪碧图虽好,但这个也有一个很大的痛点，维护困难。每新增一个图标，都需要改动原始图片，还可能不小心出错影响到前面定位好的图片.于是就出现了下一种方式。\n\nIconfonticon font ，图标字体，也叫字体图标，顾名思义，就是字体做的图标。因为他是矢量图标,能够自由的变化大小，且不会模糊,其次比图片小，加载快，还能够任意改变颜色，所以越来越多的图标都开始使用 icon font\n原理每种字体在相同的字都是不一样的，比如 宋体 跟 微软雅黑 ，相同的字 ，由于调用的不同的字体，浏览器显示明显是有区别的。\n在我们还不识字的时候，每个字都是一个图案，所以老师会告诉你哪个图案念什么 ，是什么字，iconfont 同理，我认为 三角形 是 a，那对于我来说，只要是 a ，就应该是个 三角形。\n在电脑上，我给电脑规定 a 的样子是个 三角形，那么当显示 a 的时候，他就显示个三角形。\n当我把网页上的所有图标都对应一个字符的时候，你在代码里输入某个字符，那这个字符就显示你规定的形状，这就是 iconfont 图标。\n把所有的图标都放在一个字体里面，就是一个字体库了，然后按照正常字体库（本来就是正常的字体库）调用就行了。\n也就是说,我们可以理解为每一个字体就是一个矢量图标,只是现在我们这个矢量图标不是字,而是一个图案.\n此外,为了保证兼容性,所以又有.eot、.woff、.ttf、.svg四种格式的字体文件.\niconfont 三种使用方式unicode\n最开始我们使用了unicode的格式，它主要的特点是优势：\n\n兼容性最好，支持ie6+\n支持按字体的方式去动态调整图标大小，颜色等等\n\n劣势：\n\n书写不直观，语意不明确\n\n在不同的设备浏览器字体的渲染会略有差别\n\n不支持多色图标\n &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe604;&lt;/i&gt;\n\n\n\n\nfont-class\n相比它也是我们日常开发中最常用到的,相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么，但只兼容IE8+。\n&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;\n\n\n它的主要原理其实是和 unicode 一样的，它只是多做了一步，将原先&amp;#xe604这种写法换成了.icon-QQ，它在每个 class 的 before 属性中写了unicode,省去了人为写的麻烦。如 \n    .icon-QQ:before &#123; content: &quot;\\e604&quot;; &#125;\n\n相对于unicode它的修改更加的方便与直观。但也有一个大坑，之前楼主一个项目中用到了两组font-class 由于没有做好命名空间，所有的class都是放在.iconfont 命名空间下的，一上线引发了各种雪崩问题，修改了半天，所以使用font-class一定要注意命名空间的问题。\nsvg-sprite\n一个普通的SVG图标是这样的:\n&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;24px&quot; height=&quot;24px&quot; viewBox=&quot;0 0 24 24&quot;&gt; \n    &lt;path fill=&quot;#E86C60&quot; d=&quot;M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z&quot;&gt;&lt;/path&gt;\n&lt;/svg&gt;\n\n我们可以把SVG元素看成一个舞台，而symbol则是舞台上一个一个组装好的元件，这这些一个一个的元件就是我们即将使用的一个一个SVG图标。\n于是,集合了三个SVG图标的SVG元素的代码就是这样的:\n&lt;svg&gt;\n    &lt;symbol id=&quot;icon-share&quot;&gt;\n        &lt;!-- 第1个图标路径形状之类代码 --&gt;\n        &lt;path fill=&quot;#E86C60&quot; d=&quot;M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z&quot;&gt;&lt;/path&gt;\n    &lt;/symbol&gt;\n    &lt;symbol id=&quot;icon-edit&quot;&gt;\n        &lt;!-- 第2个图标路径形状之类代码 --&gt;\n        &lt;path fill=&quot;#E86C60&quot; d=&quot;M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z&quot;&gt;&lt;/path&gt;\n    &lt;/symbol&gt;\n    &lt;symbol  id=&quot;icon-top&quot;&gt;\n        &lt;!-- 第3个图标路径形状之类代码 --&gt;\n        &lt;path fill=&quot;#E86C60&quot; d=&quot;M17,0c-1.9,0-3.7,0.8-5,2.1C10.7,0.8,8.9,0,7,0C3.1,0,0,3.1,0,7c0,6.4,10.9,15.4,11.4,15.8 c0.2,0.2,0.4,0.2,0.6,0.2s0.4-0.1,0.6-0.2C13.1,22.4,24,13.4,24,7C24,3.1,20.9,0,17,0z&quot;&gt;&lt;/path&gt;\n    &lt;/symbol&gt;\n&lt;/svg&gt;\n\n但是，&lt;symbol&gt;元素不会被直接显示，大概相当于定义一个模板，然后使用&lt;use&gt;元素引用并进行渲染。\n也就是说上面的svg元素还要加上这样的一句话才能显示:\n&lt;svg&gt;&lt;use xlink:href=&quot;#icon-share&quot; /&gt;&lt;/svg&gt;\n\n\n使用方法：第一步：拷贝项目下面生成的symbol代码,该js包含了所有SVG图标：\n    &lt;script src=&quot;./iconfont.js&quot;&gt;&lt;/script&gt;\n\n第二步：加入通用css代码（引入一次就行）：\n&lt;style type=&quot;text/css&quot;&gt;\n    .icon &#123;\n       width: 1em; height: 1em;\n       vertical-align: -0.15em;\n       fill: currentColor;\n       overflow: hidden;\n    &#125;\n&lt;/style&gt;\n\n第三步：挑选相应图标并获取类名，应用于页面：\n&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;\n    &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;\n&lt;/svg&gt;\n\nSVGIcon的好处:\n\n支持多色图标了，不再受单色限制。\n支持像字体那样通过font-size,color来调整样式。\n无须像font那样引入多个字体库文件(woff|eot|ttf)\n支持 ie9+\n可利用CSS实现动画。\n减少HTTP请求。\n矢量，缩放不失真\n可以很精细的控制SVG图标的每一部分\n\n如何生成或制作SVG图标生成的方式有很多种:\n1.设计师使用AI(Adobe illustrator)的时候就可以直接生成SVG图标。2.阿里iconfont直接生成SVG，极其方便3.IcoMoon导出时可选择SVG和iconfont、PNG三种方式4.webpack的svg-sprite-loader,可将多个svg打包成SVG-sprite\n总结本文大概的讲述了一下ICON使用的发展史总的来说还是那句话，适合的才是最好的。根据自己项目的兼容性和业务场景选择自己合适的icon方式,所有方案都没有绝对的优与劣之分，适合自己业务场景，解决自己实际痛点，提高自己开发效率的方案就是好的方案。\n","slug":"来聊聊优雅的icon","date":"2019-01-24T01:31:38.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"2d7c0bd2df6d999d4495f99378b1f4d4","title":"前端性能优化之图片","content":"前端优化中图片优化必要性在我们前端优化的种种方案中,包括js、html、css文件的打包压缩合并到极致,我们节省的空间至多也就是几十K的大小,但是在图片领域能够优化的空间,往往能够达到几百k到几M的范畴,这对于一个页面而言,优化力度可是极大的.所以在前端优化中,图片的优化是至关重要的.\n图片格式认知目前在项目开发中常见的图片格式,包括有:\n\njpg\npng\ngif\nsvg\nWebP\n\njpg格式 jpg 全称叫做jpeg,.jpg和.jpeg这两种扩展名的实质是相同的，但因为DOS时代的8.3文件名命名原则是:拓展名不能超过三位,所以直接用作.jpg,虽然现在windows也可以支持任意长度的扩展名了，但大家已经习惯了.jpg的叫法，因此也就没有强制修正.\nbaseline-jpegprogressive-jpeg  jpeg优势： 非常通用，图片更小 jpeg劣势： 图片色彩不够丰富,且不支持透明.\nPNG格式 PNG,可移植网络图形格式,这种类型的图片可以展示 256 种颜色，而且每一种颜色都可以做成透明,所以这类图片我们常用来做透明和半透明的素材,缺点则是体积较大.\nGIF格式 GIF,一般都理解为gif动画,其实GIF也可以存储图片,同时也支持透明,但作为图片,GIF只支持透明和不透明,不支持半透明,而且相对于png的图片,GIF的占用空间更大,它的唯一优势在于它是支持动画,而其他格式都不支持,所以一般我们图片是不使用GIF格式,只有在用动画的情况才使用。\nsvg格式 可缩放矢量图形，属于 XML 格式，百度地图就是使用 svg 绘制的，位图当你放大时单位面积内可视的像素点会变少，所以会失真，也就是我们常说的图片模糊，首先 svg 它是一个可以进行计算矢量图，放大和缩小的时每一个像素会根据向量重新计算，不会失真，并且 svg 的体积很小。\nWebP 是 Google 于2010年提出了一种新的图片压缩格式，WebP 为网络图片提供了无损和有损压缩能力，同时在有损条件下支持透明通道；无损 WebP 相比 PNG 减少26%大小，有损 WebP 在相同的结构相似性下相比 JPEG 减少 25%~34% 的大小，所以它也同时具备 jpg 和 png 的优点。 简单来说就是,体积比jpeg更小,而且还支持透明和半透明,渲染速度更快。 但在兼容性上只支持Chrome(29+)、Opera、和Android Brower,firefox和safari都不支持. \n图片使用 说着这么多的图片类型，我们在项目开发中，如何基于性能和用户体验的权衡来选择合适的图片类型呢？\n 如果是颜色丰富的图片，jpg 是通用的选择。 如果是较通用的动画，gif 是唯一可用的选择。 如果需要清晰的显示颜色丰富和透明的图片，png 是比较好的选择。 如果是企业级应用（不考虑兼容性），可以选择 WebP。\n目前比较流行的做法压缩图片 智图: http://zhitu.isux.us/  Kraken: https://kraken.io/\nCSS Sprites(雪碧图) 场景：任何用到页面图片的场景 原理：将多个页面上用到的背景图片合并成一个大的图片在页面中引用 优势：可以有效的较少请求个数，而且，而不影响开发体验，使用构建插件可以做到对开发者透明。适用于页面图片多且丰富的场景。 劣势：生成的图片体积较大，减少请求个数同时也增加了图片大小，不合理拆分将不利于并行加载。\n使用base64编码代替图片 适用于图片大小小于2KB，页面上引用图片总数不多的情况,可以减少http请求。\niconfont、CSS3代替图片 css方式可以用来绘制相对简单的图来代替图片，一般使用before或者after伪元素来丰富图案的复杂度。 iconfont可以代替传统图片的icon. 这两种方式都是为了减少网页中图片的使用。\n响应式动态图片加载 场景：不同终端对同一个图片需求不一样，可以根据终端加载不同的图片来节省没必要的流量 原理：通过picture元素，picturefill或平台判断来为不同终端平台输出不同的图片 优势：减少没必要的图片加载，灵活控制，慢速用户加载小图片不至于加载失败，移动端没必要加载大尺寸图片等，可以通过不同方式兼容所有浏览器 劣势：无法避免图片的加载过程，图片本身没优化\n","slug":"前端性能优化之图片","date":"2018-10-27T02:11:26.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"7b6c80c82769c35e7a6f32b608c38d88","title":"JavaScript的高级运用之节流与防抖","content":"概念与目的首先还是得先来讲讲概念,节流和防抖的目的都十分的简单,就是为了性能优化而出现的,目的是为了解决一些短时间内连续执行导致性能不佳或者内存消耗巨大的情况。这类事件有:scroll keyup mousemove resize事件等，短时间内会不断的触发，在性能上消耗是非常大的，尤其是一些改变DOM结构的操作；例如我们的scroll事件,当使用触控板，滚动滚轮，或者拖拽滚动条的时候，一秒就可以触发 30 次事件。经测试，在移动设备上轻轻滚动一下，一秒可以触发 100 次之多。这么高的执行频率是我们无法忍受的。所以,在这些高频率触发的事件中,节流[throttle]与防抖[debounce]十分有必要了,它们非常相似，都是让上述这类事件在规定的事件从不断的去触发更改成为规定的时间内触发多少次；\n节流[throttle]我们的所谓节流,就是需要事件按照我们规定的时间间隔内执行,换成函数来说，使用setTimeout方法，给定两个时间，后面的时间减去前面的时间，得到时间间隔,这个时间到达我们给定的时间就去触发一次这个事件.\n来看看我们的代码,以scroll:\n/** 先给定DOM结构;**/\n&lt;div class=&quot;scroll-box&quot;&gt;\n    &lt;div class=&quot;scroll-item&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n\n/**主要看js,为了简单我用JQ去写了**/\n&lt;script&gt;\n    $(function()&#123;\n        var scrollBox = $(&#39;.scroll-box&#39;);\n        //调用throttle函数，传入相应的方法和规定的时间;\n        var thro = throttle(throFun,300);\n        //触发事件;\n        scrollBox.on(&#39;scroll&#39; , function()&#123;\n            //调用执行函数;\n            thro();\n        &#125;)\n\n        // 节流函数;    \n        function throttle(method,time)&#123;\n            var timer = null;\n            var startTime = new Date();\n            return function()&#123;\n                var context = this;\n                var endTime = new Date();\n                var resTime = endTime - startTime;\n                //判断大于等于我们给的时间采取执行函数;\n                if(resTime &gt;= time)&#123;\n                    method.call(context);//success\n                    //执行完函数之后重置初始时间，等于最后一次触发的时间\n                    startTime = endTime;\n                &#125;\n            &#125;\n        &#125;\n        //执行函数\n        function throFun()&#123;\n            console.log(&#39;success&#39;);\n        &#125;\n    &#125;)\n&lt;/script&gt;\n\n通过函数,我们其实也清晰的明白了,节流的原理,首先给给定一个间隔时间值,然后我们的节流函数就会通过比对上一次的时间和当前时间,超过或者等于这个时间才触发,反之,则不执行.以上的代码就能实现,300ms内触发一次。\n防抖[debounce]代码之前，我们先清楚一下防抖的概念，不知道大家有没有做过电脑端两边悬浮广告窗口的这么一个东西，当我们拖动滚动条的时候，两边的广告窗口会因为滚动条的拖动，而不断的尝试着去居于中间，然后你就会看到这两个窗口，不停的抖啊抖；一般这种就叫抖动了，我们要做的就是防止这种抖动，称为防抖[debounce]；比如开发技巧中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。那这里防抖思想就是当我们拖动完成之后，两边的窗口位置再重新去计算，这样，就会显得很平滑，看着很舒服了，最主要的操作DOM结构的次数就大大减少了；优化了页面性能，降低了内存消耗，不然你像IE这种比较老点版本的浏览器，说不定就直接给你蹦了用书面一点的说法就是，在某个事件没有结束之前，函数不会执行，当结束之后，我们给定延时时间，然他在给定的延时时间之后再去执行这个函数，这就是防抖函数；来看代码：\n/** 先给定DOM结构;**/\n&lt;div class=&quot;scroll-box&quot;&gt;\n    &lt;div class=&quot;scroll-item&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n\n/**主要看js,为了简单我用JQ去写了**/\n&lt;script&gt;\n    $(function()&#123;\n        var scrollBox = $(&#39;.scroll-box&#39;);\n        //调用throttle函数，传入相应的方法和规定的时间;\n        var debo = debounce(debounceFun,300);\n        //触发事件;\n        scrollBox.on(&#39;scroll&#39; , function()&#123;\n            //调用执行函数;\n            debo();\n        &#125;)\n\n        // 防抖函数;    \n        function debounce(method,time)&#123;\n            var timer = null ;\n            return function()&#123;\n                var context = this;\n                //在函数执行的时候先清除timer定时器;\n                clearTimeout(timer);\n                timer = setTimeout(function()&#123;\n                    method.call(context);  //success\n                &#125;,time);\n            &#125;\n        &#125;\n        function debounceFun()&#123;\n            console.log(&#39;success&#39;);\n        &#125;\n    &#125;)\n&lt;/script&gt;\n\n思路就是在函数执行之前，我们先清除定时器，如果函数一直执行，就会不断的去清除定时器中的方法，直到我们操作结束之后，函数才会执行；\n其实书写的方式有很多，主要还是思路的问题，大家写的多了，自然就知道了；\n","slug":"JavaScript的高级运用节流与防抖","date":"2018-05-17T01:33:34.000Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"Xposean"},{"id":"5b1e2e9ed1fe26668be4e02b12beafaf","title":"初探PWA的Service Worker","content":"\nProgressive Web App, 简称 PWA，是提升 Web App的体验的一种新方法，能给用户原生应用的体验，致力于用前沿的技术开发，让网页使用如同原生App般的体验的一系列方案。\n用来自Google Developers的解答Progressive Web Apps:\n\n渐进式 - 适用于所有现代浏览器，因为它是以渐进式增强作为宗旨开发的\n离线使用 - 借助 Service Worker 能够在离线或者网络较差的情况下正常访问\n可安装 - 用户可以添加到桌面并生成快捷方式,一键访问\n类似应用 - 由于是在 App Shell 模型基础上开发，因为应具有 Native App 的交互和导航，给用户 Native App 的体验\n持续更新 - 始终是最新的，无版本和更新问题\n安全 - 通过 HTTPS 协议提供服务，防止窥探和确保内容不被篡改\n可索引 - 应用清单文件和 Service Worker 可以让搜索引擎索引到，从而将其识别为『应用』\n粘性 - 网页已经关闭的情况下还可以通过推送后台通知等，让用户回流\n\n我们也可以通过一个DEMO看看实际效果&#x3D;&gt;lavas-demo\n而其中,PWA方案的最主要核心功能都是依赖于Service Worker这个API来实现的.\n\nService Worker是什么呢?W3C 组织早在 2014 年 5 月就提出过 Service Worker这样的一个 HTML5 API ，主要用来做持久的离线缓存。\n当然这个 API 不是凭空而来，至于其中的由来我们可以简单的捋一捋：\n浏览器中的 javaScript 都是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，我们逐渐在 js 中加了很多耗资源、耗时间的复杂运算过程，这些过程导致的性能问题在 WebApp 的复杂化过程中更加凸显出来。\nW3C 组织早早的洞察到了这些问题可能会造成的影响，这个时候有个叫Web Worker 的 API 被造出来了，这个 API 的唯一目的就是解放主线程，Web Worker 是脱离在主线程之外的，将一些复杂的耗时的活交给它干，完成后通过 postMessage 方法告诉主线程，而主线程通过 onMessage 方法得到 Web Worker 的结果反馈。\n一切问题好像是解决了，但 Web Worker 是临时(即浏览器关闭后就关闭了)的，我们能不能有一个东东是一直持久存在的，并且随时准备接受主线程的命令呢？基于这样的需求推出了最初版本的 Service Worker ，Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力.\nService Worker 有以下功能和特性：\n\n一个独立的 worker 线程，独立于当前网页进程。\n一旦被 install，就永远存在，除非被 uninstall\n需要的时候可以直接唤醒，不需要的时候自动睡眠\n可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n离线内容开发者可控\n能向客户端推送消息\n不能直接操作 DOM\n出于安全的考虑，必须在 HTTPS 环境下才能工作\n\n所以我们基本上知道了 Service Worker 的伟大使命，就是让缓存做到优雅和极致，让 Web App 相对于 Native App 的缺点更加弱化，也为开发者提供了对性能和体验的无限遐想。\nService Worker工作原理Service Worker的技术核心是Service Worker脚本，它 是一种由Javascript编写的浏览器端代理脚本。\n前端页面向内核发起注册时会将脚本地址通知内核，内核会启动独立进&#x2F;线程加载Service Worker脚本并执行Service Worker安装及激活动作。成功激活后便进入空闲等待状态，若当前的Service Worker进&#x2F;线程一直没有管辖的页面或者事件消息时会自动终止（具体的终止策略视不同浏览器及版本而定，不会影响前端编写逻辑，但前端勿在Service Worker脚本中保存需要持久化的信息，可以借助localstorage），当打开新的可管辖页面或者已管辖页面发起message等消息时，Service Worker进&#x2F;线程会被重新唤起。\n每当已安装的Service Worker有管辖页面被打开时，便会触发Service Worker脚本更新，当Service Worker脚本发生了更改，便会忽略本地网络cache的Service Worker脚本直接从网络拉取。若网络拉取的与本地有一个字节的差异都会触发Service Worker脚本的更新，更新流程与安装类似，只是在更新安装成功后不会立即进入active状态，需要等待旧版本的Service Worker进&#x2F;线程终止。\n\n实例代码// 在html里注册service-worker\nif (navigator.serviceWorker != null) &#123;\n    navigator.serviceWorker.register('sw.js')\n      .then(function(registration) &#123;\n        console.log('Registered events at scope: ', registration.scope);\n      &#125;);\n  &#125;\t\n\n// 首先定义需要缓存的路径, 以及需要缓存的静态文件的列表。\nvar cacheStorageKey = 'minimal-pwa-8'\n\nvar cacheList = [\n  '/',\n  \"index.html\",\n  \"main.css\",\n  \"e.png\",\n  \"*.png\"\n]\n\n// 借助 Service Worker, 可以在注册完成安装 Service Worker 时, 抓取资源写入缓存:\nwindow.addEventListener('install', function(e) &#123;\n  console.log('Cache event!')\n  e.waitUntil(\n    caches.open(cacheStorageKey).then(function(cache) &#123;\n      console.log('Adding to Cache:', cacheList)\n      return cache.addAll(cacheList) \n    &#125;).then(function() &#123;\n      console.log('Skip waiting!')\n      return self.skipWaiting()\n    &#125;)\n  )\n&#125;)\n\n// 网页抓取资源的过程中, 在 Service Worker 可以捕获到 fetch 事件, 可以编写代码决定如何响应资源的请求:\nwindow.addEventListener('fetch', function(e) &#123;\n  // console.log('Fetch event:', e.request.url)\n  e.respondWith(\n    caches.match(e.request).then(function(response) &#123;\n      if (response != null) &#123;\n        console.log('Using cache for:', e.request.url)\n        return response\n      &#125;\n      console.log('Fallback to fetch:', e.request.url)\n      return fetch(e.request.url)\n    &#125;)\n  )\n&#125;)\n\n\n关于事件install 事件:当前Service Worker脚本被安装时，会触发 install 事件。\npush事件:push 事件是为推送通知而准备的。不过首先你需要了解一下 Notification API 和 PUSH API。\n通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 Service Worker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。\nonline&#x2F;offline事件:当网络状态发生变化时，会触发 online 或 offline 事件。结合这两个事件，可以与 Service Worker 结合实现更好的离线使用体验，例如当网络发生改变时，替换&#x2F;隐藏需要在线状态才能使用的链接导航等。\nfetch 事件：当我们安装完Service Worker成功并进入激活状态后即运行于浏览器后台,我们的这个线程就会一直监控我们的页面应用,如果出现HTTP请求,那么就会触发fetch事件，并且给出自己的响应。这个功能是十分强大的,借助 Fetch API 和 Cache API 可以编写出复杂的策略用来区分不同类型或者页面的资源的处理方式。它能够提供更加好的用户体验:例如可以实现缓存优先、降级处理的策略逻辑：监控所有 http 请求，当请求资源已经在缓存里了，直接返回缓存里的内容；否则使用 fetch API 继续请求，如果是 图片或 css、js 资源，请求成功后将他们加入缓存中；如果是离线状态或请求出错，则降级返回预缓存的离线内容。\n\n使用看到这里很多人会有疑问了,既然可以通过service-worker缓存资源,那如果一个正式项目,在项目迭代后,并将代码推送到正式环境后,前端怎么实时知道并重新缓存新的资源呢?\n​    第一种方式,就是每次修改都手动去更改sw文件的版本号,触发更新。\n​    第二种就是使用webpack插件自动化处理\n事实上,在我们真实的用webpack生成的项目中,如果按照第一种方式手动去写Service-worker.js文件的话，会遇到两个问题:\n\nwebpack生成的资源多会生成一串hash，Service-worker.js的资源列表里面需要同步更新这些带hash的资源； \n每次更新代码，都需要通过更新service-worker文件版本号来通知客户端对所缓存的资源进行更新.\n\n看到这里就该让用webpack插件:offline-plugin 登场了,官方同时也推荐sw-precache-webpack-plugin ,offline-plugin不仅能够解决刚刚那个提到的缓存更新的问题,同时还具备以下的优点:\n\n1、自动生成和更新Service-worker.js文件和自动为SW添加缓存资源列表 \n2、更为详细的文档和例子；\n3、迭代频率相对更高，star数更多；\n4、自动处理生命周期，用户无需纠结生命周期的坑；\n5、支持自动生成manifest文件。\n\n部署到项目中也十分的简单\n1.安装npm install offline-plugin [--save-dev]\n\n2.初始化第一步，进入webpack.config.js:\n// webpack.config.js example\n\nvar OfflinePlugin = require('offline-plugin');\n\nmodule.exports = &#123;\n  // ...\n\n  plugins: [\n    // ... other plugins\n    // it's always better if OfflinePlugin is the last plugin added\n    new OfflinePlugin()\n  ]\n  // ...\n&#125;\n\n3.入口文件导入import * as OfflinePluginRuntime from 'offline-plugin/runtime';\nOfflinePluginRuntime.install();\n\n经过上面的步骤，offline-plugin已经集成到项目之中，通过webpack构建即可。 \n具体代码也可查看 demo\n\n博客中使用在博客页面中pwa的使用, 其实更加的广泛, 那么本页面实际上也是使用了pwa的, 不信? 你可以试试离线访问哦\n那么是怎么使用的呢？\n如果你的博客页面是基于jekyll或者是hexo搭建起来的, 那么直接就有现成的插件可以使用啦jekyll-pwa\nhexo-pwa\n以hexo为例:\nnpm install --save hexo-pwa\n\n在hexo项目中找到    _config.yml文件, 添加以下代码\npwa:\n  manifest:\n  #   path: &#x2F;manifest.json\n  #   body:\n  #     name: hexo\n  #     short_name: hexo\n  #     icons:\n  #       - src: &#x2F;images&#x2F;android-chrome-192x192.png\n  #         sizes: 192x192\n  #         type: image&#x2F;png\n  #       - src: &#x2F;images&#x2F;android-chrome-512x512.png\n  #         sizes: 512x512\n  #         type: image&#x2F;png\n  #     start_url: &#x2F;index.html\n  #     theme_color: &#39;#ffffff&#39;\n  #     background_color: &#39;#ffffff&#39;\n  #     display: standalone\n  serviceWorker:\n    path: &#x2F;sw.js\n    preload:\n      urls:\n        - &#x2F;\n      posts: 5\n    opts:\n      networkTimeoutSeconds: 5\n    routes:\n      # - pattern: !!js&#x2F;regexp &#x2F;hm.baidu.com&#x2F;\n      #   strategy: networkOnly\n      - pattern: !!js&#x2F;regexp &#x2F;.*\\.(js|css|jpg|jpeg|png|gif)$&#x2F;\n        strategy: cacheFirst\n      - pattern: !!js&#x2F;regexp &#x2F;\\&#x2F;&#x2F;\n        strategy: networkFirst\n  priority: 5\n\n重启服务, 再打开就可以啦！\nPWA的浏览器支持情况\n\n\n\n\n\n\n\n\n兼容性查看\n毕竟是自家产品,chrome浏览器肯定是支持度最高的浏览器,chrome64版本是基本支持所有PWA功能API的。\n但国内的浏览器·支持情况相对差一些,而且chrome移动版的使用人群还是偏少的,不过在UC的支持程度也不低\n\n\n\n","slug":"初探PWA的Service-Worker","date":"2018-04-23T01:48:25.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"87f74f29e587dfbe6578c326f4dc0a70","title":"移动设备引发的一像素边框问题","content":"熟悉移动web开发的同学一定对1像素边框问题不陌生,随着移动端web项目越来越多,要求也越来越高，好多设计师都发现了，你们前端实现的边线为什么这么粗的，根本不是1像素，好吗？一句很普通的border: 1px solid white;在PC端浏览器上会正常显示1px的边框,然而放在移动端时就不是1px的大小了，可以能是2px，也可能是1.5px等,这又是怎么回事呢？咱们继续往下看。\n原因讲原因我们得来认识几个关键词:\n设备像素比 devicePixelRatio\n\n\n\n\n\n\n\n\ndevicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。公式表示就是：devicePixelRatio(设备像素比) &#x3D; 物理像素 &#x2F; 设备独立像素(dips)\n 物理像素：  物理像素（physical pixel）又称设备像素，设备能控制显示的最小单位，我们可以把这些像素看作成真实存在显示器上一个个的点.\n 设备独立像素:  也叫设备像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用并控制的虚拟像素(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统转换为物理像素。\n物理像素与设备独立像素之间的关系在一定的条件下两者它们两者是可以相等的,比如：在PC端浏览器默认情况下（100%，即页面没被缩放），一个物理像素 &#x3D; 一个设备独立像素。而在移动端可就不一样的，因为retina视网膜分辨率,是苹果公司提出来的，可以把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度，目前大部分设备都用到了这种技术。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。也被称为视网膜显示屏。\n得出结论:\n\nPC端浏览器因为物理像素&#x3D;设备独立像素,所以一般情况下,设备像素比 devicePixelRatio等于1。\n而移动端因为为了更清晰的显示效果,使用了视网膜显示屏,所以物理像素不断地提高,但独立设备像素没有对应的提高,所以导致设备像素比 devicePixelRatio&gt;1。\n\n也就是说,以iphone8为例，其min-device-pixel-ratio的值为2，如果某元素的下边框的写法是：border: 1px solid color，即当PC端显示的是1px的下边框时，在iphone6中显示的就不是1px，而是2px;\n解决方案经过搜集,解决方案有很多种,经过推敲,有两种方案是比较灵活,适合放到项目中的.\n1.伪类 + transform 实现&lt;style&gt;\n    .scale-1px&#123;\n      position: relative;\n      border:none;\n    &#125;\n    //设备像素比为1.5\n    @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5),(min--moz-device-pixel-ratio: 2),(min-resolution: 2dppx) &#123;\n        .scale-1px:::after &#123;\n            content: &#39;&#39;;\n            position: absolute;\n              bottom: 0;\n              background: #000;\n              width: 100%;\n              height: 1px;\n              -webkit-transform: scaleY(1/1.5);\n              transform: scaleY(0.5);\n        &#125;\n    &#125;\n    //设备像素比为2\n    @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2),(min--moz-device-pixel-ratio: 2),(min-resolution: 2dppx) &#123;\n        .scale-1px:::after &#123;\n            content: &#39;&#39;;\n            position: absolute;\n              bottom: 0;\n              background: #000;\n              width: 100%;\n              height: 1px;\n              -webkit-transform: scaleY(0.5);\n              transform: scaleY(0.5);\n        &#125;\n    &#125;\n    //设备像素比为3\n    @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3),(min--moz-device-pixel-ratio: 3),(min-resolution: 3dppx) &#123;\n        .scale-1px:::after &#123;\n            content: &#39;&#39;;\n            position: absolute;\n              bottom: 0;\n              background: #000;\n              width: 100%;\n              height: 1px;\n              -webkit-transform: scaleY(1/3);\n              transform: scaleY(0.5);\n        &#125;\n    &#125;\n&lt;/style&gt;\n\n优点:\n所有场景都能满足\n支持圆角(伪类和本体类都需要加border-radius)\n\n缺点:\n对于已经使用伪类的元素(例如clearfix)，可能需要多层嵌套\n\n2.viewport + rem 实现同时通过设置对应viewport的rem基准值，这种方式就可以像以前一样轻松愉快的写1px了。\n&lt;script&gt;    \n     var viewport = document.querySelector(&quot;meta[name=viewport]&quot;);  \n    //下面是根据设备像素设置viewport\n    if (window.devicePixelRatio == 1.5) &#123;  \n       viewport.setAttribute(&#39;content&#39;, &#39;width=device-width,initial-scale=0.6666666666666667, maximum-scale=0.6666666666666667, minimum-scale=0.6666666666666667, user-scalable=no&#39;);  \n    &#125;  \n    if (window.devicePixelRatio == 2) &#123;  \n       viewport.setAttribute(&#39;content&#39;, &#39;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#39;);  \n    &#125;  \n    if (window.devicePixelRatio == 3) &#123;  \n      viewport.setAttribute(&#39;content&#39;, &#39;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&#39;);  \n    &#125;  \n    var docEl = document.documentElement;\n    var fontsize = 10 * (docEl.clientWidth / 320) + &#39;px&#39;;\n    docEl.style.fontSize = fontsize;   \n&lt;/script&gt; \n\n在devicePixelRatio &#x3D; 1.5 时，输出viewport：\n&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.6666666666666667, maximum-scale=0.6666666666666667, minimum-scale=0.6666666666666667, user-scalable=no&quot;&gt;\n\n在devicePixelRatio &#x3D; 2 时，输出viewport：\n&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;&gt;\n\n在devicePixelRatio &#x3D; 3 时，输出viewport：\n&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&quot;&gt;\n\n\n\n\n\n\n\n\n\n\n以上部分内容引用移动web 1像素边框 瞧瞧大公司是怎么做的7 种方法解决移动端 Retina 屏幕 1px 边框问题\n","slug":"移动设备引发的一像素边框问题","date":"2018-02-27T01:41:55.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"08c4771ec9e4c3675f85bffbb0600e94","title":"浅谈前后端开发中的MVVM开发模式","content":"之前在我的博客也写过关于MVVM模式的简单介绍,但不够详细,也因为对 MVVM 模式一直只是模模糊糊的认识，现在就给大家讲一下详细讲下MVVM模式为何物.\n概述MVVM 源自于经典的 Model–View–Controller（MVC）模式（期间还演化出了 Model-View-Presenter（MVP）模式，可忽略不计）。MVC模式的业务逻辑主要集中在Controller，而前端的View其实已经具备了独立处理用户事件的能力，当每个事件都流经Controller时，这层会变得十分臃肿。\nMVVM 的出现促进了 GUI 前端开发与后端业务逻辑的分离，极大地提高了前端开发效率。MVVM 的核心是 ViewModel层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：\n\nMVVM 已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。KnockoutJS 是最早实现 MVVM 模式的前端框架之一，当下流行的 MVVM 框架有 Vue，Angular 等。\nMVVM架构组成\nView 层View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Marko、Pug、Jinja2等等，各大 MVVM 框架如 KnockoutJS，Vue，Angular 等也都有自己用来构建用户界面的内置模板语言。\n\nModel 层Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。后端的处理通常会非常复杂：\n后端业务处理再复杂跟我们前端也没有半毛钱关系，只要后端保证对外接口足够简单就行了，我请求api，你把数据返出来，咱俩就这点关系，其他都扯淡。\n\nViewModel 层ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示），而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现数据驱动开发。看到了吧，View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。\n\n举一个栗子扯了这么多，并没有什么卵用。千言万语不如一个栗子来的干脆，下面用一个 Vue 实例来说明 MVVM 的具体表现。\nVue 的 View 模板：\n&lt;div id=&quot;app&quot;&gt;\n    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;\n    &lt;button @click=&quot;showMessage()&quot;&gt;Click me&lt;/button&gt;\n&lt;/div&gt;\n\nVue 的 ViewModel 层（下面是伪代码）：\nvar app = new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;     // 用于描述视图状态（有基于 Model 层数据定义的，也有纯前端定义）\n        message: &#39;Hello Vue!&#39;,  // 纯前端定义\n        server: &#123;&#125;, // 存放基于 Model 层数据的二次封装数据\n    &#125;,\n    methods: &#123;  // 用于描述视图行为（完全前端定义）\n        showMessage()&#123;\n            let vm = this;\n            alert(vm.message);\n        &#125;\n    &#125;,\n    created()&#123;\n            let vm = this;\n    \n            // Ajax 获取 Model 层的数据\n            this.$axios.get(&#39;/your/server/data/api&#39;).then(\n                result=&gt;&#123;console.log(result);&#125;\n            );\n        &#125;\n&#125;)\n \n\n在MVVM中，我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为（格式化数据由View的负责），这里可以把它理解为一个类似json的数据对象。\n&#123;\n    &quot;url&quot;: &quot;/your/server/data/api&quot;,\n    &quot;res&quot;: &#123;\n        &quot;success&quot;: true,\n        &quot;name&quot;: &quot;IoveC&quot;,\n        &quot;domain&quot;: &quot;www.cnblogs.com&quot;\n    &#125;\n&#125;\n\n这就是完整的 MVVM 编程模式。\nMVVM的优点1.低耦合视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。\n2.可重用性你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。\n3.前后端协同开发开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。\n4.容易测试界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。\n","slug":"浅谈前后端开发中的MVVM开发模式","date":"2018-01-17T02:00:21.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"406a9d044b09e92171b60ddb7efe0ee1","title":"深入研究微信小程序的wepy框架","content":"小程序现状微信小程序自发布到如今已经有半年多的时间了,凭借微信平台的强大影响力，越来越多企业加入小程序开发。 小程序于传统web页和APP比相比，有以下优势： \n\n小程序拥有更多的能力，包括定位、录音、文件、媒体、各种硬件能力等，想象空间更大 \n运行在微信内部，体验更接近APP\n在过度竞争的互联网行业中，获取一个有效APP用户的成本已经非常高了，小程序相比APP更加轻量、即用即走， 更容易获取用户\n\n小程序问题从开发角度来讲，，但同时也带来很多不便： \n1、虽然小程序官方封装了很多常用组件给开发带来很多便利性,但在自定义组件复用性上十分薄弱,仅仅支持模板片段层面的复用,业务代码与交互事件都不支持。\n2、小程序不支持SASS、LESS等预编译器,而小程序的WXSS语法在学习成本和功能性比不上我们日常开发的预编译器.\n3、小程序支持部分ES6语法,不支持ES7、ES8的新语法.\n4、在开发模式上,如果是Angular、VUE的开发者,在适应小程序的开发模式上,还需要时间适应.\nWepy框架基于小程序存在的问题,腾讯的官方团队推出了wepy框架，该框架是腾讯内部基于小程序的开发框架，设计思路基本参考VUE，开发模式和编码风格上80%以上接近VUE，开发者可以以很小的成本从VUE开发切换成小程序开发。WePY 是一款让小程序真正支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，Promise，Async、await的引入都是为了能让开发小程序项目变得更加简单，高效。\nWepy框架的优势1.新增属性,并针对原生API进行优化对现在API进行promise处理，同时修复一些现有API的缺陷，比如：wx.request并发问题等。\n// 官方\nwx.request(&#123;\n    url: &#39;xxx&#39;,\n    success: function (data) &#123;\n        console.log(data);\n    &#125;\n&#125;);\n\n// wepy 使用方式\n// request 接口从只接收Object变为可接收String\nwx.request(&#39;xxxx&#39;).then((d) =&gt; console.log(d));\n\n在同时并发10个request请求测试时：不使用wepy:\n使用wepy后：\n新增属性(vue移植)\ncomputed 计算属性\nwatcher 监听器\nprops 传值\nslot 组件内容分发插槽\n\n\n2.单文件模式使得目录结构更加清晰 小程序官方目录结构要求app必须有三个文件app.json，app.js，app.wxss，页面有4个文件 index.json，index.js，index.wxml，index.wxss。而且文件必须同名。 所以使用wepy开发前后开发目录对比如下：\n官方DEMO：\nproject\n\n├── pages\n\n|   ├── index\n\n|   |   ├── index.json  index 页面配置\n\n|   |   ├── index.js    index 页面逻辑\n\n|   |   ├── index.wxml  index 页面结构\n\n|   |   └── index.wxss  index 页面样式表\n\n|   └── log\n\n|       ├── log.json    log 页面配置\n\n|       ├── log.wxml    log 页面逻辑\n\n|       ├── log.js      log 页面结构\n\n|       └── log.wxss    log 页面样式表\n\n├── app.js              小程序逻辑\n\n├── app.json            小程序公共设置\n\n└── app.wxss            小程序公共样式表\n\n使用wepy框架后目录结构：\nproject\n\n└── src\n\n    ├── pages\n\n    |   ├── index.wpy    index 页面配置、结构、样式、逻辑\n\n    |   └── log.wpy      log 页面配置、结构、样式、逻辑\n\n    └──app.wpy           小程序配置项（全局样式配置、声明钩子等）\n\n3.真正的组件化开发 小程序虽然有 标签可以实现组件复用，但仅限于模板片段层面的复用，业务代码与交互事件 仍需在页面处理。无法实现组件化的松耦合与复用的效果.但wepy能够真正实现组件化开发,这也是使用它的最大优势之一,而且wepy在使用上更靠近vue框架的书写风格,使用起来更得心应手。\n/ index.wpy\n\n&lt;template&gt;\n    &lt;view&gt;\n        &lt;panel&gt;\n            &lt;h1 slot=&quot;title&quot;&gt;&lt;/h1&gt;\n        &lt;/panel&gt;\n        &lt;counter1 :num=&quot;myNum&quot;&gt;&lt;/counter1&gt;\n        &lt;counter2 :num.sync=&quot;syncNum&quot;&gt;&lt;/counter2&gt;\n        &lt;list :item=&quot;items&quot;&gt;&lt;/list&gt;\n    &lt;/view&gt;\n&lt;/template&gt;\n&lt;script&gt;\n\nimport wepy from &#39;wepy&#39;;\n\nimport List from &#39;../components/list&#39;;\n\nimport Panel from &#39;../components/panel&#39;;\n\nimport Counter from &#39;../components/counter&#39;;\n\n\nexport default class Index extends wepy.page &#123;\n    config = &#123;\n        &quot;navigationBarTitleText&quot;: &quot;test&quot;\n    &#125;;\n\n    components = &#123;\n        panel: Panel,\n        counter1: Counter,\n        counter2: Counter,\n        list: List\n    &#125;;\n\n    data = &#123;\n        myNum: 50,\n        syncNum: 100,\n        items: [1, 2, 3, 4]\n    &#125;\n&#125;\n\n&lt;/script&gt;\n\n组件通信与交互wepy.component基类提供三个方法$broadcast，$emit，$invoke，因此任一页面或任一组件都可以调用上述三种方法实现通信与交互，如：1.$broadcast$broadcast事件是由父组件发起，所有子组件都会收到此广播事件，除非事件被手动取消。事件广播的顺序为广度优先搜索顺序，如上图，如果Page_Index发起一个$broadcast事件，那么接收到事件的先后顺序为：A, B, C, D, E, F, G, H。如下图：\n\n2.$emit$emit与$broadcast正好相反，事件发起组件的父组件会依次接收到$emit事件，如上图，如果E发起一个$emit事件，那么接收到事件的先后顺序为：A, Page_Index。如下图：\n3.$invoke$invoke是一个组件对另一个组件的直接调用，通过传入的组件路径找到相应组件，然后再调用其方法。\n如果想在Page_Index中调用组件A的某个方法：\nthis.$invoke(&#39;ComA&#39;, &#39;someMethod&#39;, &#39;someArgs&#39;);\n\n如果想在组件A中调用组件G的某个方法：\nthis.$invoke(&#39;./../ComB/ComG&#39;, &#39;someMethod&#39;, &#39;someArgs&#39;);\n\n\n4.支持加载外部NPM包小程序较大的缺陷是不支持NPM包，导致无法直接使用大量优秀的开源内容，wepy在编译过程当中，会递归 遍历代码中的require然后将对应依赖文件从node_modules当中拷贝出来，并且修改require为相对路径， 从而实现对外部NPM包的支持。\n\n5.默认使用babel编译，支持ES6&#x2F;7的一些新特性，如promise，async&#x2F;await等等\n6.wepy支持使用LESS、SASS、Styus；\nwepy编译原理\nweby快速起步weby配备了专门的构建工具脚手架wepy-cli协助开发,帮助快速起步\n1.安装\nnpm install wepy-cli -g\n\n2.脚手架\nwepy new myproject\n\n3.切换至项目目录\ncd myproject\n\n4.实时编译\nwepy build --watch\n\nwepy作为一款优秀的微信小程序框架，可以帮我们大幅提高开发效率，在为数不多的小程序框架中一枝独秀，希望有更多的团队选择wepy。\n","slug":"深入研究微信小程序的wepy框架","date":"2017-12-30T05:24:28.000Z","categories_index":"小程序","tags_index":"小程序","author_index":"Xposean"},{"id":"4a5351e61e8e71cf89704b131251d4a8","title":"JavaScript的深拷贝与浅拷贝","content":"在掌握深浅拷贝前,我们要知道,JavaScript的变量可以分为以下两种类型：\n\n基本类型\nundefined\nnull\nnumber\nstring\nboolean\nsymbol\n\n\n\n\n\n\n\n\n\n\n\n\n基本变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。\n\n引用类型 Object、Function、Array\n\n\n\n\n\n\n\n\n\n\n存放在堆内存中的对象，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈内存中获得该对象的地址指针，然后再从堆内存中取得所需的数据。\n概念浅拷贝(shallowCopy):对于字符串类型，浅拷贝是对值的复制，对于对象来说，浅拷贝是对对象地址的复制，并不会开辟新的内存地址，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变;\n深拷贝(deepCopy):而深拷贝则是开辟新的内存地址，将原对象的各个属性逐个复制进去，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。\n深浅拷贝的实现实现浅拷贝1.Object.assignObject.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象,这也是实现浅拷贝常用的方法之一.\nlet obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;\nlet obj2 = Object.assign(&#123;&#125;, obj1);\nconsole.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;\n\n2.遍历对象属性赋值之前一直有一个错误实现深拷贝的想法，就是遍历一个对象的Key-Value对并一一复制给另一个对象便可以实现深拷贝。\n但是是错误的，这个是浅拷贝(shallowCopy)\n原因很简单，当Kry-Value对里value是Object的时候，复制过去便仍然是复制引用。\nlet obj = &#123;\n    a: 1,\n    b:&#123;\n        c: 2,\n        d: 3\n    &#125;\n&#125;\n\nlet obj2 = &#123;&#125;\n\nfor(let item of Object.keys(obj))&#123;\n    obj2[item] = obj[item]\n&#125;\n\nobj2.b.d = 2; \n\nobj.b.d // 此时obj.b.d 变成了2,所以是浅拷贝\n\n\n实现深拷贝1.JSON对象的parse和stringify(最简单的)let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;\n\nlet obj2 = JSON.parse(JSON.stringify(obj1));\n\nobj2.b.c = 3;\nconsole.log(obj2.b.c); // &#123; a: 0 , b: &#123; c: 3&#125;&#125;;\n\nconsole.log(obj1.b.c); // &#123; a: 0 , b: &#123; c: 0&#125;&#125;;\n\n该方法思路就是将一个对象转成json字符串，然后又将字符串转回对象。能够处理JSON格式能表示的所有数据类型，但是无法拷贝对象里面的函数，正则表达式等，而且会丧失所有的constructor，也就是说，将是破坏整条prototype链。\n2.JQuery的extend()我们在 jQuery 中可以通过添加一个参数来实现递归extend。调用$.extend(true, &#123;&#125;, ...)就可以实现深复制啦，参考下面的例子：\nvar x = &#123;\n    a: 1,\n    b: &#123; f: &#123; g: 1 &#125; &#125;,\n    c: [ 1, 2, 3 ]\n&#125;;\n\nvar y = $.extend(&#123;&#125;, x),          //shallow copy\n    z = $.extend(true, &#123;&#125;, x);    //deep copy\n\ny.b.f === x.b.f       // true\nz.b.f === x.b.f       // false\n\n3.Lodash的深拷贝Lodash 是一套基于JavaScript的工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前 ECMAScript 尚未制定的规范，但同时被业界所认可的辅助函数。目前每天使用 npm 安装 Lodash 的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。jQuery无法深拷贝JSON对象以外的对象,但Lodash在源代码已经兼顾到许多ES6引入的新标准对象,所以在可用性上,比其他第三方库文件反馈更好,可用性更强.\nvar objects = [&#123; &#39;a&#39;: 1 &#125;, &#123; &#39;b&#39;: 2 &#125;];\n \nvar deep = _.cloneDeep(objects);\nconsole.log(deep[0] === objects[0]);\n// =&gt; false\n\n总结\n基本类型变量存贮在栈内存区,存放在堆内存中的对象，变量保存的是一个指针。\n直接遍历对象一一复制是浅拷贝(shallowCopy)\n深拷贝即是在堆内存区拷贝出一个对象来。\n深拷贝当然更占内存，请一定要针对不同的场景做不同的拷贝处理。\n\n","slug":"深拷贝与浅拷贝","date":"2017-12-25T02:49:36.000Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"Xposean"},{"id":"82ca99d72366ad356dc36bff3d6367ca","title":"谈谈现在的移动端页面调试","content":"通常我们在日常开发手机版网页的时候，都是通过PC浏览器的移动设备模式来模拟移动设备访问网页,但总会出现以下的问题:\n开发时，在自己电脑上运行得好好的，在真机上打开就挂了，但是手机上又看不到错误的log信息；\n作为开发者，我们的诉求很简单：有没有快捷的工具可以让我们在真机运行网页的时候可以看到log信息。\n答案是肯定的。接下来就给大家介绍一下这些工具:\nvConsole由鹅厂开发的一个轻量、可拓展、针对手机网页的前端开发者调试面板。\n\n\n\n\n\n\n\n\n\n特性：\n\n使用简单\n查看 console 日志,包括报错、Objet&#x2F;Array等信息\n查看网络请求\n手动执行 JS 命令行\n自定义插件,可查看HTML、CSS、JS源码\n\n上手使用\n\n\n\n\n\n\n\n\n1.使用 npm 安装：\nnpm install vconsole\n\n\n\n\n\n\n\n\n\n\n2.直接引入:\n&lt;script src=&quot;path/to/vconsole.min.js&quot;&gt;&lt;/script&gt;\n\n\n\n\n\n\n\n\n\n\n3.初始化 &amp; 配置\n//引入后, 需要手动初始化 vConsole：\nvar vConsole = new VConsole();\n\n\n\n\n\n\n\n\n\n\n4.打印日志\nconsole.log(&#39;foo&#39;);   // 白底黑字\nconsole.info(&#39;bar&#39;);  // 白底紫字\nconsole.debug(&#39;oh&#39;);  // 白底黄字\nconsole.warn(&#39;foo&#39;);  // 黄底黄字\nconsole.error(&#39;bar&#39;); // 红底红字\n\n\n\n\n\n\n\n\n\n\n5.打印Object&#x2F;Array\nvar obj = &#123;&#125;;\nobj.foo = &#39;bar&#39;;\nconsole.log(obj);\n/*\nObject\n&#123;\n  foo: &quot;bar&quot;\n&#125;\n */\n\n使用vConsole可以很方便的log我们想要的信息,只是需要引入一个库文件,而且不支持代码断点,以及不支持查看元素的样式是写在css第几行，也不支持显示在哪个文件，于是还有一种更加好的方案.\n\nChrome远程调试(Remote Debugging)Chrome浏览器是可以通过USB连接移动设备进行远程Web页面调试的,上图的左边是pc端的chrome浏览器，右边是手机上的Chrome 然后可以看到当鼠标移动到某个div上时 手机上的这个区域高亮显示 跟pc上调试某段代码效果一样 你可以修改代码 并直接在手机上反馈修改结果\n准备在移动调试前我们需要以下准备工作:\n\npc端安装最新的chrome\n(Android设备)手机端安装最新的chrome \nUSB连接线\n\n步骤USB设置 在你的手机里打开”设置”-&gt;”开发人员工具”-&gt;”USB调试” 打开USB调试。 因为Android手机型号众多 很多人找不到”USB调试这个选项在哪” 而且大多数手机”开发者选项”默认是影藏的，你需要看下自己的手机说明然后将手机调到”开发者模式” 就可以找到 “USB调试了” \n假设你已经将手机设置为”USB调试”打开的状态 将手机连接到电脑 手机会弹出是否链接 点击确定,并安装好驱动,这是关键.\n\n打开电脑的chrome 在地址栏输入 chrome://inspect  选中 Discover USB devices 可以检测到你的设备 \n\n在移动设备上打开chrome,并访问要调试的网址\n点击inspect 如下图 就看到了文章开始一样的效果 此时就是可以审查手机页面上的元素了\n使用Chrome远程调试的方式可以更加全面的调试代码和审查元素,但有不好的地方就是只支持安卓设备,目前是不支持IOS苹果设备的.不过这个也不是问题,IOS 的话，可以使用iphone 数据线链接 Mac，打开 Safari 就可以直接使用 Mac 的 Safari 调试工具了,跟chrome的方法类似。\n调试iOS上的Safari\n在iOS设备上打开允许调试：设置→Safari→高级→打开”web检查器“\n在MAC上打开Safari的开发菜单：顶部菜单栏“Safari”→偏好设置→高级→打开”在菜单栏中显示“开发”菜单\n在iOS设备上的Safari浏览器中打开要调试的页面，然后切换到MAC的Safari，在顶部菜单栏选择“开发”→找到你的iOS设备名称→右边二级菜单选择需要调试的对应标签页，即可开始远程调试\n\n如果没有iOS设备，也可以在Xcode中模拟一台，点击顶部“Xcode”→“Open Developer Tool”→“iOS Simulator”即可打开一个iOS设备的模拟器，并且模拟器里面Safari打开的页面，也是能通过上个步骤中MAC上的Safari调试。\nUC浏览器开发版同时UC也提供了真机调试的版本http://www.uc.cn/business/developer/\n","slug":"谈谈现在的移动端页面调试","date":"2017-12-19T03:21:26.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"656b08fb883cb37221ecfb23b5e18094","title":"前端包管理器的发展","content":"前言我们在开发时，会用到很多开发者写的第三方库。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到一个包管理器的平台上，如果要使用，直接通过包管理器安装就可以直接用，不用管代码存在哪，应该从哪下载。\n因此使用包管理器主要基于以下几个原因：\n\n方便的寻找和下载你需要的依赖库，并将它们整合到项目中，例如jQuery,Angular等。\n方便的下载指定版本的依赖库（免除去网络上搜索和下载）\n解决第三方库之间的依赖关系\n\nBower由twitter推出的包管理工具。基于nodejs的模块化思想,把功能分散到各个模块中，让模块和模块之间存在联系,通过 Bower 来管理模块间的这种联系。它的特点是对包结构没有强制规范，即依赖扁平。\n但Bower本身不存储模块文件本身，也不保存模块的版本信息。模块的发布者通过注册（register）的方式，将模块的可访问的公开的git地址记录在bower的数据库中。而所有的版本都是通过模块发布者自己控制代码库的tag来决定。\nBower在安装流程基本上可以简单认为是将注册的git地址中的特定tag clone一份到你本地的bower_components 目录中。\nBower本身也存在很多问题,也是导致频临淘汰的原因:\n\n数据源的问题,Bower 直接取 github 而缺少像 npm 那样的 registry，导致一个问题，github上放的是源码，和部署所需是不同的，这导致使用上的问题，对于开发者而言,还需要专门开个分支整理出一个适合使用者的源码.\n缺乏构建工具\n源数据问题\n\n\nNPMnpm(node package manager)有两层含义。一层含义是Node的开放式模块登记平台和管理系统，网址为npmjs.org。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。\nnpm不需要单独安装。在安装Node的时候，会连带一起安装npm。同时也是目前开发者中使用率最高的包管理器但是，Node附带的npm可能不是最新版本，最好用下面的命令，更新到最新版本。\nNPM较之Bower,具有一个独立的服务器网站用来存放开发者的库文件,且在处理库与库之间的依赖关系上更强.\nCNPM因为npm的服务器是在国外,所以被墙是经常的,这是就要介绍一下比较良心的cnpm了.CNPM即是淘宝镜像源,这是一个完整  npmjs.org 镜像，用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。\n使用cnpm后,install的速度可比cnpm快得多了。\n\nYarnfacebook发布的新一代包管理工具，旨在解决以往使用npm作为包管理会遇到的一些问题。从其官方介绍可以看到其重点强调的3个点：快、可靠、安全。\nyarn的优势相比于Node的亲儿子npm来说，yarn有以下优势:\n1、安装模块速度更快\n2、支持离线模式(只要你安装过此模块，第二次安装就会从缓存文件中直接复制过来)yarn会有一个缓存目录，会缓存以前安装过的软件包，再次安装时就不必从网络下载了，大大加速安装速度。这一点很重要，npm 饱受诟病的一点就是，每次安装依赖，都需要从网络下载一大堆东西，而且是全部重新下载，工程多的时候比较烦人。\n3、依赖关系确定性.在每一台机器上针对同一个工程安装依赖时，生成的依赖关系顺序和版本是一致的。之前 npm 在这里有一个处理得不好的地方 。举例来说，我写的工程依赖 A, B, C 三个库，我在编写 package.json 的时候，给 A, B, C 都指定了版本号。但是 A 库可能又依赖 D, E, F 库，D 库又依赖 G, H 库。这么多关联依赖关系中，很可能某个库在指定依赖时，没有指定版本号。于是，这就导致了一个问题。如果我在另一台机器上对同样的工程安装依赖，或者把这台机器工程下的 node_modules 目录删除来重新安装依赖。由于关联依赖中，没有指定版本号的库，发生了版本更新，就会导致再次安装的依赖，其中具体某些软件包的版本是不一致的。在这种情况下，你会发现原来能够正常运行的程序，忽然变得不能工作或一堆 BUG.\n而yarn在解析package.json文件时，会对其每个依赖包进行遍历分析生成yarn.lock文件。该文件描述了项目中每个包以及每个包中所依赖的包的版本信息。\n4.迁移方便目前npm的项目迁移至yarn,基本是无痛迁移,可以很方便的就切换.\n\nyarn &amp; npm 常用命令比较\nnpm install &#x3D;&#x3D;&#x3D; yarn &#x2F; yarn install\nnpm install xxx —save &#x3D;&#x3D;&#x3D; yarn add xxx\nnpm uninstall xxx —save &#x3D;&#x3D;&#x3D; yarn remove xxx\nnpm install xxx —save-dev &#x3D;&#x3D;&#x3D; yarn add xxx —dev\nnpm update &#x3D;&#x3D;&#x3D; yarn upgrade\nnpm install xxx -g &#x3D;&#x3D;&#x3D; yarn global add xxx当然，在比较选择yarn与npm时，速度也是一个很重要的衡量指标。\n\n\nYarn总结yarn 相比 npm 最直观优势就是快目前项目在基本可以无痛迁移使用。yarn 目前并不是非常稳定，不少反馈script run以及下载包有问题。lock功能具有双面性，是否锁定版本需要看具体情况而定\n","slug":"前端包管理器的发展","date":"2017-12-08T03:53:43.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"a62ea6a9ff7b388523bd21c04a242050","title":"MPA和SPA,你选哪一个","content":"背景旧的桌面应用程序被Web应用程序推到了极点。基于Web的应用程序使用起来非常方便，可以从多个设备访问，并且易于升级。对移动友好的复杂应用程序的需求正在上升。熟悉Web应用程序开发的您必须了解两种主要的Web设计类型：单页应用程序（SPA）和多页面应用程序（MPA）。\n多页面应用程序(MultiPage Application，MPA)MPA的工作遵循传统模式，即每次更改都会重新提交，或者从服务器显示为新的页面。鉴于这些应用程序的性质，它们的大小以适应其功能。内容的巨大增加给应用程序提供了多层UI的复杂性。侵入的复杂性是在21世纪初引入的AJAX（异步JavaScript和XML），这使得仅仅刷新网站的一部分而不是重新提交整个页面成为可能。尽管它极大地改善了用户体验，但却为页面增添了一层复杂性。与SPA的直接方法相比，MPA的发展是复杂的。\nMPA的优点\nMPA方法最适合那些设计为视觉地图的网站。多级菜单导航是传统MPA的核心。\n开发成本和学习门槛较低,易于上手。\nSEO搜索引擎优化管理是有效的，因为不同的关键字可以优化每个应用程序的一个关键字。\n\nMPA的弱点\nMPA资源不共用，每个页面都需要加载,这就意味着大部分页面的部分代码和资源都是重复加载的.\n用户体验较差,多页面切换会造成整页刷新,加载缓慢,流畅度也不足,且无法实现转场动画。\n传统前后端开发模式,非前后端分离,导致不够高效。\n\n单页应用程序(SinglePage Web Application，SPA)\n简单点说,SPA就是只有一个Web页面的应用，单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。\n怎么实现无刷新的呢?那就是History API.History API是HTML5 的历史记录 API。这套 API 提供一种「人为操纵」浏览器历史记录的方法,可以实现无刷新更改地址栏链接，配合 AJAX 可以做到无刷新跳转。简单来说：假设当前页面为xposean.xin&#x2F;，那么执行下面的 JavaScript 语句：\nwindow.history.pushState(null, null, &quot;/profile/&quot;);\n\n之后，地址栏的地址就会变成xposean.xin&#x2F;profile&#x2F;，但同时浏览器不会刷新页面，甚至不会检测目标页面是否存在。\npushState方法浏览器历史记录可以看作一个「栈」。栈是一种后进先出的结构，可以把它想象成一摞盘子，用户每点开一个新网页，都会在上面加一个新盘子，叫「入栈」。用户每次点击「后退」按钮都会取走最上面的那个盘子，叫做「出栈」。而每次浏览器显示的自然是最顶端的盘子的内容。\n执行pushState函数之后，会往浏览器的历史记录中添加一条新记录，同时改变地址栏的地址内容。它可以接收三个参数，按顺序分别为：\n\n一个对象或者字符串，用于描述新记录的一些特性。这个参数会被一并添加到历史记录中，以供以后使用。这个参数是开发者根据自己的需要自由给出的。\n\n一个字符串，代表新页面的标题。当前基本上所有浏览器都会忽略这个参数。\n\n一个字符串，代表新页面的相对地址。\n var state = &#123;\n     id: 2,\n     name: &quot;profile&quot;\n &#125;;\n window.history.pushState(state, &quot;My Profile&quot;, &quot;/profile/&quot;);\n\n\n\nreplaceState 方法有时，你希望不添加一个新记录，而是替换当前的记录（比如对网站的 loading-page），则可以使用replaceState方法。这个方法和pushState的参数完全一样。\nSPA的优点\n分离前后端关注点，前端负责view，后端负责model，各司其职； \n服务器只接口提供数据，不用展示逻辑和页面合成，提高性能； \n同一套后端程序代码，不用修改兼容Web界面、手机； \n用户体验好、快，内容的改变不需要重新加载整个页面 \n可以缓存较多数据，减少服务器压力 \n单页应用像网络一样，几乎随处可以访问—不像大多数的桌面应用，用户可以通过任务网络连接和适当的浏览器访问单页应用。如今，这一名单包括智能手机、平板电脑、电视、笔记本电脑和台式计算机。\n\nSPA的缺点：\nSEO问题\n首次加载时间较长。 \n页面复杂度提高很多，复杂逻辑难度成倍,意味着开发成本和学习成本的提高。\n\n感谢本文部分内容出处为MPA OR SPA? WHICH ONE SHOULD YOU CHOOSE?\n","slug":"MPA和SPA-你选哪一个","date":"2017-11-23T00:57:12.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"12871e3c295dd1902181cbe44daad752","title":"表格布局display:table的妙用","content":"今天给大家讲一下,CSS2提供的一个布局,display:table;,虽然在CSS3提供了两个全新的布局,Flex和Grid布局,但却存在这样或那样的兼容性问题,其次我们有时候因为table的语义化和SEO问题,不想使用table标签,却需要实现table标签的表格布局,就能用到CSS2提供的这个属性.\n接下来看看关于table的display可选值：\n\ntable：指定对象作为块元素级的表格，相当于html标签&lt;table&gt;\ninline-table：指定对象作为内联元素级的表格，相当于html标签&lt;table&gt;\ntable-caption：指定对象作为表格标题，相当于html标签&lt;caption&gt;\ntable-cell：指定对象作为表格单元格，相当于html标签&lt;td&gt;\ntable-row：指定对象作为表格行，相当于html标签&lt;tr&gt;\ntable-row-group：指定对象作为表格行组，相当于html标签&lt;tbody&gt;\ntable-column：指定对象作为表格列，相当于html标签&lt;col&gt;\ntable-column-group：指定对象作为表格列组显示，相当于html标签&lt;colgroup&gt;\ntable-header-group：指定对象作为表格标题组，相当于html标签&lt;thead&gt;\ntable-footer-group：指定对象作为表格脚注组，相当于html标签&lt;tfoot&gt;\n\n还有一些协助属性：\n\nborder-collpase：用来决定表格的边框是分开的还是合并的。在分隔模式下，相邻的单元格都拥有独立的边框。在合并模式下，相邻单元格共享边框。\nborder-spacing： 规定相邻单元格边框之间的距离（只适用于 边框分离模式 ）。相当于 HTML 中的 cellspacing 属性，但是第二个可选的值可以用来设置不同于水平间距的垂直间距。\ntable-layout：定义了用于布局表格单元格，行和列的算法。(auto：表格及单元格的宽度取决于其包含的内容。fixed：表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。)\nvertical-align：用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。\n\n使用display:table的好处除了在兼容性更好和语义化程度更强之外,表格布局也继承了table标签的布局优势;\n更简单的栅格布局&lt;style>\n  .box&#123;\n    border:1px solid #dedede;\n    display:table;\n    height: 300px;\n    width: 100%;\n  &#125;  \n  .box .item&#123;\n    border-right:1px solid #ccc;\n    display:table-cell;\n  &#125;\n&lt;/style>\n&lt;body>\n  &lt;div class=\"box\">\n    &lt;div class=\"item\">AA&lt;/div>\n    &lt;div class=\"item\">BB&lt;/div>\n    &lt;div class=\"item\">CC&lt;/div>\n  &lt;/div>\n&lt;/body>\n\n很轻松的就能够实现,一行多列的布局,而且自动根据.item元素个数计算.item的宽度,比原来通过浮动并设置百分比方便多了.\n","slug":"表格布局display-table的妙用","date":"2017-11-12T11:29:49.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Xposean"},{"id":"85f7e5e03854074d222564e95ebbd6c6","title":"详解CSS中的函数","content":"首先我们很好奇,css这一门都不能算的上是正常的编程语言,竟然还有函数这一回事,其实是有的,只是我们因为日常很少用到,所以一直没有听闻罢了。\ncalc()calc()从字面我们可以把他理解为一个函数function。其实calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，用于动态计算长度值。通常會用來做數值的運算，尤其是針對於長寬等等，而他最特別的是運算的數值”不需要”相同單位.\ncalc()语法calc()语法非常简单，就像我们小时候学加 （+）、减（-）、乘（*）、除（&#x2F;）一样，使用数学表达式来表示：\nwidth: calc(四则运算);\n\ncalc()的运算规则calc()使用通用的数学运算规则，但是也提供更智能的功能：\n使用“+”、“-”、“” 和 “&#x2F;”四则运算；可以使用百分比、px、em、rem等单位；可以混合使用各种单位进行计算；表达式中有“+”和“-”时，其前后必须要有空格，如”width: calc(12%+5em)”这种没有空格的写法是错误的；表达式中有“”和“&#x2F;”时，其前后可以没有空格，但建议留有空格。\n例子&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;utf-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;\n  &lt;title&gt;JS Bin&lt;/title&gt;\n&lt;/head&gt;\n  &lt;style&gt;\n   .box&#123;\n    width: 100%;\n    height: 500px;\n    background-color:red;\n    border:1px solid blue;\n  &#125;\n\n  .box-child&#123;\n    width: calc(100% - 100px);\n    height: calc(100% - 200px);\n    background-color:yellow;\n    border:1px solid #eee;\n  &#125;\n  &lt;/style&gt;\n&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;\n    box\n    &lt;div class=&quot;box-child&quot;&gt;box-child&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n从效果我们可以看出,calc()可以动态计算我们的宽度,而且运算的时候數值”不需要”相同單位.\n此外我们的居中方式也多了一种,通过calc()的话:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;utf-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;\n  &lt;title&gt;JS Bin&lt;/title&gt;\n&lt;/head&gt;\n  &lt;style&gt;\n    #box&#123;\n      width: 200px;\n      height: 200px;\n      background-color:#eee;\n      position:absolute;\n      top:calc(50% - 100px);\n      left: calc(50% - 100px);\n    &#125;\n  &lt;/style&gt;\n&lt;body&gt;\n  &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nattr()attr() 函数返回选择元素的属性值。content属性和attr函数,在我们实际开发过程还是十分有用的,就是用来动态生成文本内容并展示在页面上,制作纯CSS的Tooltip;\nattr()的日常使用下面让我们看看 attr 和 content 如何相互配合产生神奇效果的    \ndiv[data-line]:after &#123; \n    content:attr(data-title);\n    display:block;\n    font-size:12px;\n    margin-top: 10px;\n&#125;\n\n在页面就会直接展示attr这段文字了,然后我们通过JavaScript改变data-title的值,就能够动态改变文字的显示了。十分简单.不需要用JavaScript里拼装字符串,CSS3里就能完成这些，是不是感觉CSS3可以部分的替代Javascript了！attr的动态生成页面内容的能力着实是一件让人兴奋的事情。你实际上可以用它配合content对页面的很多其他元素和属性进行操作。\nlinear-gradient()linear-gradient() 函数用于创建一个线性渐变的 “图像”。以往我们做渐变效果,只能通过图片来实现,但现在有了linear-gradient(),我们就能通过它来制作想要的渐变背景了。为了创建一个线性渐变，你需要设置一个起始点和一个方向（指定为一个角度）的渐变效果。你还要定义终止色。终止色就是你想让Gecko去平滑的过渡，并且你必须指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。\nlinear-gradient()语法background: linear-gradient(direction, color-stop1, color-stop2, ...);\n\ndirection是指用角度值指定渐变的方向（或角度）。 to left：设置渐变为从右到左。相当于: 270deg to right：设置渐变从左到右。相当于: 90deg to top：设置渐变从下到上。相当于: 0deg to bottom：设置渐变从上到下。相当于: 180deg。这是默认值，等同于留空不写。 xxxdeg:设置渐变角度。color-stop1、color-stop2....用于指定渐变的起止颜色,颜色数量不限制,即可以制作大于两种颜色以上的渐变背景。\n因为很简单,所以就不多介绍了,详细可看MDN\n\n","slug":"详解CSS中的函数","date":"2017-11-05T14:29:54.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Xposean"},{"id":"345a3c40621a9fce5c40a188b50f83cc","title":"CSS盒模型详解","content":"在整理收集前端面试题的时候,经常有关于CSS盒模型的问题,属于经典问题了。很多博客里讲得也很模糊不清，于是，我在这里重新整理一下。\n概念可以认为每个html标签都是一个方块，然后这个方块又包着几个小方块，如同盒子一层层的包裹着，这就是所谓的盒模型。其实就是我们平常F12检查元素的时候页面表示出来的这个图片。\n\n从上图即可知,正常的一个盒子的内容包括:\n\nmargin\nborder\npadding\ncontent四部分组成。\n\n分类和区别那盒模型是分为 IE盒模型 和 W3C标准盒模型。\n区别是?\nW3C 标准盒模型：\n\n属性width,height只包含内容content，不包含border和padding。\n\nIE 盒模型：\n\n属性width,height包含border和padding，指的是content+padding+border。\n意思是什么呢?就是如果是W3C 标准盒模型,那么我们的宽度和高度就不包括边框和内边距了,即这种模型下,我们如果已经设置了宽高度,那么即便改变了border和padding的大小,也不会改变整个元素的宽高。\n日常开发注意事项在我们日常的CSS开发中,默认浏览器渲染的时候都是 W3C 标准盒模型.在这种盒模型下,我们的日常开发会遇到什么问题呢？假设我们设定了一个div元素\n.box&#123;\n    width:200px;\n    height:200px;\n    background-color:pink;\n&#125;\n\n这个时候我们检查.box元素,没有意外,高宽都是200px.那接着我们继续添加CSS元素,\n.box&#123;\n    width:200px;\n    height:200px;\n    background-color:pink;\n    padding:20px;\n    border:10px solid black;\n&#125;    \n\n这个时候我们再检查元素,高宽就变成了 200+20+20+10+10&#x3D;260 了。说明padding和border会把整个盒子撑高撑大。那这种情况给我们的开发者就造成一种困扰,我已经设置高宽是200px的情况下,就是不想要有其他属性再去影响它了.而且如果我们是一行多个元素百分比布局的情况下,一旦给单个元素添加了padding或border元素的话,就会影响单个元素宽度,”一行”变成”两行”,极不美观.\n于是,我们CSS3添加了一个属性:box-sizing,他的默认属性值就是content-box(即 W3C 标准盒模型),那么当我们的把属性值设置为border-box(IE盒模型)之后,以上出现的问题就迎刃而解了。\n因为在这种模型下,我们盒子的宽高度是包括padding和border的,即便我们给某个元素设置了padding或border值,也不会变动元素的宽高度,也不会撑大撑高元素。\n所以在日常CSS开发过程中,在设置全局css中(如bootstrap),我们都会给所有元素添加一个属性就是:\nbox-sizing:border-box;\n\n","slug":"CSS盒模型详解","date":"2017-11-05T04:38:19.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Xposean"},{"id":"5060dfe35a7d053a870cb97f4dd7d628","title":"jQuery的插件机制","content":"jQuery框架现况分析和概述虽然jQuery的市场占有率正逐年下滑,但不可避免的,jQuery仍是目前前端领域里使用率最高的前端框架,仍旧需要深入学习它,利用它更方便的写出优秀的前端代码。\n\n先来回顾一下,jQuery的优秀之处:\n\n强大的DOM选择器\n可靠的事件处理器\n完善的Ajax函数\n链式操作\n出色的浏览器兼容性\n强大的插件支持\n\n而本篇文章主要讲解的就是jQuery框架强大的插件系统支持,且听我慢慢道来.\njQuery的插件系统概述首先编写插件的目的很明确,就是为了能够让代码的复用性更强,提高可维护性和开发效率。\n那首先,jquery的插件主要分为三种类型:\n封装对象方法的插件这种是将对象方法封装起来,用于对通过选择器获得JQuery对象进行操作,也是最常用的插件类型。\n简单的举例就是我们在jQuery用的addClass()、parent()此类的方法都是属于这种类型的插件。\n封装全局函数的插件可以将独立的函数(方法)加到JQuey命名空间下.例如&#96;&#96;中的$.Ajax()和$.trim()这种就属于jquery编写的作为全局函数使用的插件。\n选择器插件这个就很好理解了,虽然我们的JQuery的选择器非常的强大且丰富,但仍不是尽善尽美的,仍然有时候需要扩展一些我们自定义的选择器。\n注意事项:为了防止我们内部编写的变量影响到全局空间,我们在编写插件的时候必须通过一段代码来包裹我们的编写的代码体。\n;(function($)&#123;\n    /* 放置我们的插件代码,并且可以通过$来作为JQuery的缩写别名*/\n&#125;)(JQuery);\n\n这样的话,我们写的插件里的变量不会污染到全局空间,而且我们在代码中还能继续使用过$来作为JQuery的缩写别名.\nJQuery的插件机制简单介绍了jQuery插件以及其类型,我们再来讲讲jQuery的插件机制,jQuery是用什么来创建我们的插件的呢？\njQuery提供了两个用于扩展JQuery功能的方法,即jQuery.fn.extend()和jQuery.extend()方法。\njQuery.fn.extend()用来扩展我们前面提到的第一种类型的插件,\njQuery.extend()用来扩展第二和第三类型的插件。\n这两个方法都接受一个Object类型的参数。\n编写jQuery插件封装JQuery对象方法的插件在这里我们要编写一个能够设置对象颜色的插件。\n&lt;!DOCTYPE html>\n&lt;html>\n  &lt;head>\n    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    &lt;script class=\"jquer\" src=\"/js/sandbox/jquery/jquery-1.8.2.min.js\" type=\"text/javascript\">&lt;/script>\n    &lt;title>演示代码&lt;/title>\n  &lt;/head>\n&lt;body>\n    &lt;div class='content'>hello&lt;/div>\n  &lt;/body>\n&lt;/html>\n&lt;script>\n;(function($)&#123;\n  jQuery.fn.extend(&#123;\n    \"color\":function(value)&#123;\n      return this.css('color',value);\n    &#125;\n  &#125;)\n&#125;)(jQuery);\n\n$(function()&#123;\n  $('.content').color('red');\n&#125;);\n&lt;/script>\n在这段代码中,我们通过$.fn.extend()就能够封装一个JQ对象的插件函数了。\n通过$(&#39;xxx&#39;).color(&#39;color&#39;),我们就能直接给DOM元素设置颜色了,极其方便好用。\n封装全局函数的插件同样的我们可以编写一个能够清除去除左侧空格的插件函数。\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n  &lt;meta charset=\"utf-8\">\n  &lt;meta name=\"viewport\" content=\"width=device-width\">\n  &lt;title>JS Bin&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;script src=\"https://code.jquery.com/jquery-2.2.4.js\">&lt;/script>\n  &lt;div class=\"content1\">\n    \n  &lt;/div>\n&lt;/body>\n&lt;/html>\n&lt;script>\n;(function($)&#123;\n    $.extend(&#123;\n        ltrim:function(text)&#123;\n            return (text||\"\").replace(/^\\s+/g,\"\");\n        &#125;\n    &#125;);\n&#125;)(jQuery);\n$(function()&#123;\n    var str = \"           2222\";\n    alert($.ltrim(str));\n&#125;);\n&lt;/script>\n\n在这段代码里,我们定义了一个全局函数的插件,来实现去除字符串左侧空格的功能,通过$.extend()设置后,我们就可以直接通过$.ltrim(xxx)来设置了。\n封装自定义选择器首先,我们以自带的选择器例子来做介绍:\n$(\"div:gt(1)\")\n这个例子中,选择器会首先找到所有div的元素,再遍历这些元素,然后将这些元素和”1″和下标一起传入gt选择器对应的选择器函数中。根据函数里编写的代码,如若返回true,则该元素会保留,反之,该元素就会被忽略。\n而例子中的gt选择器函数转化成自定义的选择器函数是这样的:\nfunction(a,i,m)&#123;\n  return i>m[3]-0;\n&#125;\n\n第一个参数a:指的是当前遍历的DOM元素;\n第二个参数i:指的是当前遍历的DOM元素的索引值,从0开始;\n第三个参数m:他是由JQuery解析出来的一个数组.\n介绍完这些,接下来我们来自己编写一个自定义的选择器:\n创建一个根据你传入的字符串等于DOM元素文本内容的选择器:\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n  &lt;meta charset=\"utf-8\">\n  &lt;meta name=\"viewport\" content=\"width=device-width\">\n  &lt;title>JS Bin&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;script src=\"https://code.jquery.com/jquery-2.2.4.js\">&lt;/script>\n  &lt;p>111&lt;/p>\n  &lt;p>222&lt;/p>\n  &lt;p>333&lt;/p>\n  &lt;p>444&lt;/p>\n  &lt;p>555&lt;/p>\n  &lt;p>666&lt;/p>\n  &lt;p>777&lt;/p>\n&lt;/body>\n&lt;/html>\n&lt;script>\n;(function($)&#123;\n  $.extend($.expr[\":\"],&#123;\n    \"equal\": function(a,i,m)&#123;\n      return $(a).text()==m[3];\n    &#125;\n  &#125;);\n&#125;)(jQuery);\n$(function()&#123;\n  $('p:equal(111)').css('color',\"red\");\n&#125;);\n&lt;/script>\n\n该选择器会根据传入的字符找到字符相等的元素。\n因为选择器函数是属于调用十分频繁的函数,所以在编写的时候,一定要秉承优化再优化的原则,不能草草了事。\n总结以上就是jQuery的插件系统,利用好插件,可以给我们的开发工作带来十分大的效率提升。\n","slug":"jQuery的插件机制","date":"2017-10-24T08:05:52.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"0253ce7d41971055efd7d65777100cee","title":"移动web适配方案简述","content":"众所周知,目前移动设备的访问量早已超越PC端设备,这就意味着用户使用移动设备访问页面的行为越发频繁,这就给web前端开发人员带来了一系列的苦恼,如何才能在不同大小的设备上呈现同样的网页？这是每一个移动web开发者的都会发出的疑问.接下来,本文将讲述自适应网页设计的概念和方法，使网页开发人员维护同一个网页代码，即可使网站在多种设备上具有更好的阅读体验。\n\n\n\n\n\n\n\n\n\n本文详细介绍了网页全适配的实现方法，希望能给迷惑的你带来帮助。\n先说说方案目前主流的方案有两个,响应式以及自适应的解决方案,除此之外也有其他的方案,但在这主要只讲这两者.自适应:在移动端设备上浏览，网页与PC端无大的差别，原网页的布局在任何设备上都可以保持一致，不会因为屏幕窄宽大小而会影响视觉效果（不会被遮挡）和响应效果。响应式:在手机等设备上浏览，网页与PC端内容相似，但布局是自动改变为专为手机等其他设备所准备的。\n自适应方案\n\n\n拉勾网和简书网的页面就属于是自适应方案,这种页面有以下特别:\n1.文字流式;\n2.控件弹性\n3.图片等比缩放\n4.顶部或底部的的bar无论宽度怎么变,高度和位置不变.\n但自适应布局更多用在页面元素相对没那么复杂的网站,如果是比较复杂的网站,并不推荐使用这个布局,简单的说，图片为主内容的可以用自适应布局,例如花瓣网这种.\n\n响应式布局目前一般常见的实现响应式有两种方法，一种是利用媒体查询，另外一种利用JS计算屏幕宽度做出响应.\n但从性能和易用程度上,推荐使用媒体查询,媒体查询可以针对不同的屏幕尺寸设置不同的样式,对于响应式布局的页面,非常有用.\nbootstrap的 栅格布局 就是根据这种原理实现的。\n当页面宽度大于1200px:\n\n当页面宽度大于900px并且小于1200px:\n\n当页面宽度小于900px:\n\n但这种布局,会存在一个问题,那就是元素字体、间距、宽高等属性的属性值不会随着屏幕的宽度进行放大或缩小,这个时候,就得动态改变我们的css单位了.\nem相对单位em的特点 : 1. em的值并不是固定的; 2.em始终会继承父级元素的字体大小。\n但因为em在易用性上不强,且父级元素继承关系容易紊乱,所以又推出了rem单位.\nrem相对单位rem也是相对单位,但它是基于根元素(也就是html标签)做相对大小,这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应.\nJs动态设置rem来实现移动端字体的自适应原理就是:利用Js获取设备屏幕的宽度，并根据屏幕的宽度动态改变根元素html的font-size属性的作用。\n总结如果在不考虑人力成本和时间成本的话,只考虑页面效果,首推PC端和移动端各自两套页面布局,这样方案是最合适;甚至可以移动端自适应布局,pc端响应式布局.\n以及百度、淘宝、知乎,这些大型的网站都是这样,主要还是因为考虑到业务等各方面的原因.\n因为虽然响应式和自适应能够达到我们的效果,但在细节之处总是不够尽如人意,同时在页面布局上是固定几个模板的,不能更加的别出心栽和创意.\n","slug":"移动web适配方案简述","date":"2017-10-24T07:47:35.000Z","categories_index":"前端","tags_index":"前端","author_index":"Xposean"},{"id":"06a1c23ef60fb42dc35a87810987448c","title":"来聊聊localStorage、sessionStorage和cookie","content":"首先当然还得是来介绍一下基本概念.\n基本概念Cookie对于Cookie,不用介绍的太多,想必大家也都很熟悉了.Cookie实际上是一小段的文本信息,每个Cookie的大小限制为4KB.\n它的主要用途有保存登录信息，比如你登录某个网站市场可以看到浏览器提醒你需要“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\nweb StoragesessionStorage 和 localStorage 是HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。\n在这之前,客户端存储数据都是使用cookie,但是大家都知道,每一次HTTP请求,都会带着cookie给后端,即使是不需要传输的情况下,这在无形之中就增加带宽的浪费,而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n三者的异同\n通过上图的表,大概总结一下webstorage API的好处:1.** 减少网络流量：一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。2. 快速显示数据：性能好，从本地读数据比通过网络从服务器获得数据快得多，本地数据可以即时获得。再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。3. 临时存储**：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便。4. 更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，使得数据操作更为简便。\nWebstorage API的简单使用//创建localStorage对象\nvar localstroage = window.localStorage;  \n//存储值\nlocalstroage.setItem(&#39;name&#39;,&#39;Jack&#39;);  \nlocalstroage.setItem(&#39;uid&#39;,&#39;10001&#39;);  \n//获取值\nvar openid = localstroage.getItem(&#39;openid&#39;);  \nconsole.log(openid);\n//删除值\nlocalstroage.removeItem(&#39;openid&#39;);  \n//清空值\nlocalstroage.clear(); \n\n而sessionStorage的使用则与localStorage完全一致.\n此外,HTML5在提供了storage事件,当键值改变或者clear的时候，就可以触发storage事件,相当于加了个监听事件,这也是cookie原生没有的.\n应用场景和总结我们的Storage API,可以用在IM聊天记录,购物车,HTML5的游戏数据存储,内容多的表单.并非说有了localStorage、sessionStorage,cookie就会被淘汰了,就目前的客户端(浏览器)使用而言,cookie的使用率仍然是非常高的,只是在某种特定的情况下呢,使用我们的webStorageAPI会更加方便好用,更快的解决问题.\n此外,我们的webStorageAPI也仍存在一些局限,一个是兼容性问题,是不支持IE8以下的,还有一个是如果用户使用的是浏览器的隐身模式的话,是无法访问用localStorage存储下来的值的。\n","slug":"来聊聊localStorage、sessionStorage和cookie","date":"2017-10-24T07:27:14.000Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"Xposean"},{"id":"a4b264498977972b162e90cae20a3771","title":"PostCSS入门","content":"概述我想你应该已经听说过PostCSS,它比libsass快了几乎两倍(并且比Ruby Sass快了28倍)； 或者听说过它支持cssnext和自动添加私有前缀而且可扩展功能,难道你一点都不好奇吗？\nPostCSS最强大之处在于它是模块化并且基于插件的架构，不过这也是个缺点。如果你之前在项目中使用Sass(比如大多数的设计师和前端开发者)，你从不需要配置任何东西——Sass内置了全部实用功能，开箱即用。 然而，PostCSS需要你做一些配置。你不得不从一眼看不到底的插件列表选择插件并且自己把全部插件一起配置。但这同时意味着它的自定义程度高,足够实现你想要的。\n现状PostCSS在以惊人的速度发展，而且越来越受人欢迎。越来越多的人开始在了解它，使用它。因为他们意识到，在项目中使用PostCSS让他们意识到了眼前一亮。\n\n2014年总共不到140万的下载量，但从2015年1月份到6月份已经超过380万个下载。\n**Autoprefixer**是PostCSS中最流行的插件，其中Google、Shopify、Twitter、Bootstrap和Codepen都在使用这个插件。Wordpress也使用Autoprefixer插件，而且还使用RTLCSS插件。Alibaba使用了几个PostCSS插件，以及也参加PostCSS的开发。\n运行PostCSS运行PostCSS的方法有很多种。你可以很容易地将它添加到Gulp、webpack的构建过程中；或者是通过最简单的方式,即postcss-cli来构建都是OK的,但因为我是习惯使用gulp,所以接下来介绍的是通过gulp配置,如果想使用其他方式构建，请自行度娘或google。\n在已经安装了gulp的配置环境下,我们直接开始进行postCSS的配置.\n开始配置首先在你的项目中创建两个文件夹，一个命名为src，另一个命名为dest。src文件夹用来放置未处理的CSS文件，而dest用来放置PostCSS插件处理后的文件。\n接下来需要做的就是在你的项目中安装gulp-postcss插件，安装好之后就可以使用PostCSS处理器。\n打开你的命令终端(CMD)，并且进入到你的项目根目录下，然后在命令终端输入下面的命令：\nnpm install --save-dev gulp-postcss\n\n安装完成后你的项目结构看起来就应该像这样：\n现在通过编辑器打开gulpfile.js文件，并且创建gulp和gulp-postcss变量，如下面代码所示：\nvar gulp = require(&#39;gulp&#39;); \nvar postcss = require(&#39;gulp-postcss&#39;);\n\n那我们现在可以设置一个任务，让PostCSS读取CSS原文件并且处理它。\n添加的代码如下：\ngulp.task(&#39;css&#39;, function () &#123;\n  var processors = [ ];\n  return gulp.src(&#39;./src/*.css&#39;).pipe(postcss(processors)).pipe(gulp.dest(&#39;./dest&#39;)); \n&#125;);\n\n我们一起来看一下上面的代码。在第一行，设置了一个任务名叫css。这个任务将会执行一个函数，同时在这个函数中创建了一个名为processors的数组。现在这个数组为空，这里将插入我们想使用的PostCSS插件。在processors数组后面，我们指定了需要处理的目标文件，即src目录中的任何CSS文件。\n这里面使用了两个.pipe()函数，设置postcss()执行PostCSS，并且给postcss()传递processors参数，后面会告诉PostCSS要使用哪个插件。\n接下来的第二个.pipe()函数，指定结过PostCSS处理后的CSS放置在dest文件夹中。\n添加PostCSS插件假设,现在我们添加需要的PostCSS插件：Autoprefixer(处理浏览器私有前缀)著作权归作者所有。运行下面的命令，将插件安装到你的项目:\nnpm install autoprefixer --save-dev\n\n接下来，在我们的项目中定义变量，将这些插件加载到我们的项目中。和前面的方式一样，在gulpfile.js文件中添加下面的代码：\n var autoprefixer = require(&#39;autoprefixer&#39;);\n\n然后将这个插件添加到processors数组中，更新后的数组如下：\nvar processors = [ autoprefixer];\n\n插件已经添加到了processors数组中了，这个时候PostCSS会知道将这些插件功能应用到我们的CSS源文件中。\n测试编译在src目录中创建一个测试文件style.css，并在这个文件中添加一些CSS的测试代码：\n /* Testing autoprefixer */ \n.autoprefixer &#123; display: flex; &#125;\n\n在命令终端执行gulp css命令。在dest目录生成的文件会有下面的代码：\n/* Testing autoprefixer */ \n.autoprefixer &#123; \n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex; \n&#125;\n\n如上面编译出来的代码你应该看到了Autoprefixer给需要的属性添加了浏览器的私有前缀，编译符合需求的代码。\n设置插件选项注：每一个插件都有对应的配置参数选项，如果你想为一个插件配置选项参数，你可以在gulpfile.js文件中,在插件后面添加一对括号，并在里面传递选项的参数。例如，Autoprefixer需要指定对应的浏览器列表参数，你可以像这样设置：\n var processors = [ \n     autoprefixer(&#123;browsers: [&#39;last 1 version&#39;]&#125;)\n ];\n\n总结\n通过npm(或cnpm)创建项目，并且将gulp安装到gulpfile文件\n安装gulp-postcss插件\n设置你的gulpfile.js文件，将gulp和gulp-postcss加载到项目中\n创建一个任务，来编译你的CSS\n在任务中，设置一个processors数组\n在.pipe()设置一个postcss()函数，并且将processors传递给它\n\n你可以根据上面的教程介绍，遵循相同的步骤，你可以将PostCSS任何插件安装到项目中。\n通过npm install &lt;plugin_name&gt; –save-dev 命令将插件安装到你的项目中类似var autoprefixer = require(&quot;autoprefixer&quot;)代码在你的gulpfile.js文件中定义要加载的插件变量名将变量名添加到你的preprocessors数组中\n","slug":"PostCSS入门","date":"2017-10-24T06:25:07.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Xposean"}]