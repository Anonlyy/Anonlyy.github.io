---
title: 一文带你知晓HTTP/2
date: 2020-12-22 10:41:40
tags: 网络
categories: 网络
feature: true
cover: https://image.xposean.top/blogImage/0016.png

---

## 前言

作为一个经常跟`web` 打交道的程序员，了解HTTP协议是必须的, 通过本文, 希望能够让你了解到一些关于HTTP协议和HTTP/2的基本概念和优劣势,如有不对的地方请指出。

## HTTP协议

`HTTP`的全称是超文本传输协议 (`HyperText Transfer Protocol`) ,伴随着计算机网络和浏览器的诞生，`HTTP1.0` 也随之而来，处于计算机网络中的应用层，`HTTP` 是建立在 `TCP` 协议之上，所以 `HTTP `协议的瓶颈及其优化技巧都是基于` TCP` 协议本身的特性，**例如 `TCP`建立连接的 3 次握手和断开连接的 4 次挥手以及每次建立连接带来的 RTT 延迟时间。**

> RTT(Round-Trip Time)，往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。

早在 HTTP 建立之初，主要就是为了将超文本标记语言 (HTML) 文档从 Web 服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的 HTML 页面将要放在我们的 web 服务器上，用户端通过浏览器访问 url 地址来获取网页的显示内容，但是到了 `WEB2.0` 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 `CSS`，`Javascript`，来丰富我们的页面展示，当 `ajax` 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化。 



## HTTP/1.x 介绍

`HTTP1.0`最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而`HTTP1.1`则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时`HTTP1.1`也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

- 缓存处理，在`HTTP1.0`中主要使用header里的`If-Modified-Since`,`Expires`来做为缓存判断的标准，`HTTP1.1`则引入了更多的缓存控制策略例如`E-Tag`，`If-Unmodified-Since`, `If-Match`, `If-None-Match`等更多可供选择的缓存头来控制缓存策略。

- 带宽优化及网络连接的使用，`HTTP1.0`中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，`HTTP1.1`则在请求头引入了`range`头域，它允许只请求资源的某个部分，即返回码是`206（Partial Content）`，这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- 错误通知的管理，在`HTTP1.1`中新增了24个错误状态响应码，如`409（Conflict）`表示请求的资源与资源的当前状态发生冲突；`410（Gone）`表示服务器上的某个资源被永久性的删除。
  Host头处理，在`HTTP1.0`中认为每台服务器都绑定一个唯一的`IP`地址，因此，请求消息中的`URL`并没有传递主机名（`hostname`）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（`Multi-homed Web Servers`），并且它们共享一个`IP`地址。`HTTP1.1`的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（`400 Bad Request`）。

- **长连接**，`HTTP 1.1`支持长连接（`PersistentConnection`）和请求的流水线（`Pipelining`）处理，在一个TCP连接上可以传送多个`HTTP`请求和响应，减少了建立和关闭连接的消耗和延迟，在`HTTP1.1`中默认开启`Connection： keep-alive`，一定程度上弥补了`HTTP1.0`每次请求都要创建连接的缺点。

  

### HTTP/1.x 的缺陷

虽然 `HTTP/1.1`对比`HTTP/1.0`强大了许多, 但仍存在诸多缺陷：

- **连接无法复用**：连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。
  - HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。
  - HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。
- **Head-Of-Line Blocking（HOLB）**：即队头阻塞, 导致带宽无法被充分利用，以及后续健康请求被阻塞。[HOLB](http://stackoverflow.com/questions/25221954/spdy-head-of-line-blocking)是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB（队头阻塞）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。
  - HTTP 1.0：下个请求必须在前一个请求返回后才能发出，`request-response`对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。
  - HTTP 1.1：尝试使用 `pipeling` 来解决，即浏览器可以一次性发出多个请求（同个域名，同一条 TCP 链接）。但 `pipeling` 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，`pipeling` 只部分解决了 `HOLB`的情况。

![](https://image.xposean.top/20210113114727.png)

如上图所示，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间。

- **协议开销大**： `HTTP1.1` 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。
- **安全因素**：`HTTP1.1` 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性

因为 `HTTP/1.1` 的问题，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到 2009 年，谷歌公开了自行研发的 `SPDY`协议，主要解决 `HTTP/1.1` 效率不高的问题。谷歌推出 `SPDY`，才算是正式改造 `HTTP` 协议本身。降低延迟，压缩 `header` 等等，`SPDY` 的实践证明了这些优化的效果，也最终带来 `HTTP/2` 的诞生。

`SPDY` 协议在 `Chrome` 浏览器上证明可行以后，就被当作 `HTTP/2` 的基础，主要特性都在 `HTTP/2` 之中得到继承。

## HTTP/2

2015 年初，`IESG` 审阅了新的` HTTP/2` 标准并批准发布。

### 为什么不是 HTTP/1.2？

为了实现 HTTP 工作组设定的性能目标，HTTP/2 引入了一个新的二进制分帧层，该层无法与之前的` HTTP/1.x `服务器和客户端向后兼容，因此协议的主版本提升到 `HTTP/2`。

即便如此，除非您在实现网络服务器（或自定义客户端），需要使用原始的 TCP 套接字，否则您很可能注意不到任何区别：所有新的低级分帧由客户端和服务器为您执行。 可观察到的唯一区别将是性能的提升和请求优先级、流控制与服务器推送等新功能的出现。

需要注意的是，HTTP/2 仍是对之前 `HTTP` 标准的扩展，而非替代。 `HTTP `的应用语义不变，提供的功能不变，`HTTP` 方法、状态代码、`URI` 和标头字段等这些核心概念也不变。 这些方面的变化都不在` HTTP/2` 考虑之列。 

---

那下面咱们来说说HTTP/2的新特性

### **1. 二进制传输**

`HTTP/2` 所有性能增强的核心在于新的**二进制分帧层**，它定义了如何封装 `HTTP` 消息并在客户端与服务器之间传输.新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。 为了说明这个过程，我们需要了解 `HTTP/2` 的三个概念：

- *数据流*：已建立的连接内的双向字节流，可以承载一条或多条消息。
- *消息*：与逻辑请求或响应消息对应的完整的一系列帧。
- *帧*：`HTTP/2` 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。

这些概念的关系总结如下：

- 所有通信都在一个 `TCP` 连接上完成，此连接可以承载任意数量的双向数据流。
- 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。
- 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。
- 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

![](D:\Download\2019-03-06-2.png)

`HTTP/2`中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。

了解了二进制传输的概念, 咱们才能明白`HTTP/2`的下一个重要特性**多路复用**的原理, 因为多路复用的实现正是基于二进制传输。

### 2. 多路复用

在 `HTTP/2` 中引入了多路复用的技术。**多路复用**很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟因为在`TCP`的"慢启动"机制下, 每新开一个 TCP 连接都需要慢慢提升传输速度。

通过访问 [HTTP/1与HTTP/2性能对比](https://http2.akamai.com/demo) 可以明显的看出性能上的区别

![](https://image.xposean.top/20210113143024.png)



在 `HTTP/2 `中，有了二进制分帧之后，`HTTP /2 `不再依赖 TCP 链接去实现多流并行了，在 `HTTP/2` 中：

- 同域名下所有通信都在单个连接上完成。
- 单个连接可以承载任意数量的双向数据流。
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。



通俗一点来说，`TCP`连接相当于两根管道（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，传输是有序的，每个字节都是一个一个来传输。

例如客户端要向服务器发送`Hello`、`World`两个单词，只能是先发送`Hello`再发送`World`，没办法同时发送这两个单词。不然服务器收到的可能就是`HWeolrllod`（注意是穿插着发过去了，但是顺序还是不会乱）。这样服务器处理就会出现问题了。

接上面的问题，能否同时发送`Hello`和`World`两个单词呢？在`HTTP/2`中就能，可以将消息数据拆成帧，给每个帧打上标签(帧首部的流标识)。发的时候是这样的①H ②W ①e ②o ①l ②r ①l ②l ①o ②d。这样到了服务器，服务器根据标签()把两个单词区分开来。实际的发送效果如下图：

![](https://image.xposean.top/20210113144541.png)

这一特性，使得传输性能有了极大提升：

- 同个域名只需要占用一个 `TCP`连接，使用一个连接并行发送多个请求和响应,消除了因多个 `TCP` 连接而带来的延时和内存消耗。
- 并行交错地发送多个请求，请求之间互不影响。
- 并行交错地发送多个响应，响应之间互不干扰。
- 消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。
- 不必再为绕过` HTTP/1.x` 请求限制而做很多工作（例如级联文件、image sprites 和域名分片等）



总结下来, 多路复用技术：利用单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；由于减少TCP 慢启动时间，提高传输的速度

### 3.**Header 压缩**

为什么要压缩？在 `HTTP/1.x` 中，`HTTP` 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成。一般而言，消息主体都会经过` Gzip` 压缩，或者本身传输的就是压缩过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接以纯文本传输。

随着 `Web` 功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输 `UserAgent`、`Cookie` 这类不会频繁变动的内容，可能每次都需要重复传输几百到几千的字节, 造成浪费。

为了减少这块的资源消耗并提升性能， `HTTP/2` 对这些首部采取了压缩策略：

- `HTTP/2 `在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；
- 首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
- 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值

例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销.

![](https://image.xposean.top/20210113145839.png)

### 4 .服务器推送

`HTTP/2` 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源（如下图所示），而无需客户端明确地请求。

![](https://image.xposean.top/20210113150150.png)

为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。

事实上，如果您在网页中内联过 CSS、JavaScript，或者通过数据 URI 内联过其他资产，那么您就已经亲身体验过服务器推送了。 对于将资源手动内联到文档中的过程，我们实际上是在将资源推送给客户端，而不是等待客户端请求。 使用 HTTP/2，我们不仅可以实现相同结果，还会获得其他性能优势。 推送资源可以进行以下处理：

- 由客户端缓存
- 在不同页面之间重用
- 与其他资源一起复用
- 由服务器设定优先级
- 被客户端拒绝

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 `RST_STREAM` 帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行, 更多详情可参阅[服务器推送](https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81)

那么以上就是`HTTP/2`的所有新特性了, 其实以上的特性同时也是`HTTP/1.x`中存在的缺陷, 同时需要注意的是, 在`HTTP/2`中, 我们的日常用的 优化手段, 例如图片`Base64`、雪碧图、多域名等手段也不再适用了。

## 拓展

虽然 `HTTP/2` 提高了网页的性能，但是并不代表它已经是完美的了，`HTTP/3` 就是为了解决 `HTTP/2` 所存在的一些问题而被推出来的.

`HTTP/2`还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。

上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 `HTTP/2` 的表现情况反倒不如 `HTTP/1` 了。

因为在出现丢包的情况下，整个 `TCP` 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 `HTTP/1.1` 来说，可以开启多个` TCP` 连接，出现这种情况反倒只会影响其中一个连接，剩余的` TCP `连接还可以正常传输数据。

那么可能就会有人考虑到去修改 `TCP` 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实, 这就是所谓的[协议僵化](https://http3-explained.haxx.se/zh/why-quic/why-ossification)

基于这个原因，**Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上**，HTTP/3 之前名为 `HTTP-over-QUIC`，从这个名字中我们也可以发现，`HTTP/3` 最大的改造就是使用了 `QUIC`。

`QUIC` 虽然基于 `UDP`，但是在原本的基础上新增了很多功能, 使得`QUIC` 能够用`UDP `来实现高速度，同时又不会牺牲 `TLS `的安全性。

2018 年，`QUIC` 演变成为 `HTTP3`。互联网工程任务组（Internet Engineerring Task Force）的那帮制定互联网协议的哥们同意了这个提案。这是个好消息，因为对于我们这些急躁的人们来说，互联网的速度永远都不够快。

更多关于HTTP/3的内容, 可以阅读[http3-explained](https://http3-explained.haxx.se/zh)



>  参考文章
>
> [[一文读懂 HTTP/2 及 HTTP/3 特性](https://blog.fundebug.com/2019/03/07/understand-http2-and-http3/)]
>
> [[HTTP/3 explained](https://http3-explained.haxx.se/zh)]
>
> [[谈谈HTTP1.0,HTTP1.1和HTTP2.0区别](https://segmentfault.com/a/1190000016496448)]

