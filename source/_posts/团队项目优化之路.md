---
title: 团队项目优化之路
date: 2020-05-09 16:51:32
tags: 前端
categories: 前端
cover: https://image.xposean.top/blogImage/0014.png

---
### 背景

公司的前端项目是基于`Vue`技术栈为核心的前端项目,不得不说, 我花了接近将近一个多星期, 才对它有一定的了解, 在不包含引入库和依赖的情况下, 接近 `43.3M`, `src`文件下的`.vue`文件 接近700个, 这么大的项目, 可是让我疑惑的点是, 在优化的方面, 却有很多不足之处。

![image-20200519145742791](https://image.xposean.top/20200519150208.png)

**项目中存在的问题：**

1. 使用 `vuex`, 但不使用 `vuex` 的组件化通信,只是将 `vuex` 作为一个存储全局变量的作用,事实上 `vuex` 还有很多功能可以用到,例如 `action` 等,此外 `vuex` 没有分模块管理,只使用一个 `store.js` ,在项目功能越发复杂的情况,会导致该文件越发的庞大且难以维护
1. 样式集中于一个 `style` 文件,文件庞大难以维护,且极其容易出现样式污染的情况
1. `elementUI` 的主题修改, `elementUI` 官方提供修改主题色的方式,使用现有的样式替换方式会导致一些组件样式使用上很奇怪
1. `API`方法使用问题,第一个问题是内部封装的方法是用 `mixin` 去引入的,这就导致了只有在 `vue` 文件中才能使用,在一些特定的场景下无法使用,如路由钩子和一些自定义方法,其次是在使用某个请求方法的时候,代码可读性很差。
1. 开发代码无规范, 预计使用 `eslint(standard)` 、`js`命名使用小驼峰
1. `git commit`提交无规范, 随意提交
1. 构建代码时间过长,且 `webpack` 配置有待优化
1. 组件封装和代码风格问题
1. 前端权限路由系统



以上问题, 在目前最新的项目中已基本完成修复, 这过程其实算是比较漫长的, 因为还要兼顾需求的开发和`bug`修复, 以及个别改动较大, 需要考虑时机进行整改, 例如代码规范这一项, 改动的范围就很大.

那么以下就根据一个个修复点进行详解:



### 1) `Vuex` 的使用

文档首页: https://vuex.vuejs.org/zh/

> `Vuex` 是一个专为 `Vue.js` 应用程序开发的 状态管理模式 。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

对于中大型项目而言, `Vuex`的使用是十分有必要性的, 项目一庞大, 势必带来层级关系复杂, 变量繁多的情况, 这个使用`vuex`能够较大程度的解决一些变量传值和统一管理的问题。

在 `Vuex` 有几个核心概念,分别是 `state` , `action` , `mutation` , `Module` , `Getter` ,而我们的项目中只用到了 `state` 和 `mutation` ,此外因为项目既然已经使用了 `vuex` , 很多地方还是会出现, 一个变量传三四层组件的情况。

项目中的 `vuex` 应分功能模块管理,尽量不耦合关联,项目成员只改动自己功能所属的` Vuex` 模块代码, 这样, 多层嵌套的组件、兄弟组件间的状态会更好管理维护, 而且对开发者来说，如果你的项目足够复杂，团队的规模也不仅是一个人，那么数据集中处理更利于程序的稳定和维护。

理想中的 `Vuex` 文件夹结构


``` 
└── store
   ├── index.js          # 我们组装模块并导出 store 的地方
   ├── actions.js        # 根级别的 action
   ├── mutations.js      # 根级别的 mutation
   ├── getters.js      # 根级别的 getters
   └── modules
       ├── network  # 网络模块
            └── actions.js   # 网络模块的 action
            └── getters.js   # 网络模块的 getters          
            └── mutations.js   # 网络模块的 mutation      
            └── index.js   # 导出网络模块文件    
       ├── user  # 用户模块
            └── actions.js   # 用户模块的 action
            └── getters.js   # 用户模块的 getters          
            └── mutations.js   # 用户模块的 mutation      
            └── index.js   # 导出用户模块文件    
       ....
```

而每次需要修改增加 `store` 的功能,则可以去对应的功能模块文件夹下新增或修改即可



### 2) `API`的调用方式

项目中 `API` 原来的调用方式是使用 `Mixin` 混入全局来进行使用的,这种方案问题很大。



先来说缺陷:
1. 使用局限性,我们都知道`mixin`是只有在`vue`文件中才有的功能,那么就会导致封装的`API`方法只能在我们的`vue`文件中使用,如果在我们的 `vuex` 或者 `vue-router` 中去使用的话,是没办法使用的。
2. 代码可读性差, 在目前项目中,调用一个请求方法可能是这样的

```javascript
import xxxApi from 'xxx/models/xxxApi' // 1. 引入mixin文件
export default {
	mixins: [xxxApi] // 2. 引用
}
// 参数
let params = {
  name: xxx,
  age: xxxx
}
self.hostphysicalList(params).then(res => { // 3.使用
// 接口返回处理
})
```

 如果这个使用在 `vue`的 `method` 定义了另一个`hostphysicalList` 命名相近的方法,这个时候其他成员在阅读代码的时候会比较清楚哪个才是真正的请求方法。

3. 命名空间容易冲突, `api`请求方法名很容易和原本自带的方法名重复。

这种情况下, 势必要对 `Api`的请求方式和架构做调整.

**`API`目录：**

```
└── api
   ├── index.js       # api方法入口文件
   ├── http.js       # api方法核心文件
   ├── modules        # api方法文件夹
        ├── user.js  # 用户模块API方法
        ├── cluster.js # 集群模块API方法
        ├── tenant.js # 租户模块API方法
```

```javascript
// `http.js` 
// 1. 文件配置好`API`的公共配置并导出, 然后在每个方法中引入使用。
import axios from 'axios'
import router from '@/router/routerConfig'
import store from '@/vuex/store'
import Message from '@/components/message/' // 自定义message提示
import VueMessageBox from '@/components/message-box/' // 自定义confirm提示框
import NProgress from 'nprogress'
import sha256 from 'crypto-js/sha256'
import Base64 from 'crypto-js/enc-base64'
/**
 * 请求失败(非200)后的错误统一处理
 * @param {Number} status 请求失败的状态码
 */
const errorHandle = (status, other) => {
  // 状态码判断
  console.log('status', status)
  switch (status) {
    // 404请求不存在
    case 404:
      Message({
        message: '请求不存在！',
        type: 'error',
        duration: 2000
      })
      break
    case 500:
      Message({
        message: '服务端错误！',
        type: 'error',
        duration: 2000
      })
      break
    default:
      Message({
        message: '接口错误',
        type: 'error',
        duration: 1500
      })
      break
  }
}
// 创建axios实例
// console.log('baseURL', baseURL)
const instance = axios.create({
  baseURL: 'xxxx', // 填写API baseURL
  timeout: 1000 * 300,
  headers: {
    'Content-Type': 'application/json'
  },
  cancelToken: true
})
/**
 * 请求拦截器
 * 1. 请求前，如果存在token则在请求头中携带token
   2. POST请求传参加密
   3. 添加cancelToken,处理路由切换请求cancel
 */
instance.interceptors.request.use(config => {
  const systemConfigModuleState = _.cloneDeep(store.state.SystemConfig)
  config.cancelToken = new CancelToken((cancel) => {
    if (!config.noCancel) {
      systemConfigModuleState.httpCancelTokenList.push(cancel)
    }
    store.commit('SystemConfig/setAxiosCancelTokenList', systemConfigModuleState.httpCancelTokenList)
  })
  // 添加 token
  let token = store.state.token
  config.headers.Authorization = token
  // 检测传入集群uuid，不传入则默认使用当前集群uuid
  if (!config.data) {
    config.data = {}
  }
  if (!config.params) {
    config.params = {}
  }
  switch (config.method.toUpperCase()) {
    case 'POST':
    case 'PUT':
    case 'PATCH':
      if (config.method.toUpperCase() === 'POST') {
        // 对POST请求增加参数防篡改机制：
        // 1. 通过 SHA256 > BASE64 > AES 给 请求体进行加密得出秘钥,并放置在请求头中
        // 2. 后端拿到秘钥后再做校验, 校验正确则通过, 失败则直接报错误
      }
      break
  }
  return config
},
error => Promise.error(error)
)

// 响应拦截器
// 关于token机制, 超时后直接弹出确认框跳转到登录页, 无刷新token操作
instance.interceptors.response.use(
  async (response) => {
	return Promise.resolve(response.data)
  },
  // 请求失败(非200)
  error => {
    NProgress.done()
    const { response } = error
    if (response) {
      // 请求已发出，但是不在2xx的范围,直接进入统一错误处理
      errorHandle(response.status, response.data.message)
      return Promise.reject(response)
    } else {
      console.log('error', error.message)
      // 处理断网的情况
      if (!window.navigator.onLine) {
        Message({
          message: '网络异常,请检查网络连接',
          type: 'error',
          duration: 2000
        })
      } else if (error.message === 'routerCancel') { // 接口取消的情况下不提示错误
        return Promise.reject(error)
      } else {
        errorHandle(-1)
        return Promise.reject(error)
      }
    }
  })

export default instance
```

```javascript
// 2. API文件引用axios实例
import axios from './http'
export default {
   /**
	 * 登录
	 * @method managerLogin
	 * @param {String} user 用户名
	 * @param {String} password 用户密码
	 * @param {String} tenant 租户名
	*/
  login (params) {
    return axios.post('/login', params)
  },
}
```

```javascript
// index.js 充当入口文件
import user from './modules/user'
export default {
    user
}
```

实际使用会将所有`API`方法,挂载到 `vue`实例上, 即：

```javascript
// main.js
import Vue form 'vue'
Vue.prototype.$Api = Api
```



最终使用效果:

- 每个模块的`api`方法要在`api/index.js`文件引入后才可调用

* `vue`文件中使用, 因为已经挂载到`vue.prototype.$Api`对象上,直接 `this.$Api['模块名称'].函数名()`即可

- 非`vue`文件中使用, 如 `store`、`router`中的`js`使用, 则直接`import`对应的模块

```javascript
例: import authApi from '@/api/modules/authorization'
引用 => auth.函数名() 即可
```



更换新的`API`方式后, 可以带来以下的优点：

1. 拓展性强, 所有参数与`axios`文档无异, 也可以使用`axios`的所有功能
2. 可读性强, 使用方便
3. 适用范围广, 在`vue`文件和普通`js`文件中都可以使用封装好的`axios`实例
4. 增加路由切换, 将上一页面`pengding`的请求`cancel`, 节省流量



### 3) 代码封装问题

目前的前端项目之所以频繁出现 改了一个 `bug` 又出现其他 `bug` 的原因,除了有程序员粗心以外,我觉得还有另外几个原因：

- 项目中单个`vue`文件代码过于臃肿,冗余,修改功能和修复`bug`十分困难,往往就是几千行代码

- 过多使用 `mixin` 来进行代码封装,导致代码可读性差

- 各组件之间高度耦合
- 变量经常被过多依赖
  ....

建议:

1.  以一个文件代码不超过`1k`行的标准(根据实际情况而定)来规定, 超过`1k`行的代码,即要拆分为组件,如发现该功能存在复用的情况,则可直接封装。
2. 多使用[ES6的module功能](http://es6.ruanyifeng.com/#docs/module)封装代码(如某些功能函数), 少使用 `mixin` , `ES6` 的 `module `使用更加方便且通用.我所认为需要使用 `mixin` 的场景,应当是一些功能逻辑不复杂的工具方法,如表单自定义验证方法,可以使用, `mixin` 使用过多会导致后期维护和组件封装十分困难, 变量来源不可知、变量污染、代码可读性差的问题

3. 修改某个方法和变量时,应注意该方法是否在其他地方使用,如有,则要做兼容处理,否则容易出现,另一个使用该方法的地方出现问题

4. 少定义公共变量。



### 4) 代码规范

在多人协作的项目中, 制定并共同遵循同一个代码规范是非常必要的,这无论对于新成员阅读代码或是其他成员修改阅读代码都是很有帮助的,我们的`JS`中已经有了相应的工具是帮助我们制定规范，即 `ESlint` ,其中我较为推荐的是 `standrd` 规则

JavaScript Standard 规则细则: https://standardjs.com/rules-zhcn.html

这个规则也是大部分前端团队中用的比较多的规范,在我们的前端项目使用它并安装 VS code 相关插件,即可实现自动代码格式化且符合 `standard `代码规范。

> 代码命名

`JS`命名是统一使用小驼峰写法,

至于`CSS`的命名规范,个人是比较推崇 `BEM` 的命名方式的, https://juejin.im/post/5cc28ed46fb9a032086dd3d3

剩下的HTML命名的话,则不强制



### 5) 构建配置优化

初始版本的`webpack`配置优化程度不够, 且版本是`2.2.1`,所以干脆对项目`webpack`配置做了升级:

1. 使用 `webpack`4
2. 改造项目结构, 使用`vue/cli@3`创建项目, 并且升级`webpack`版本到`webpack4`
3. 使用`parallel-uglify-plugin`、`HappyPack `多进程编译, 加速编译时间
4. 增加 小于`5kb`的图片转为`base64`
5. 压缩图片和代码, 且删除`console`、`debugger`代码
6. 增加了一键部署的功能



### 6) git commit 提交规范

规则是 **提交类型(修改范围): 提交内容**

提交类型用于说明 `commit` 的类别，只允许使用下面8个标识:
```
'feat', // 新功能（feature）
'bugfix', // bug修复
'docs', // 文档更新
'UI', // 只修改页面样式(不影响代码运行的变动)
'refactor',// 重构（即不是新增功能，也不是修改bug的代码变动）
'common', // 全局级别的修改(如公共组件或公共配置)
'build', // 主要目的是修改项目构建系统(例如 webpack，rollup 的配置等)的提交
'other', // 不属于以上任何类型之一	
```

#### 使用`commitlint`

此外为了规范 git commit内容提交,增加了`commitlint`工具拦截commit提交,

#### 1.全局安装 `commitlint`
```bash
npm install -g @commitlint/cli @commitlint/config-conventional
```
#### 2.项目单独安装

```bash
npm install yorkie --save-dev
```
其他配置文件已修改完成, 安装后提交不合规范的`commit`即会被拦截。





PS: 本文主要是记录在公司的团队项目中, 对前端项目做的一系列优化, 希望能给你带来一些启发。

---

### 参考文献

> [使用webpack4提升180%编译速度](http://louiszhai.github.io/2019/01/04/webpack4/)

