---
title: 你好, 请你解释一下浏览器缓存策略
date: 2021-01-15 16:08:44
tags: 网络
categories: 网络
cover: https://image.xposean.top/blogImage/008.png

---

## 前言

前段时间, 被面试官问了一个之前完全没有留意的问题, 你知道什么是浏览器的缓存策略吗？知道的话,能不能解释一下缓存策略的内容, 这下可把我问懵了, 毕竟那会对于浏览器缓存只是一知半解, 更别说浏览器缓存策略了, 于是下定决定查阅了相关资料, 于是才有了这篇文章。



## 概述

浏览器缓存策略的目的是为了可以降低资源的重复加载, 并提高网页的整体加载速度。

通常缓存策略可分为两种: **强缓存**和**协商缓存**

### 基本流程

1) 浏览器加载资源时, 首先通过 响应头中的`Expires`(时间值)、 `Cache-Control` (相对值)验证强缓存是否可用, 如可用, 则直接从缓存读取资源，不会发请求到服务器。

2) 否则进入协商缓存，即发送 `HTTP` 请求，服务器通过请求头中的`If-Modified-Since`或者`If-None-Match`这些条件请求字段检查资源是否更新

3) 若命中缓存,则返回`304`状态码，告诉浏览器直接从缓存获取资源

4) 若没有命中, 则直接从服务器加载资源



### 异同点

相同的地方: 如果命中, 都是从客户端中读取缓存, 而不是从服务端加载数据。

不同的地方: 强缓存不发送请求到服务端, 而协商缓存会请求到服务端。



> 那我们怎么区分一个请求是使用了协商缓存或强缓存呢？

十分简单, 通过`HTTP`状态码即可得知

命中强缓存的请求, `Status Code`为`200 (from memory cache)`或 `200(from disk  cache)`

![](https://image.xposean.top/20210115163448.png)

命中协商缓存的, `Status Code`为304

---

## 强缓存

强缓存就是通过`Expires`和`Cache-Control`两种**响应头**实现

### **Expires**

`Expires`即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:

```javascript
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

表示资源在*2019年11月22号8点41分*过期，过期了就得向服务端发请求。

这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器本地的时间可能并不一致，那么服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的`HTTP1.1`版本中被抛弃了。

### **Cache-Control**

在`HTTP1.1`中，采用了一个非常关键的字段：`Cache-Control`。这个字段也是存在于响应头中的.

它和`Expires`本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是`max-age`。比如这个例子:

```javascript
Cache-Control:max-age=3600
```

代表这个响应返回后在 **3600 秒**，也就是一个小时之内可以直接使用缓存。

`cache-control`其实可以组合非常多的指令，完成更多场景的缓存判断, 如下图所示：

![](https://image.xposean.top/20210115165642.png)

更多的详情可以查看: [cache-control文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)

值得注意的是, `cache-control`中**禁用缓存**的指令不是 `no-cache`, `no-cache`表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。真正禁用缓存的指令是` no-store`

### 小结

`Expires` 是`http1.0`的产物，`Cache-Control` 是`http1.1`的产物。

`Cache-Control` 相对于 `Expires` 更加准确，它的优先级也更高, 

**当两者都存在时, `Cache-Control`会优先考虑;** 在某些不支持`HTTP1.1`的环境下，`Expires`就会发挥用处。所以`Expires`其实是过时的产物，现阶段它的存在只是一种兼容性的写法。



## 协商缓存

当浏览器对某个资源的请求没有命中强缓存时，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的`http`状态为304并且会显示一个`Not Modified`的字符串

而协商缓存是利用的是`Last-Modified/If-Modified-Since`和`ETag/If-None-Match`这两对`Header`来管理的, 这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存中的两个 tag 不一样。

### **If-Modified-since/Last-Modified**

即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

```javascript
Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
```

浏览器接收到后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。

```javascript
If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT
```

服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中该资源的最后修改时间对比:

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
- 否则返回304，告诉浏览器直接用缓存。响应头中不会再添加 `Last-Modified` 字段



### **If-None-Match/ETag**

`ETag` 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。

浏览器接收到`ETag`的值，会在下次请求时，将这个值作为`If-None-Match`这个字段的内容，并放到请求头中，然后发给服务器。

服务器接收到`If-None-Match`后，会跟服务器上该资源的`ETag`进行比对:

- 如果两者不一样，说明要更新了。返回新的资源，跟常规的`HTTP`请求响应的流程一样。
- 否则返回304，告诉浏览器直接用缓存



### **两者对比**

1. 在精准度上，`ETag`优于`Last-Modified`。优于`ETag` 是按照内容给资源上标识，因此能准确感知资源的变化。而 `Last-Modified` 就不一样了，它在一些特殊的情况下并不能准确感知资源变化，主要有两种情况:

- 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
- `Last-Modified` 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

1. 在性能上，`Last-Modified`优于`ETag`，也很简单理解，`Last-Modified`仅仅只是记录一个时间点，而` Etag`需要根据文件的具体内容生成哈希值。

另外，如果两种方式都支持的话，服务器会优先考虑`ETag`。



## 缓存位置

​	前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache（内存缓存）
- Disk Cache（硬盘缓存）
- Push Cache（推送缓存）

### Service Worker

​	和Web Worker类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Worker使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的

### Memory Cache 和 Disk Cache

`Memory Cache`指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

`Disk Cache`就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：

- 比较大的`JS`、`CSS`文件会直接被丢进磁盘，反之丢进内存
- 内存使用率比较高的时候，文件优先进入磁盘

### Push Cache

即推送缓存，这是浏览器缓存的最后一道防线。是`HTTP/2`的内容，目前应用较少

`Push Cache` 是指 `HTTP2` 在 `server push` 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段, 具体内容可以的可以查看[HTTP/2 简介](https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81)

- `Push Cache` 是缓存的最后一道防线。浏览器只有在 `Memory Cache`、`HTTP Cache` 和 `Service Worker Cache` 均未命中的情况下才会去询问 `Push Cache`。
- `Push Cache `是一种存在于会话阶段的缓存，当 `session` 终止时，缓存也随之释放。
- 不同的页面只要共享了同一个 `HTTP2` 连接，那么它们就可以共享同一个 `Push Cache`。



## 总结

​	以上就是 关于浏览器缓存策略的全部内容了, 既然知道了缓存策略的规则, 那么我们在日常的开发项目中，对资源文件的缓存策略就有一个比较清晰的认识。

​	对于一些**改动比较频繁**的, 例如`index.html`可以使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小, 且不会因为缓存导致请求了旧资源。

​	而对于 **不常变化的资源文件**,，给它们的 `Cache-Control` 配置一个很大的 `max-age=31536000` (一年)，这样浏览器之后请求相同的 `URL `会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (我们的`webpack`就能够实现这种功能)。

在线提供的类库 (如 `jquery-3.3.1.min.js`, `lodash.min.js` 等) 均采用这个模式。



> 参考文章

> [[缓存（二）——浏览器缓存机制：强缓存、协商缓存](https://github.com/amandakelake/blog/issues/41*)]

> [[缓存机制](https://www.hfwang.win/pages/855b44/)]

