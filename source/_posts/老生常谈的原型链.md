---
title: 老生常谈的原型链
date: 2021-03-12 14:43:27
tags: JavaScript
categories: JavaScript
cover: https://cdn.jsdelivr.net/gh/Anonlyy/random-pic/006.png

---
## 前言

今天咱们来谈谈在`JavaScript`中常常被提及的**原型链**, **原型链**的概念比较抽象, 所以初学时会难以理解, 但因为**原型链**又是`JavaScript`中十分重要的概念, 所以学习好原型链是十分有必要的。

## 理解原型链

其实原型链咱们可以拆分成两个关键词:

- 原型(`prototype`)
- 链(`__proto__`)

### 原型(prototype)

原型（prototype）是一个普通的对象，它为构造函数的实例共享了属性和方法。在所有的实例中，引用到的原型都是同一个对象。

> 函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。

以代码为例：

```javascript
// 构造函数 Student
function Student(name) { 
    this.name = name 
    this.study = function () {
        console.log('study js')
    }
}

// 创建2个实例
const xiaoming = new Student('xiaoming')
const xiaohong = new Student('xiaohong')
xiaoming.study()
xiaohong.study()
```

在上面的代码中, 我们创建了2个`Student`实例:`xiaowang`和`xiaohong`, 每个实例都有一个`study`方法, 用来打印`study js`.

如果没有`prototype`会怎样呢？

2个实例中的`study`方法都是独立的, 虽然功能相同, 但在系统中占用的是2分内存, 如果创建的是100个实例，就得占用100份内存,这样的话, 就会造成大量的内存浪费。

```javascript
// 使用prototype
function Student(name) { 
    this.name = name 
}
Student.prototype.study = function() {
	console.log('study js')
}
// 创建2个实例
const xiaoming = new Student('xiaoming')
const xiaohong = new Student('xiaohong')
xiaoming.study() // study js
xiaohong.study() // study js

```

使用 `prototype` 之后， `study` 方法存放在 `Student` 的原型中，内存中只会存放一份，所有 `Student` 实例都会共享它，内存问题就迎刃而解了。

`prototype`设计之初其实就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了`prototype`我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）,那些不需要共享的才创建在构造函数中。

可是还有一个问题 !

> 为什么`xiaohong`和`xiaoming`两个实例能够访问到`Student`原型上的属性和方法呢？

那就得介绍`__proto__`了。



### 链(`__proto__`)

链（`__proto__`）可以理解为一个**指针**，它是实例对象中的一个属性，指向了**构造函数**的原型（`prototype`）。即从一个对象指向该对象的原型对象（也可以理解为父对象）,显然它的含义就是告诉我们一个对象的原型对象是谁。

以代码为例：

```javascript
function Student(name) {
  this.name = name
}
Student.prototype.study = function () {
  console.log('study js')
}
const xiaoming = new Student('xiaoming')
xiaoming.study() // study js
console.log(xiaoming.__proto__ === Studuent.prototype) // true
```

从打印结果可以得出：函数实例的 `__proto__` 指向了构造函数的 `prototype`，上文中遗留的问题也就解决了。

但很多同学可能有这个疑问。

> 为什么调用 `xiaoming.study` 时，访问到的却是 `Student.prototype.study` 呢？

答案在原型链中，我们接着往下看。

### 原型链

原型链指的是：一个实例对象，在调用属性或方法时，会依次从实例本身、构造函数原型、构造函数原型的原型... 上去寻找，查看是否有对应的属性或方法。这样的寻找方式就好像一个链条一样，从实例对象，一直找到 `Object.prototype` ，专业上称之为**原型链**。

同样的拿代码举例：

```javascript
function Student(name) {
  this.name = name;
}
Student.prototype.study = function () {
  console.log("study js");
};

const student = new Student("xiaoming");
student.study(); // study js。
// 1.在实例中没找到，2.在构造函数的原型上找到了。
// 实际调用的是：student.__proto__.study 也就是 Student.prototype.study。

student.toString(); // "[object Object]"
// 1.在实例中没找到。
// 2.在构造函数的原型上也没找到。
// 3.在构造函数的原型的原型上找到了。
// 实际调用的是 student.__proto__.__proto__.toString 也就是 Object.prototype.toString。
```

所以看到， `__proto__` 就像一个链一样，串联起了实例对象和原型。

你可能还会疑问。

> 为什么 `Student.protype.__proto__`是 `Object.protype`呢？

这里有个推导步骤可供参考：

1. 先找 `__proto__` 前面的对象，也就是 `Student.prototype` 的构造函数。

2. 1. 判断 `Student.prototype` 类型， `typeof Student.prototype` 是 `object`。
   2. `object` 的构造函数是 `Object`。
   3. 得出`Student.prototype` 的构造函数是 Object。

3. 所以 `Student.prototype.__proto__ === Object.prototype`。

这个推导方法很实用，除了自定义构造函数对象之外，其他对象都可以推导出正确答案。



### 原型链常见问题

> `Function.__proto__` 是什么？

1. 找`Function`的构造函数

   a. 判断`Function`类型, 即`typeof Function `是 `function`.

   b. `function`类型的构造函数就是`Function`.

   c. 得出`Function`的构造函数是`Function`.

2. 故 `Function.__proto__ === Function.prototype`.

> `Number.__proto__` 是什么？

1. 找`Number`的构造函数

   a. 判断`Number`类型, 即 `typeof Number`是`function`.

   b. `function`类型的构造函数就是`Function`.

   c. 得出`Number`的构造函数是`Function`

2. 故 `Number.__proto__ === Function.prototype`.

> `Object.prototype.__proto__` 是什么？

这里是个特例, 如果按照前面推导步骤, `Object.prototype.__proto__` 是 `Object.prototype`，但这是不对的，因为这样下去原型链就在 `Object` 处无限循环了。

为了解决这个问题，`JavaScript`就直接在规定了 `Object.prototype.__proto__` 为 `null`，打破了原型链的无线循环。

然而 `null` 究竟代表了什么呢？

引用阮一峰老师的 [《undefined与null的区别》](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html) 就是：

> null 表示“没有对象”，即该处不应该有值。

所以 `Object.prototype.__proto`__ 的值为 null 跟 `Object.prototype` 没有原型，其实表达了一个意思。

所以查找属性的时候查到 `Object.prototype` 就可以停止查找了。



那么如果以下这张图片你能看懂, 那也就是你已经理解**原型链**了。

![](https://image.xposean.top/20210312164516.png)